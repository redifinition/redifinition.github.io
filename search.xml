<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>说说健身这件事</title>
      <link href="/2022/03/09/muscle/"/>
      <url>/2022/03/09/muscle/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 运动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 撸铁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些日常跑步记录</title>
      <link href="/2022/03/09/running-1/"/>
      <url>/2022/03/09/running-1/</url>
      
        <content type="html"><![CDATA[<p>从2022年3月9号开始，记录一下自己每天的日常跑步吧~<br>至于为什么要选择这一天作为记录的第一天，因为咱们的汪汪汪今天开始跑步了！！！建议把3.9号定一个纪念日</p><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2022</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-09</p></div></div><div class='timeline-item-content'><p>有氧轻松跑–绕着体育场跑了4.38公里，用时20：47，平均配速4：44，步频172步幅122，平均心率180；还是不习惯路跑，各种上下坡和拐弯消耗了很多体力，然后心率还是居高不下哇，是因为自己跑的太用力吗？</p><div class="fj-gallery"><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220309234903644.png" alt="image-20220309234903644"><br><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220309235034152.png" alt="image-20220309235034152"></p>          </div></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 运动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中长跑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web端服务器部署基本步骤</title>
      <link href="/2022/03/07/screen/"/>
      <url>/2022/03/07/screen/</url>
      
        <content type="html"><![CDATA[<h1>服务器部署常用指令</h1><p>常常面临前后端（特别是后端）部署到服务器的需求，每次部署的时候都到处搜指令，效率十分低下，所以就在这个博客里面慢慢记录一些常用的指令吧。</p><p>参考：</p><p><a href="https://www.runoob.com/linux/linux-comm-screen.html">Linux screen命令 | 菜鸟教程 (runoob.com)</a></p><h2 id="后端（Spring-cloud）ubuntu服务器部署">后端（Spring cloud）ubuntu服务器部署</h2><p>首先在本地build相应的<code>jar</code>文件，然后在服务器的<code>\root</code>目录新建一个文件夹（用于放置你项目的所有文件）然后放入build的<code>jar</code>包。</p><h3 id="新建screen会话">新建screen会话</h3><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720220307185958.png" alt=""></p><p>使用</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctrl+a d键</span><br></pre></td></tr></table></figure><p>退出当前会话</p><p>运行每一个jar包在独立的screen，就完成部署了</p><h3 id="删除会话">删除会话</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">screen -X -S $tr_name quit</span><br></pre></td></tr></table></figure><h2 id="前端部署">前端部署</h2><p>本地运行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>然后会生成一个<code>dist</code>文件</p><p>放进服务器相应的文件里面</p><p>然后开启nginx服务，具体安装和配置方法参考网站。</p><p>大概是首先修改confi文件，然后干嘛…反正不难</p><p>更新中…</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html/css/js三件套复习--grid布局</title>
      <link href="/2022/03/05/grid/"/>
      <url>/2022/03/05/grid/</url>
      
        <content type="html"><![CDATA[<h1>CSS Grid 网格布局教程</h1><p>还有一个月就开始蓝桥杯了。为了血洗”如何看待蓝桥杯只拿三等奖“之耻，是时候复习下三件套啦！</p><blockquote><p>教程来源：CSS grid网格布局教程 --阮一峰的博客</p></blockquote><p>另外推荐一个学习grid布局的网站：scrima，这个网站本来是首收费（$108）但是唯独grid布局是免费的！</p><p><a href="https://scrimba.com/learn/cssgrid/intro-to-the-css-grid-course-cg9PpTb">Intro to the CSS Grid course - Scrimba.com</a></p><p>体验了一下，这个网站做的很牛逼，直接把可编辑的代码和视频教学结合在了一起，值得一试！</p><h2 id="1-Grid-与-Flex-的区别">1 Grid 与 Flex 的区别</h2><p>Flex 布局是轴线布局，只能指定&quot;项目&quot;针对轴线的位置，可以看作是<strong>一维布局</strong>。Grid 布局则是将容器划分成&quot;行&quot;和&quot;列&quot;，产生单元格，然后指定&quot;项目所在&quot;的单元格，可以看作是<strong>二维布局</strong>。Grid 布局远比 Flex 布局强大。</p><h2 id="2-基本概念">2 基本概念</h2><h3 id="2-1-容器和项目">2.1 容器和项目</h3><p>采用网格布局的区域，称为&quot;容器&quot;（container）。容器内部采用网格定位的子元素，称为&quot;项目&quot;（item）</p><p>项目只能是容器的顶层子元素，不包含项目的子元素，Grid 布局只对项目生效。</p><h3 id="2-2-行和列">2.2 行和列</h3><p><img src="https://www.wangbase.com/blogimg/asset/201903/1_bg2019032502.png" alt="img"></p><p>容器里面的水平区域称为&quot;行&quot;（row），垂直区域称为&quot;列&quot;（column）。</p><h3 id="2-3-单元格和网格线">2.3 单元格和网格线</h3><p>行和列的交叉区域，称为&quot;<strong>单元格</strong>&quot;（cell）。划分网格的线，称为&quot;<strong>网格线</strong>&quot;（grid line）。水平网格线划分出行，垂直网格线划分出列。</p><h2 id="3-容器属性">3 容器属性</h2><h3 id="3-1-display属性">3.1 display属性</h3><p><code>display: grid</code>指定一个容器采用网格布局。</p><p>默认情况下，容器元素都是块级元素，但也可以设成行内元素。</p><ul><li><p>容器是块级元素</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032504.png" alt="img"></p></li><li><p>容器是行内元素</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032505.png" alt="img"></p></li></ul><p>​</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，设为网格布局以后，容器子元素（项目）的<code>float</code>、<code>display: inline-block</code>、<code>display: table-cell</code>、<code>vertical-align</code>和<code>column-*</code>等设置都将失效。</p><h3 id="3-2-grid-template-columns-属性，-grid-template-rows-属性">3.2 grid-template-columns 属性， grid-template-rows 属性</h3><p>容器指定了网格布局以后，接着就要划分行和列。<code>grid-template-columns</code>属性定义每一列的列宽，<code>grid-template-rows</code>属性定义每一行的行高。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  grid-template-rows: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了使用绝对单位，也可以使用百分比。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">33.33%</span> <span class="number">33.33%</span> <span class="number">33.33%</span>;</span><br><span class="line">  grid-template-rows: <span class="number">33.33%</span> <span class="number">33.33%</span> <span class="number">33.33%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用<code>repeat()</code>函数简化写法：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">33.33%</span>);</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">2</span>, <span class="number">100px</span> <span class="number">20px</span> <span class="number">80px</span>);</span><br></pre></td></tr></table></figure><h4 id="auto-fill-关键字">auto-fill 关键字</h4><p>有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用<code>auto-fill</code>关键字表示自动填充。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(auto-fill, <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="grid中auto-fit和auto-fill的区别"><strong>grid中auto-fit和auto-fill的区别</strong></h4><pre><code>auto-fill:在轨道重复过程中，尽可能多的根据元素创建轨道，如果创建的轨道数量是小数比如6.5，那么0.5就被称为剩余空间，剩余的空间不够一个轨道了，就相当于每个轨道1fr进行分配这个0.5的剩余空间，没有元素填充的空轨道不会折叠依然保留（相当于留了空白）。auto-fit:在轨道重复过程中，尽可能多的根据元素创建轨道，并均分不到一个轨道的剩余空间。轨道分配完以后如果轨道中没有元素则将所有没有元素填充的空轨道折叠为0，即把没有元素填充的空轨道全被分配给有元素的轨道（相当于有元素填充的轨道全部为1fr）。最后没有空轨道剩余</code></pre><p><strong>scrima中给出的直观解释：</strong></p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305215542906.png" alt="image-20220305215542906"></p><h4 id="auto-fit关键字">auto-fit关键字</h4><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305210303497.png" alt="image-20220305210303497"></p><p>这个写法真的很棒！！！</p><p><a href="https://scrimba.com/learn/cssgrid/auto-fit-and-minmax-css-grid-tutorial-cg92LA6">Auto-fit and minmax - CSS Grid tutorial - Scrimba.com</a></p><p><code>minmax</code>的加入使得每个块可以根据屏幕大小变化宽度适应整个画面</p><h4 id="fr关键字">fr关键字</h4><p>为了方便表示比例关系，网格布局提供了<code>fr</code>关键字（fraction 的缩写，意为&quot;片段&quot;）。如果两列的宽度分别为<code>1fr</code>和<code>2fr</code>，就表示后者是前者的两倍。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">150px</span> <span class="number">1</span>fr <span class="number">2</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="minmax">minmax()</h4><p><code>minmax()</code>函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="built_in">minmax</span>(<span class="number">100px</span>, <span class="number">1</span>fr);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>minmax(100px, 1fr)</code>表示列宽不小于<code>100px</code>，不大于<code>1fr</code>。</p><h4 id="auto关键字">auto关键字</h4><p><code>auto</code>关键字表示由浏览器自己决定长度。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> auto <span class="number">100px</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了<code>min-width</code>，且这个值大于最大宽度。</p><h4 id="grid-template">grid-template</h4><p>是<code>grid-template-columns</code>和<code>grid-template-rows</code>的合体，比如下面的写法：</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305160832455.png" alt="image-20220305160832455"></p><p>可以想象使用”L“绘制网页：先规定rows也就是纵向，后规定columns也就是横向。</p><h4 id="网格线的名称">网格线的名称</h4><p><code>grid-template-columns</code>属性和<code>grid-template-rows</code>属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: [c1] <span class="number">100px</span> [c2] <span class="number">100px</span> [c3] auto [c4];</span><br><span class="line">  grid-template-rows: [r1] <span class="number">100px</span> [r2] <span class="number">100px</span> [r3] auto [r4];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。</p><p>网格布局允许同一根线有多个名字，比如<code>[fifth-line row-5]</code>。</p><h4 id="布局实例">布局实例</h4><p><code>grid-template-columns</code>属性对于网页布局非常有用。两栏式布局只需要一行代码。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">70%</span> <span class="number">30%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码将左边栏设为70%，右边栏设为30%。</p><p>传统的十二网格布局，写起来也很容易。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">12</span>, <span class="number">1</span>fr);</span><br></pre></td></tr></table></figure><h3 id="3-3-grid-row-gap属性-grid-colum-gap属性，grid-gap属性">3.3 grid-row-gap属性 grid-colum-gap属性，grid gap属性</h3><p><code>row-gap</code>属性设置行与行的间隔（行间距），<code>column-gap</code>属性设置列与列的间隔（列间距）。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    row-gap: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">column-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gap</code>属性为两个属性的合并简写形式：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  grid-gap: <span class="number">20px</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-grid-template-areas属性">3.4 grid-template-areas属性</h3><p>网格布局允许指定&quot;区域&quot;（area），一个区域由单个或多个单元格组成。<code>grid-template-areas</code>属性用于定义区域。</p><p>下面是一个布局实例。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-areas: <span class="string">&quot;header header header&quot;</span></span><br><span class="line">                     <span class="string">&quot;main main sidebar&quot;</span></span><br><span class="line">                     <span class="string">&quot;footer footer footer&quot;</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，顶部是页眉区域<code>header</code>，底部是页脚区域<code>footer</code>，中间部分则为<code>main</code>和<code>sidebar</code>。</p><p>如果某些区域不需要利用，则使用&quot;点&quot;（<code>.</code>）表示。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-areas: <span class="string">&#x27;a . c&#x27;</span></span><br><span class="line">                     <span class="string">&#x27;d . f&#x27;</span></span><br><span class="line">                     <span class="string">&#x27;g . i&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。</p><p>注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为<code>区域名-start</code>，终止网格线自动命名为<code>区域名-end</code>。</p><p>比如，区域名为<code>header</code>，则起始位置的水平网格线和垂直网格线叫做<code>header-start</code>，终止位置的水平网格线和垂直网格线叫做<code>header-end</code>。</p><h3 id="3-5-grid-auto-flow属性">3.5 grid-auto-flow属性</h3><p>grid-auto-flow决定了容器的子元素放入的顺序，默认为”先行后列“。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-<span class="attribute">auto</span>-flow: column;</span><br></pre></td></tr></table></figure><p>这样就变成先列后行</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032513.png" alt="img"></p><p>如上所示的效果</p><p>使用了如下的css:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#container</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  grid-template-rows: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  grid-<span class="attribute">auto</span>-flow: row;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ef342a</span>;</span><br><span class="line">  grid-column-start: <span class="number">1</span>;</span><br><span class="line">  grid-column-end: <span class="number">3</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item-2</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f68f26</span>;</span><br><span class="line">  grid-column-start: <span class="number">1</span>;</span><br><span class="line">  grid-column-end: <span class="number">3</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>grid-column-start</code>和<code>grid-column-end</code>让1和2 占据了两个单元格</p><p>现在修改设置，设为<code>row dense</code>，表示&quot;先行后列&quot;，并且尽可能紧密填满，尽量不出现空格。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-<span class="attribute">auto</span>-flow: row dense;</span><br></pre></td></tr></table></figure><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032514.png" alt="img"></p><p>上图会先填满第一行，再填满第二行，所以3号项目就会紧跟在1号项目的后面。8号项目和9号项目就会排到第四行。</p><h4 id="使用dense实现照片墙的例子">使用dense实现照片墙的例子</h4><p><a href="https://scrimba.com/learn/cssgrid/an-awesome-image-grid-css-grid-tutorial-cBq3PsP">An awesome image grid - CSS Grid tutorial - Scrimba.com</a></p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305213136445.png" alt="image-20220305213136445"></p><h3 id="3-6-justify-items，align-items-place-items属性">3.6 justify-items，align-items,place-items属性</h3><p><code>justify-items</code>属性设置单元格内容的水平位置（左中右），<code>align-items</code>属性设置单元格内容的垂直位置（上中下）。</p><p>这两个属性的写法完全相同，都可以取下面这些值。</p><ul><li>start：对齐单元格的起始边缘。</li><li>end：对齐单元格的结束边缘。</li><li>center：单元格内部居中。</li><li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  justify-items: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032516.png" alt="img"></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示，单元格的内容头部对齐，效果如下图。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032517.png" alt="img"></p><p><code>place-items</code>属性是<code>align-items</code>属性和<code>justify-items</code>属性的合并简写形式。如：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-items: start end;</span><br></pre></td></tr></table></figure><h3 id="3-7-justify-content-align-content-place-content属性">3.7 justify-content,align content,place-content属性</h3><p>先上一个有趣的教程示例：</p><p><a href="https://scrimba.com/learn/cssgrid/justify-content-and-align-content-css-grid-tutorial-cGpB8t7">justify-content and align-content - CSS Grid tutorial - Scrimba.com</a></p><p><code>justify-content</code>属性是整个内容区域在容器里面的水平位置（左中右），<code>align-content</code>属性是整个内容区域的垂直位置（上中下）。</p><p>这两个属性的写法完全相同，都可以取下面这些值。（下面的图都以<code>justify-content</code>属性为例，<code>align-content</code>属性的图完全一样，只是将水平方向改成垂直方向。）</p><blockquote><ul><li>start - 对齐容器的起始边框。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032519.png" alt="img"></p><blockquote><ul><li>end - 对齐容器的结束边框。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032518.png" alt="img"></p><blockquote><ul><li>center - 容器内部居中。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032520.png" alt="img"></p><blockquote><ul><li>stretch - 项目大小没有指定时，拉伸占据整个网格容器。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032521.png" alt="img"></p><blockquote><ul><li>space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032522.png" alt="img"></p><blockquote><ul><li>space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032523.png" alt="img"></p><blockquote><ul><li>space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032524.png" alt="img"></p><p><code>place-content</code>属性是<code>align-content</code>属性和<code>justify-content</code>属性的合并简写形式。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-<span class="attribute">content</span>: &lt;align-content&gt; &lt;justify-content&gt;</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-<span class="attribute">content</span>: space-around space-evenly;</span><br></pre></td></tr></table></figure><h3 id="3-8-grid-auto-columns，grid-auto-rows属性">3.8 grid-auto-columns，grid-auto-rows属性</h3><p>有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。</p><p><code>grid-auto-columns</code>属性和<code>grid-auto-rows</code>属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与<code>grid-template-columns</code>和<code>grid-template-rows</code>完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p><p>例子：</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305211409763.png" alt="image-20220305211409763"></p><h2 id="4-项目属性">4 项目属性</h2><p>下面这些属性定义在项目上面。</p><h3 id="4-1-grid-row-start，grid-row-end属性">4.1 grid-row-start，grid-row-end属性</h3><p>项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。</p><ul><li><code>grid-column-start</code>属性：左边框所在的垂直网格线</li><li><code>grid-column-end</code>属性：右边框所在的垂直网格线</li><li><code>grid-row-start</code>属性：上边框所在的水平网格线</li><li><code>grid-row-end</code>属性：下边框所在的水平网格线</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  grid-column-start: <span class="number">2</span>;</span><br><span class="line">  grid-column-end: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032526.png" alt="img"></p><p>比如上面的指定了左右边框所在的网格线。</p><p>除了1号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的<code>grid-auto-flow</code>属性决定，这个属性的默认值是<code>row</code>，因此会&quot;先行后列&quot;进行排列。读者可以把这个属性的值分别改成<code>column</code>、<code>row dense</code>和<code>column dense</code>，看看其他项目的位置发生了怎样的变化。</p><p><a href="https://jsbin.com/yukobuf/edit?css,output">JS Bin - Collaborative JavaScript Debugging</a></p><p>可点击如上的网址进行理解和练习。</p><p>这四个属性的值还可以使用<code>span</code>关键字，表示&quot;跨越&quot;，即左右边框（上下边框）之间跨越多少个网格。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  grid-column-start: span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这四个属性，如果产生了项目的重叠，则使用<code>z-index</code>属性指定项目的重叠顺序。</p><h3 id="4-2-grid-column属性，grid-row属性">4.2 grid-column属性，grid-row属性</h3><p><code>grid-column</code>属性是<code>grid-column-start</code>和<code>grid-column-end</code>的合并简写形式，<code>grid-row</code>属性是<code>grid-row-start</code>属性和<code>grid-row-end</code>的合并简写形式。</p><h3 id="4-3-grid-area属性">4.3 grid-area属性</h3><p><code>rid-area</code>属性还可用作<code>grid-row-start</code>、<code>grid-column-start</code>、<code>grid-row-end</code>、<code>grid-column-end</code>的合并简写形式，直接指定项目的位置。</p><blockquote><p>.item {<br>grid-area: <row-start> / <column-start> / <row-end> / <column-end>;<br>}</p></blockquote><p>下面是一个<a href="https://jsbin.com/duyafez/edit?css,output">例子</a>。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  grid-area: <span class="number">1</span> / <span class="number">1</span> / <span class="number">3</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，scimba网站还给出了grid-area的另一种用法：</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305203819913.png" alt="image-20220305203819913"></p><p><strong>另外一个有趣的用法</strong></p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305213953945.png" alt="image-20220305213953945"></p><h3 id="4-4-justify-self，align-self-place-self属性">4.4 justify-self，align-self,place-self属性</h3><p><code>justify-self</code>属性设置单元格内容的水平位置（左中右），跟<code>justify-items</code>属性的用法完全一致，但只作用于单个项目。</p><p><code>align-self</code>属性设置单元格内容的垂直位置（上中下），跟<code>align-items</code>属性的用法完全一致，也是只作用于单个项目。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  justify-self: start | end | center | stretch;</span><br><span class="line">  <span class="attribute">align-self</span>: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个属性都可以取下面四个值。</p><ul><li>start：对齐单元格的起始边缘。</li><li>end：对齐单元格的结束边缘。</li><li>center：单元格内部居中。</li><li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li></ul><p>下面是<code>justify-self: start</code>的例子。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span>  &#123;</span><br><span class="line">  justify-self: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032532.png" alt="img"></p><p><code>place-self</code>属性是<code>align-self</code>属性和<code>justify-self</code>属性的合并简写形式。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-self: &lt;align-self&gt; &lt;justify-self&gt;;</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-self: center center;</span><br></pre></td></tr></table></figure><p>如果省略第二个值，<code>place-self</code>属性会认为这两个值相等。</p><h2 id="5-scrima上面的示例">5 scrima上面的示例</h2><p><a href="https://scrimba.com/learn/cssgrid/positioning-items-css-grid-tutorial-cbVn4t4">Positioning items - CSS Grid tutorial - Scrimba.com</a></p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305161906343.png" alt="image-20220305161906343"></p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305162045130.png" alt="image-20220305162045130"></p><h2 id="6-flex-和-grid配合使用">6 flex 和 grid配合使用</h2><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305220701719.png" alt="image-20220305220701719"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个梦---谈谈保留这首歌</title>
      <link href="/2022/03/02/emo202232/"/>
      <url>/2022/03/02/emo202232/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-zayZcwOw" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="442869203" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#FF4081"    ></div><p>2022年3月2日23：59分。</p><p>刚才在寝室洗衣服时，耳机里放着网易云”我喜欢“的歌单，随机播放。因为我的歌单里有很多首歌，快1000首了，大抵都是听一遍觉得不错便扔进了歌单里，所以每次随机播放时，都能稍稍体会到好奇下一首是哪首歌的快感</p><p>突然脑海里播放了这首歌。<br>郭顶的《保留》。这首歌没有前奏，不给人任何心理准备，一来就是“看见，你在我眼前。”<br>听后遍有一种心里很沉重很难受的感觉。是的，因为这首歌以它的方式提醒我：我三年来一直秉持的信仰和坚持（虽然中途放弃过），破碎了。<br>我本以为我快要走出来了，可是一听到这首歌，立马发现自己还在原地踏步，并且还时不时地回头看。<br>三年前，我和她走在大学路的街道上，突然听见远方唱歌的声音。一位弹着吉他的流浪歌手，唱着《保留》，声音低沉悠扬。我们当时不知道这首歌，但都被歌词和旋律深深吸引。一首歌，几句歌词，让两个人的世界第一次相交，碰撞，重叠，燃烧。<br>这首歌一听就是三年，两个人。在四平路，在嘉定。在呼伦贝尔，在成都的夜晚。在中国。在法国。<br>最终歌曲放完了。对我而言很像是一场梦，有时候会觉得是噩梦想要抽离，可真的快抽离时却发现自己十分迷恋，想一直做下去。<br>正当自己认为这场梦可以一直做，做到毕业，做到工作，做到自己有自己的一片乐土时，它碎了。<br>可能自己心里真的未放下吧，所以写的十分的抽象。或许有一天自己真正放下向前看的时候，这个梦会变得越来越清晰，清晰到我能够真正真切地去面对，能真正的觉得它是一段美好的回忆。</p><p>好了，抽象emo结束。有一说一，这首歌我还是很喜欢的。郭顶是我很喜欢的歌手，而这首歌也是他的歌里面我最喜欢的。下面是他的完整歌词，因为个人经历会觉得歌词承载的太多，不敢去过度理解，不过不影响这真的是一首好作品。</p><p>不emo了，明早还有游泳课，有的爽了。</p><p>看见 你在我眼前</p><p>不去猜想我们隔多远</p><p>当我 夜幕中准备</p><p>只想让沉默的能开解</p><p>在不同的遭遇里我发现你的瞬间</p><p>有种不可言说的温柔直觉</p><p>在有限的深夜消失之前触摸你的脸</p><p>我情愿这是幻觉 也不愿是种告别</p><p>已经忘了 你的名字</p><p>就在这座 寂静星石</p><p>怎么还有 你的样子</p><p>被保留</p><p>给我 一整个拥抱</p><p>好让我不至于 太潦倒</p><p>时间 过一分一秒</p><p>还是觉得相遇 太美好</p><p>在不同的遭遇里我发现你的瞬间</p><p>有种不可言说的温柔直觉</p><p>当不远的蓝色渐渐显现这无边境界</p><p>我始终等待再见 只不愿再也不见</p><p>已经忘了 你的名字</p><p>就在这座 寂静星石</p><p>怎么还有 你的样子</p><p>想形容你的句子 关于你所有心事</p><p>一眼能及的钻石 哪一个是你地址</p><p>忘了 你的名字</p><p>就在这座 寂静星石</p><p>怎么还有 你的样子</p><p>我始终等待再见 只不愿再也不见</p><p>真的忘了 你的名字</p><p>是在哪座 寂静星石</p><p>一直还有 你的样子</p><p>被保留</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> emo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>被讨厌的勇气--读书心得</title>
      <link href="/2022/03/02/book1/"/>
      <url>/2022/03/02/book1/</url>
      
        <content type="html"><![CDATA[<p>上大学期间一直不怎么看书。最近受某位同学的推荐阅读了这本书，通篇大部分为一个年轻人和哲人的对话，初读感觉里面讲的人生哲学非常的唯心主义，他否定了过去经历和所处环境对人性格形成的影响，而将我们后来对自己”人设“的认知和性格的形成归结为我们自己的选择。说实话，这种观点目前我是无法苟同的，不过现在还没读完这本书，等读完了在这里记录一下看法和感受吧！</p>]]></content>
      
      
      <categories>
          
          <category> 读书心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说跑步这件事</title>
      <link href="/2022/03/01/running/"/>
      <url>/2022/03/01/running/</url>
      
        <content type="html"><![CDATA[<h2 id="说说为啥喜欢长跑">说说为啥喜欢长跑</h2><p>长跑这项运动算是高中的时候就喜欢上了吧。其实初中的时候挺讨厌长跑的，因为不及格，老师让我跳蛙跳。不服气呗，所以后来1000米就死命跑，心里想的就是拼了命也要超过别人。最后中考马马虎虎，刚好过线。</p><p>​高中的时候流行夜跑嘛，晚上下了课喜欢几个人约着一起到操场夜跑+散步。后来高三压力大了，我因为个人原因整个高三就蛮抑郁的，突然想起来初中跑1000米那种拼劲，和考试相比，这可能是唯一一个付出100%努力，就能跑的比别人快的事情了。同时跑步的时候可以什么都不想，当作白天学习后释放压力放空自己的活动很合适（并且我很喜欢那种跑步超过别人的感觉？）于是那时就开始每天夜跑，不多不少5公里。</p><p>​再后来到了高三上期中的时候，开始想在这方面出一点成绩，于是就拿起个小本本开始做计划（那个小本子其实是我的日记本，现在还在我宿舍的书架上）开始设定目标，设定每个阶段应该达成的进步（记得当时的目标是参加1500米校运会，跑到5：15秒以内，也就是每1000米3：30以内完成），然后还专门留了一页纸，画了一个坐标系，横轴是时间，纵轴是1500米所用分钟数，然后画了一个基准线就是5：15的时间，基准线还画在中间的位置，因为觉得自己可以练到更快。哈哈哈，当时设想的美好画面当然是一条单调递减的曲线，晚自习的时候瞎画在那里咯咯咯的笑。同桌看了笑出声：”别人写学习计划，你tmd写跑步计划，宁这是高三？“不过yysy，我高三就是压力太大了，其实超努力的qaq.</p><p>​理想很丰满，现实很艹蛋。我现在还记得那时第一次训练，1500米跑了6：18.整整比目标慢了一分钟。起点低没事，咱慢慢练嘛。结果呢，那个坐标系里压根就是条正弦曲线，一会跑到5：50，以后又回到6：20去了，就尼玛离谱，每次跑的时候还贼累。</p><p>​现在看来当时那根本就不叫训练，完全就是瞎练，不知道啥是间歇跑，不知道啥是力量训练。不过也算是死磕了吧（日记本好像忘家里了hehe，不过记得很清楚当时至少标注了三十个点），虽然没有一次到达过目标。</p><p>​然后就去报校运会了。笑死，本来1500米就是一个大家不愿意报的运动项目，又正值高三，大家都觉得主动报的要么是行为艺术要么就是想逃习题课。一般如果没人报的话就得抓壮丁了。我记得当时举手之后，大家像看救世主一样看我。这个班级又少了一次磨难。</p><p>​说句实话，当时心里很期待那种自己在赛场上拼（zhuang）搏(bi)，台下同学加油呐喊的感觉，懂得都懂，不懂的都不懂。不过很可惜，高三学业繁重，没有运动项目的同学就在教室自习不去操场了。当时心里还是挺失落的。（怎么说呢，可能是骨子里自卑，喜欢通过这件事获得别人的认可，我承认哈哈哈）不过班主任很人道主义，规定每个项目必须有至少两名同学陪同加油助威。带着这份感恩，我就穿上丝袜去操场参赛了。</p><p>​具体比赛细节就不说了哈，其实当时还有很多同学偷偷跑下来给我加油了，当时真的很热血，或许他们是我这份爱好养成的突出贡献者哈哈哈，最后5：18，第三名（高三大家的身体素质是真的普遍退步了）虽然没达到自己定的目标，不过真的很满意了。</p><p>​这件很不起眼的小事，为啥要这么罗嗦呢？说真的它真的算是我高三抑郁生活的一大精神支柱了。很多时候心态快崩的时候都靠跑步顶住了。</p><p>​大学算是轻松了，也就开始随便跑跑，偶尔参加参加学校的校园活动，偶尔看看训练技巧，大一校运会1500米马马虎虎5：03，第九名（刚好没奖状，哈哈），摸爬滚打到了现在。</p><p>所以说现在到底为啥喜欢长跑呢？<br><strong>喜欢到每次跑步必须把仪式感拉满，必须穿背心、短裤、紧身长袖长袜<br>喜欢到上学期直接跑到腿瘸（被xian哥多次警告别再练了hhh）<br>喜欢到像现在这样作为自己值得骄傲的一件事<br>它带给我的挺简单的，我在跑步的时候感受到自己尚存的自律和拼劲<br>找回自己其实并不经常存在的自信的状态<br>跑步的时候真的可以什么都不想 或者想明白一些平时想不明白的事情<br>唯一一点不喜欢的是<br>和健身增肌是冲突的！！！跑完能感觉到自己刚练的肌肉又掉了…</strong></p><h2 id="知乎的一篇回答">知乎的一篇回答</h2><p>​上学期（大三上）又是喜欢长跑到近乎狂热的一学期。为啥呢？因为我长胖了！！！长胖了！！！长胖了！！！能想象？一个千年玉米杆子因为一学期+一个暑假没咋运动直接有小肚子，135斤。想想以前经常长跑，还参加校运会，都快不认识这么肥宅的自己了。</p><p>​于是又是以增肌减脂为起因（这个时候也办了1年健身再健身的健身卡）开始慢慢恢复。刚开始跑步的时候那叫一个酸爽，跟双腿安了假肢一样，第一次跑了2公里，配速直接飞到6：30，那绝望是真的绝望。然后就继续死磕吧，每次都几乎用到90%的力气，死磕5公里，慢慢配速降到了4：30，算是可以接受的地步。</p><p>​也是在这个时候开始在知乎小破站学习训练速耐的技巧（暂时不敢接触半马这种长距离，怕腿受伤w），练习间歇跑。给自己定下的flag很简单：1000米体测3：10内。最后跑了3：06，说实话，真的超有成就感。在经历了长胖危机后，刷新了1000米速耐pb.</p><p>​之后带着这种自负和狂妄在知乎上发了篇回答：</p><p><a href="https://www.zhihu.com/question/325715679/answer/2088568177">(44 封私信 / 80 条消息) 大学生体测1000米满分（3分16秒）有多难? - 知乎 (zhihu.com)</a><br>上原回答：<br>2021.11.7号更新</p><p>今天下午去体测啦 听说上海今天要降温十多度 立马赶着降温前去测试了 当时下着小雨。</p><p>然后结果出来了<br><img src="https://pic1.zhimg.com/80/v2-ec606df9aec7585674236616f4e807e5_720w.jpg?source=1940ef5c" alt="img"></p><p>3:06 比上次的PB快了十秒…</p><p>算是了却了自己的心愿吧！！！</p><p>2021.11.3更新</p><p>间歇跑真香！！！</p><p>开学以来陆陆续续跑了两个月了。跑量大概150km左右，每月80。</p><p>最开始还是死磕五公里，配速不上不下，4:30左右，然后真就感觉越跑越累。</p><p>然后在知乎上问了各路大神后，听取了“练1000不要尝试接触3:30-5:00的配速的建议。</p><p>开始每周2-3次400米间歇。大概是400米间歇1:20跑完，中间休息2min，连续5组。最开始跑真的很吃力，第三组的时候已经没力气了，跑完也很难受…不过不得不说间歇跑对提高1000米速耐真的很有帮助。</p><p>陆陆续续练了有十次吧。现在基本一组400可以1:14内跑完，五组下来不是特别累。其他时间就是5km5分配慢跑，练练有氧顺便减脂。</p><p>然后有一天发现，4:55跑完五公里后，试了试冲刺一下800。结果看时间， 800用了2:35。最后6公里配速4:40，这可比以前累死累活4:30舒服多了。</p><p>所以这里给大家的建议是平时可以慢跑间歇交替进行。慢跑的话25min跑个5公里就好啦，间歇的话400跑不下来就从200开始，这样正好跑200走200，非常方便。相信我，间歇对于1000的进步太大了。</p><p>现在跑1000和以前的跑姿也有了变化。以前都是一个劲冲，姿势从头到尾都是变形的。现在3:00配冲哥800身体基本比较稳，跑姿不会有什么变化，核心力量也提升了。</p><p>马上就要体测啦，希望大家都可以跑到自己满意的成绩！！！</p><p>我也希望今年能进一次3:05….加油！</p><p>————————————————分割线———————————</p><p>先放个图吧。去年（2020）十一月大二体测跑的。</p><p>当时拿着手机用keep记录了一下。刚好满分。（老师测的3:16，keep有些许延迟）</p><p><img src="https://pic3.zhimg.com/80/v2-1e82d5845156be6e836d49bad727fe4f_720w.jpg?source=1940ef5c" alt="img"><br>再随便截一张平时跑步的图<br><img src="https://pic2.zhimg.com/80/v2-0968fb4d245b33ac75818b5c9c077618_720w.jpg?source=1940ef5c" alt="img"></p><p>大学生1000米满分对于正常人来说的确有点难。</p><p>我在初中的时候因为1000米不及格被老师叫着去操场跳蛙跳，间歇跑，练着练着成绩就上来了。记得初中体考的时候3:33（当时满分是3:48）</p><p>高中的时候因为压力大就把参加运动会1500米项目作为自己的目标之一，下了晚自习就跑，每天晚上五公里左右，速度不算快，4:30-5:00配速的样子，当作发泄吧。</p><p>然后我记得高三那次校运会1500米5:15秒，居然还拿了个第三 （可见高中大家的身体素质都比较一般）</p><p>到了大学的跑步频率明显减少了，加了个跑协混混，偶尔参加个校园跑，偶尔跑个五公里，大一校运会1500米前一个月突击训练了一下，然后跑了5:03，第九名 （第一名我记得是4:30好像）大学高手还是很多的。那个时候我记得体育体测1000米好像3:10秒的样子，跑满分还算轻松。</p><p>后来到了大二，因为各种原因运动减少了，很少跑步，然后就有了图一的成绩，3:16，非常吃力，跑完半条命没了。</p><p>然后到了这学期 ，基本一学期没运动过，体重直接重5kg，耐力明显下降了。（最近有开始恢复训练，但跑5公里五分配速都很吃力。）</p><p>可见，要想大学1000米拿满分并且保持这个成绩的话。除了体重要控制的较好以外，一定频率的训练还是必不可少的。我的建议是至少一周2-3次五公里跑或者间歇跑，用自己60-70%的力气，5公里的话一开始配速5:30就行，然后慢慢减。如果练到5公里21:00以内跑完的话，其实1000米跑满分也不算难了。跑进20:00的话，可以尝试一下1500校运会，说不定能拿名次。</p><h2 id="这学期的训练计划">这学期的训练计划</h2><p>截至2022年3月8号，开学的跑量大概也有40km的样子了，用了两周的时间完成了别人一次就能跑完的全马…每次2km-5km不等，配速大概在4：00-4：20不等<br><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/IMG_9868.PNG" alt="IMG_9868"><br>keep上大概记录了25km左右，还有一些在iwatch和搞笑体育上。下面说说近一个月的训练安排吧！！</p><p><strong>每周跑步的频率在3-5次，不宜太多，给自己充分的休息时间(充分的精力撸铁，由于增肌和有氧训练冲突，思考了很久还是决定以增肌为主了)。然后每周安排1-2次的间歇跑，其他时候为有氧跑，下面具体说说这两种吧！</strong></p><h3 id="间歇跑">间歇跑</h3><p>很肝也很爽的训练，不过得等到人稍微少的时候-_-<br>热身跑1圈，配速6：00-6：30左右，身子一定要跑热<br>然后开始400m间歇，每次完成的时间很重要<br>这学期我给自己的目标是1000m跑到3：00（感觉会很难qaq）<br>所以换算下来，400m要在1：12内完成。（等等，真的能做到？）<br>由于这个要求有点太高，那就给自己的休息时间长一点，休息2分钟左右<br>然后继续<br>这样持续下来，最好能跑完5组，也就是2km。<br>最开始可以从圈速1：14开始，慢慢减。（感觉每减1秒都会很难)<br>跑完后再慢跑一圈<br>然后拉伸</p><h3 id="有氧跑">有氧跑</h3><p>这个就很轻松了，就是越轻松越好，热身后跑5-10km吧<br>配速5：00左右就行，5：30也可，调整调整自己的心肺节奏</p><p>另外这学期还是不打算接触半马全马这种超长距离了，一跑感觉自己增肌的努力就白费了<br>加油！！！<br>另外暑期实习面试加油！！！</p>]]></content>
      
      
      <categories>
          
          <category> 运动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中长跑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode刷题笔记--数组</title>
      <link href="/2022/02/05/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84/"/>
      <url>/2022/02/05/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-bCNokrZI" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="482655706" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#FF4081"    ></div><h1>LeetCode数组专题</h1><h2 id="1-数组的二分查找">1. 数组的二分查找</h2><p>该类型题的一个典型特点是时间复杂度为O(logn)型，且数组都是有序的序列，一般这个时候查找某些元素的位置就会想到二分查找算法。</p><h3 id="704-二分查找">704.二分查找</h3><p>二分查找条件：有序+无重复数组</p><p>注意边界条件和区间的写法</p><ol><li><p>左闭右闭[left≤right]，这时while循环的条件为while(left≤right)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span>(target &lt; nums[mid])&#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">                mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; nums[mid])&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">                mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>左闭右开区间[left,right)，此时的循环条件是while(left&lt;right)</p></li></ol><h3 id="35-搜索插入位置">35.搜索插入位置</h3><h3 id="34-在排序数组中查找元素的第一个和最后一个位置">34.<strong>在排序数组中查找元素的第一个和最后一个位置</strong></h3><p>使用两次二分查找依次寻找要查找的元素的左区间和右区间。做法是仅需对两个边界大小条件对应的操作做出一些修改。</p><p>（当时做的时候是直接使用了两个while循环从mid往两边查找，这样不符合时间复杂度O(log(n))的要求）</p><h3 id="69-求x的平方根">69. 求x的平方根</h3><p>本题使用暴力解法的时间复杂度为O（log(n)），使用二分查找的时间复杂度为O(log(n/2))，实际会更快，注意搜索的区间最开始为1-n/2，并且为了避免 **乘法溢出，**改用除法。</p><h2 id="2-数组的元素移除问题-27">2. 数组的元素移除问题-27</h2><h3 id="27-移除元素-力扣（LeetCode）-leetcode-cn-com">@<a href="https://leetcode-cn.com/problems/remove-element/submissions/">27. 移除元素 - 力扣（LeetCode） (leetcode-cn.com)</a></h3><p>若要在O(n)的复杂度，即一遍扫描完成元素移除，且原地解决，即空间复杂度为1，则需要用到 <strong>快慢指针的方法，慢指针代码要返回的长度，而快指针代表扫描指针。</strong></p><h3 id="26-删除有序数组中的重复项-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项 - 力扣（LeetCode） (leetcode-cn.com)</a></h3><p>只需注意快慢指针的更新</p><h3 id="283-移动零-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零 - 力扣（LeetCode） (leetcode-cn.com)</a></h3><blockquote><p>给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，请你判断二者是否相等。# 代表退格字符。</p></blockquote><blockquote><p>如果相等，返回 true ；否则，返回 false 。</p></blockquote><blockquote><p>注意：如果对空文本输入退格字符，文本继续为空。</p></blockquote><p>此 题我当时想的做法是偏暴力，直接分别对每个字符串求出其实际字符串，时间复杂度为O(N+M)，空间复杂度为O(N+M),因为都需初始化一个StringBuffer.</p><p><strong>最高效的做法：</strong></p><p>使用双指针，因为每个字符是否需要被退格取决于其之后相邻的#，而跟之前的退格无关，因此我们仅仅需要分别对每个字符串同时从最后一个开始递归，然后每次对不需要退格的字符进行比较。</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/%E6%AF%94%E7%89%B9%E6%88%AA%E5%9B%BE2022-01-25-17-15-11.png" alt="比特截图2022-01-25-17-15-11.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = s.length() -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = t.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> skipS = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> skipT = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>||j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                    skipS++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(skipS &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    skipS--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t.charAt(j) == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                    skipT++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(skipT &gt; <span class="number">0</span>)</span><br><span class="line">                    skipT--;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) != t.charAt(j))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="977-有序数组的平方">977. 有序数组的平方</h2><p><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">977. 有序数组的平方 - 力扣（LeetCode） (leetcode-cn.com)</a></p><blockquote><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p></blockquote><blockquote><p>示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p></blockquote><blockquote><p>示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]</p></blockquote><p>要求时间复杂度在O(n)内</p><p>这道题的暴力解法就是平方后再排序输出。但我们知道最快速的排序算法的时间复杂度也是O(nlogn)，不符合题目要求</p><p>这里我们依然用到**双指针法，**先找到临界位置，然后将两个指针的初始位置均设置为最大的负数和最小的正数，然后依次向两边扫描做归并排序，最慢需要n趟扫描。</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/1.png" alt="1.png"></p><h2 id="209-长度最小的子数组—滑动窗口（sliding-window）">209. 长度最小的子数组—滑动窗口（sliding-window）</h2><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209. 长度最小的子数组 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p><strong>本题要求时间复杂度为O(nlog(n))</strong></p><p>我当时的想法是滑动窗口大小从1一直到最大，每次需要循环移动滑动窗口，最后的时间复杂度为O(n*n)。力扣上的效率很低。</p><p>滑动窗口：不断调节子序列的起始位置和终止位置</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/%E6%AF%94%E7%89%B9%E6%88%AA%E5%9B%BE2022-01-26-18-00-01.png" alt="比特截图2022-01-26-18-00-01.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> startIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minLength = <span class="number">0</span>;<span class="comment">//如果未改变该值，则表示没有找到最短数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> endIndex = <span class="number">0</span>; endIndex&lt;nums.length; endIndex++)&#123;</span><br><span class="line">        sum += nums[endIndex];</span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(minLength &gt; <span class="number">0</span>)</span><br><span class="line">                minLength = Math.min((endIndex - startIndex + <span class="number">1</span>), minLength);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                minLength = endIndex - startIndex + <span class="number">1</span>;</span><br><span class="line">            sum -= nums[startIndex++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="904-水果成篮-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/fruit-into-baskets/">904. 水果成篮 - 力扣（LeetCode） (leetcode-cn.com)</a></h3><p><a href="https://leetcode-cn.com/problems/fruit-into-baskets/">904. 水果成篮 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>我最开始想到了用滑动窗口，即使用startIndex和endIndex,对于每个递增的endIndex,都对应一个最小的startIndex,即有f(endIndex) = startIndex, f函数表示使得从startIndex到endIndex的所有水果成功放入蓝中的startIndex的最小值。可见该函数是一个递增函数，因此使用滑动窗口一定能解决出来。</p><p>但关键问题在于如何存储篮子中放置水果的情况，对此我是直接用了两个二维数组分别存储每个篮子内放置的水果的种类和数量，这样做还要在每次增加和删除时作两次比较，降低了算法效率，这样得到了如下的结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(<span class="keyword">int</span>[] fruits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> startIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] basket = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] basketNum = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> endIndex = <span class="number">0</span>; endIndex &lt; fruits.length; endIndex++)&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;<span class="number">2</span> ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(basket[i] == -<span class="number">1</span> || fruits[endIndex] == basket[i])&#123;</span><br><span class="line">                basketNum[i]++;</span><br><span class="line">                basket[i] = fruits[endIndex];</span><br><span class="line">                sum++;</span><br><span class="line">                total = Math.max(sum,total);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sum--;</span><br><span class="line">            <span class="keyword">if</span>(basket[<span class="number">0</span>] == fruits[startIndex])&#123;</span><br><span class="line">                <span class="keyword">if</span>(basketNum[<span class="number">0</span>] == <span class="number">1</span>)</span><br><span class="line">                    basket[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">                basketNum[<span class="number">0</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(basket[<span class="number">1</span>] == fruits[startIndex])&#123;</span><br><span class="line">                <span class="keyword">if</span>(basketNum[<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">                    basket[<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">                basketNum[<span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">            startIndex++;</span><br><span class="line">            endIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/%E6%AF%94%E7%89%B9%E6%88%AA%E5%9B%BE2022-01-26-18-44-31.png" alt="比特截图2022-01-26-18-44-31.png"></p><p>实际上，对于这种情况最好的存储办法是使用<strong>HashMap</strong>，存放若干键值对的集合。修改后的写法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(<span class="keyword">int</span>[] tree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        Counter count = <span class="keyword">new</span> Counter();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tree.length; ++j) &#123;</span><br><span class="line">            count.add(tree[j], <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (count.size() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                count.add(tree[i], -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (count.get(tree[i]) == <span class="number">0</span>)</span><br><span class="line">                    count.remove(tree[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containsKey(k) ? <span class="keyword">super</span>.get(k) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        put(k, get(k) + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而实际上速度反而慢了。。。</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/%E6%AF%94%E7%89%B9%E6%88%AA%E5%9B%BE2022-01-26-18-59-05.png" alt="比特截图2022-01-26-18-59-05.png"></p><h3 id="76-最小覆盖子串（困难）—字节在线一面原题">76. 最小覆盖子串（困难）—字节在线一面原题</h3><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/solution/zui-xiao-fu-gai-zi-chuan-by-leetcode-solution/">最小覆盖子串 - 最小覆盖子串 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>方法一： 使用滑动窗口方法（我当时解题使用的方法）也是最终答案给出的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Character,Integer&gt; orign=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Character,Integer&gt;window=<span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">//记录滑动窗口中的character及频率</span></span><br><span class="line">    <span class="keyword">int</span> ansL=-<span class="number">1</span>;<span class="comment">//全局的左指针</span></span><br><span class="line">    <span class="keyword">int</span> ansR=-<span class="number">1</span>;<span class="comment">//全局的右指针</span></span><br><span class="line">    <span class="keyword">int</span> len=Integer.MAX_VALUE; <span class="comment">//记录每次匹配符合时子串的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length() ; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c=t.charAt(i);</span><br><span class="line">            orign.put(c,orign.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左、右指针</span></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (r&lt;s.length())&#123;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="comment">//可能window中一个字符出现的次数要多于我们要比对的那个字符串中字符的个数</span></span><br><span class="line">            <span class="keyword">if</span>(r&lt;s.length()&amp;&amp;orign.containsKey(s.charAt(r)))&#123;</span><br><span class="line">                window.put(s.charAt(r),window.getOrDefault(s.charAt(r),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (check()&amp;&amp;l&lt;=r)&#123; <span class="comment">//这里检查左指针是否可以收缩窗口，注意左指针可以收缩窗口的条件在于：窗口中包含了字符t</span></span><br><span class="line">                <span class="comment">//能够走到这里就说明已经符合要求了,但是要找到全局最小的子串，所以每次都要判断一下</span></span><br><span class="line">                <span class="keyword">if</span>(r-l+<span class="number">1</span>&lt;len)&#123;</span><br><span class="line">                    ansL=l;</span><br><span class="line">                    ansR=r;</span><br><span class="line">                    len=r-l+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果window中的左边出现了t中的字符，直接减1，然后看是否还能满足完全覆盖的要求</span></span><br><span class="line">                <span class="keyword">if</span>(orign.containsKey(s.charAt(l)))&#123;</span><br><span class="line">                    window.put(s.charAt(l),window.getOrDefault(s.charAt(l),<span class="number">0</span>)-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansR==-<span class="number">1</span>?<span class="string">&quot;&quot;</span>:s.substring(ansL,ansR+<span class="number">1</span>); <span class="comment">//ansR==-1 说明没有符合的，就返回空字符串</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//用于检测是否窗口中是否完全覆盖了子串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry e:orign.entrySet())&#123;</span><br><span class="line">             <span class="keyword">int</span> val= (<span class="keyword">int</span>) e.getValue();</span><br><span class="line">             <span class="keyword">if</span>(window.getOrDefault(e.getKey(), <span class="number">0</span>)&lt;val)&#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补充：遍历Hashmap的几种方法：">补充：遍历Hashmap的几种方法：</h3><ol><li><p>使用迭代器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">　Iterator iter = map.entrySet().iterator();</span><br><span class="line">　<span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">　Map.Entry entry = (Map.Entry) iter.next();</span><br><span class="line">　Object key = entry.getKey();</span><br><span class="line">　Object val = entry.getValue();</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure></li><li><p>For each遍历：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">entry.getKey();</span><br><span class="line">entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：最坏情况下左右指针对 s 的每个元素各遍历一遍，哈希表中对 s中的每个元素各插入、删除一次，对 t 中的元素各插入一次。每次检查是否可行会遍历整个 t 的哈希表，哈希表的大小与字符集的大小有关，设字符集大小为 C，则渐进时间复杂度为 O(C⋅∣s∣+∣t∣).</p></li></ol><h2 id="59-螺旋矩阵2—模拟行为">59.螺旋矩阵2—模拟行为</h2><p><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>无特殊算法，注意边界条件即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        result[i][j] = num;</span><br><span class="line">        <span class="keyword">while</span>(num &lt; n*n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span> &lt; n &amp;&amp; result[i][j+<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; (i-<span class="number">1</span>&lt;<span class="number">0</span> || result[i-<span class="number">1</span>][j] != <span class="number">0</span>))</span><br><span class="line">                result[i][++j] = ++num;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i+<span class="number">1</span> &lt;n &amp;&amp; result[i+<span class="number">1</span>][j] == <span class="number">0</span> &amp;&amp; (j+<span class="number">1</span> == n || result[i][j+<span class="number">1</span>] != <span class="number">0</span>))</span><br><span class="line">                result[++i][j] = ++num;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; result[i][j-<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; (i+<span class="number">1</span> == n || result[i+<span class="number">1</span>][j] != <span class="number">0</span>))</span><br><span class="line">                result[i][--j] = ++num;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i-<span class="number">1</span> &gt;=<span class="number">0</span> &amp;&amp; result[i-<span class="number">1</span>][j] == <span class="number">0</span> &amp;&amp; (j-<span class="number">1</span> &lt;<span class="number">0</span> || result[i][j-<span class="number">1</span>] != <span class="number">0</span>))</span><br><span class="line">                result[--i][j] = ++num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="54-螺旋矩阵">54. 螺旋矩阵</h3><p><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵 - 力扣（LeetCode） (leetcode-cn.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
