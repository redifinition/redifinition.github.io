<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一个梦---谈谈保留这首歌</title>
      <link href="/2022/03/02/emo202232/"/>
      <url>/2022/03/02/emo202232/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-EvIFZouq" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="442869203" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#FF4081"    ></div><p>2022年3月2日23：59分。</p><p>刚才在寝室洗衣服时，耳机里放着网易云”我喜欢“的歌单，随机播放。因为我的歌单里有很多首歌，快1000首了，大抵都是听一遍觉得不错便扔进了歌单里，所以每次随机播放时，都能稍稍体会到好奇下一首是哪首歌的快感</p><p>突然脑海里播放了这首歌。<br>郭顶的《保留》。这首歌没有前奏，不给人任何心理准备，一来就是“看见，你在我眼前。”<br>听后遍有一种心里很沉重很难受的感觉。是的，因为这首歌以它的方式提醒我：我三年来一直秉持的信仰和坚持（虽然中途放弃过），破碎了。<br>我本以为我快要走出来了，可是一听到这首歌，立马发现自己还在原地踏步，并且还时不时地回头看。<br>三年前，我和她走在大学路的街道上，突然听见远方唱歌的声音。一位弹着吉他的流浪歌手，唱着《保留》，声音低沉悠扬。我们当时不知道这首歌，但都被歌词和旋律深深吸引。一首歌，几句歌词，让两个人的世界第一次相交，碰撞，重叠，燃烧。<br>这首歌一听就是三年，两个人。在四平路，在嘉定。在呼伦贝尔，在成都的夜晚。在中国。在法国。<br>最终歌曲放完了。对我而言很像是一场梦，有时候会觉得是噩梦想要抽离，可真的快抽离时却发现自己十分迷恋，想一直做下去。<br>正当自己认为这场梦可以一直做，做到毕业，做到工作，做到自己有自己的一片乐土时，它碎了。<br>可能自己心里真的未放下吧，所以写的十分的抽象。或许有一天自己真正放下向前看的时候，这个梦会变得越来越清晰，清晰到我能够真正真切地去面对，能真正的觉得它是一段美好的回忆。</p><p>好了，抽象emo结束。有一说一，这首歌我还是很喜欢的。郭顶是我很喜欢的歌手，而这首歌也是他的歌里面我最喜欢的。下面是他的完整歌词，因为个人经历会觉得歌词承载的太多，不敢去过度理解，不过不影响这真的是一首好作品。</p><p>不emo了，明早还有游泳课，有的爽了。</p><p>看见 你在我眼前</p><p>不去猜想我们隔多远</p><p>当我 夜幕中准备</p><p>只想让沉默的能开解</p><p>在不同的遭遇里我发现你的瞬间</p><p>有种不可言说的温柔直觉</p><p>在有限的深夜消失之前触摸你的脸</p><p>我情愿这是幻觉 也不愿是种告别</p><p>已经忘了 你的名字</p><p>就在这座 寂静星石</p><p>怎么还有 你的样子</p><p>被保留</p><p>给我 一整个拥抱</p><p>好让我不至于 太潦倒</p><p>时间 过一分一秒</p><p>还是觉得相遇 太美好</p><p>在不同的遭遇里我发现你的瞬间</p><p>有种不可言说的温柔直觉</p><p>当不远的蓝色渐渐显现这无边境界</p><p>我始终等待再见 只不愿再也不见</p><p>已经忘了 你的名字</p><p>就在这座 寂静星石</p><p>怎么还有 你的样子</p><p>想形容你的句子 关于你所有心事</p><p>一眼能及的钻石 哪一个是你地址</p><p>忘了 你的名字</p><p>就在这座 寂静星石</p><p>怎么还有 你的样子</p><p>我始终等待再见 只不愿再也不见</p><p>真的忘了 你的名字</p><p>是在哪座 寂静星石</p><p>一直还有 你的样子</p><p>被保留</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> emo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>被讨厌的勇气--读书心得</title>
      <link href="/2022/03/02/book1/"/>
      <url>/2022/03/02/book1/</url>
      
        <content type="html"><![CDATA[<p>上大学期间一直不怎么看书。最近受某位同学的推荐阅读了这本书，通篇大部分为一个年轻人和哲人的对话，初读感觉里面讲的人生哲学非常的唯心主义，他否定了过去经历和所处环境对人性格形成的影响，而将我们后来对自己”人设“的认知和性格的形成归结为我们自己的选择。说实话，这种观点目前我是无法苟同的，不过现在还没读完这本书，等读完了在这里记录一下看法和感受吧！</p>]]></content>
      
      
      <categories>
          
          <category> 读书心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1000米进3分之路</title>
      <link href="/2022/03/01/running/"/>
      <url>/2022/03/01/running/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 运动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中长跑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode刷题笔记--数组</title>
      <link href="/2022/02/05/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84/"/>
      <url>/2022/02/05/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-rCckheRl" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="482655706" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#FF4081"    ></div><h1>LeetCode数组专题</h1><h2 id="1-数组的二分查找">1. 数组的二分查找</h2><p>该类型题的一个典型特点是时间复杂度为O(logn)型，且数组都是有序的序列，一般这个时候查找某些元素的位置就会想到二分查找算法。</p><h3 id="704-二分查找">704.二分查找</h3><p>二分查找条件：有序+无重复数组</p><p>注意边界条件和区间的写法</p><ol><li><p>左闭右闭[left≤right]，这时while循环的条件为while(left≤right)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span>(target &lt; nums[mid])&#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">                mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; nums[mid])&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">                mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>左闭右开区间[left,right)，此时的循环条件是while(left&lt;right)</p></li></ol><h3 id="35-搜索插入位置">35.搜索插入位置</h3><h3 id="34-在排序数组中查找元素的第一个和最后一个位置">34.<strong>在排序数组中查找元素的第一个和最后一个位置</strong></h3><p>使用两次二分查找依次寻找要查找的元素的左区间和右区间。做法是仅需对两个边界大小条件对应的操作做出一些修改。</p><p>（当时做的时候是直接使用了两个while循环从mid往两边查找，这样不符合时间复杂度O(log(n))的要求）</p><h3 id="69-求x的平方根">69. 求x的平方根</h3><p>本题使用暴力解法的时间复杂度为O（log(n)），使用二分查找的时间复杂度为O(log(n/2))，实际会更快，注意搜索的区间最开始为1-n/2，并且为了避免 **乘法溢出，**改用除法。</p><h2 id="2-数组的元素移除问题-27">2. 数组的元素移除问题-27</h2><h3 id="27-移除元素-力扣（LeetCode）-leetcode-cn-com">@<a href="https://leetcode-cn.com/problems/remove-element/submissions/">27. 移除元素 - 力扣（LeetCode） (leetcode-cn.com)</a></h3><p>若要在O(n)的复杂度，即一遍扫描完成元素移除，且原地解决，即空间复杂度为1，则需要用到 <strong>快慢指针的方法，慢指针代码要返回的长度，而快指针代表扫描指针。</strong></p><h3 id="26-删除有序数组中的重复项-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项 - 力扣（LeetCode） (leetcode-cn.com)</a></h3><p>只需注意快慢指针的更新</p><h3 id="283-移动零-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零 - 力扣（LeetCode） (leetcode-cn.com)</a></h3><blockquote><p>给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，请你判断二者是否相等。# 代表退格字符。</p></blockquote><blockquote><p>如果相等，返回 true ；否则，返回 false 。</p></blockquote><blockquote><p>注意：如果对空文本输入退格字符，文本继续为空。</p></blockquote><p>此 题我当时想的做法是偏暴力，直接分别对每个字符串求出其实际字符串，时间复杂度为O(N+M)，空间复杂度为O(N+M),因为都需初始化一个StringBuffer.</p><p><strong>最高效的做法：</strong></p><p>使用双指针，因为每个字符是否需要被退格取决于其之后相邻的#，而跟之前的退格无关，因此我们仅仅需要分别对每个字符串同时从最后一个开始递归，然后每次对不需要退格的字符进行比较。</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/%E6%AF%94%E7%89%B9%E6%88%AA%E5%9B%BE2022-01-25-17-15-11.png" alt="比特截图2022-01-25-17-15-11.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = s.length() -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = t.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> skipS = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> skipT = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>||j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                    skipS++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(skipS &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    skipS--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t.charAt(j) == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                    skipT++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(skipT &gt; <span class="number">0</span>)</span><br><span class="line">                    skipT--;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) != t.charAt(j))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="977-有序数组的平方">977. 有序数组的平方</h2><p><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">977. 有序数组的平方 - 力扣（LeetCode） (leetcode-cn.com)</a></p><blockquote><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p></blockquote><blockquote><p>示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p></blockquote><blockquote><p>示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]</p></blockquote><p>要求时间复杂度在O(n)内</p><p>这道题的暴力解法就是平方后再排序输出。但我们知道最快速的排序算法的时间复杂度也是O(nlogn)，不符合题目要求</p><p>这里我们依然用到**双指针法，**先找到临界位置，然后将两个指针的初始位置均设置为最大的负数和最小的正数，然后依次向两边扫描做归并排序，最慢需要n趟扫描。</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/1.png" alt="1.png"></p><h2 id="209-长度最小的子数组—滑动窗口（sliding-window）">209. 长度最小的子数组—滑动窗口（sliding-window）</h2><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209. 长度最小的子数组 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p><strong>本题要求时间复杂度为O(nlog(n))</strong></p><p>我当时的想法是滑动窗口大小从1一直到最大，每次需要循环移动滑动窗口，最后的时间复杂度为O(n*n)。力扣上的效率很低。</p><p>滑动窗口：不断调节子序列的起始位置和终止位置</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/%E6%AF%94%E7%89%B9%E6%88%AA%E5%9B%BE2022-01-26-18-00-01.png" alt="比特截图2022-01-26-18-00-01.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> startIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minLength = <span class="number">0</span>;<span class="comment">//如果未改变该值，则表示没有找到最短数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> endIndex = <span class="number">0</span>; endIndex&lt;nums.length; endIndex++)&#123;</span><br><span class="line">        sum += nums[endIndex];</span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(minLength &gt; <span class="number">0</span>)</span><br><span class="line">                minLength = Math.min((endIndex - startIndex + <span class="number">1</span>), minLength);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                minLength = endIndex - startIndex + <span class="number">1</span>;</span><br><span class="line">            sum -= nums[startIndex++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="904-水果成篮-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/fruit-into-baskets/">904. 水果成篮 - 力扣（LeetCode） (leetcode-cn.com)</a></h3><p><a href="https://leetcode-cn.com/problems/fruit-into-baskets/">904. 水果成篮 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>我最开始想到了用滑动窗口，即使用startIndex和endIndex,对于每个递增的endIndex,都对应一个最小的startIndex,即有f(endIndex) = startIndex, f函数表示使得从startIndex到endIndex的所有水果成功放入蓝中的startIndex的最小值。可见该函数是一个递增函数，因此使用滑动窗口一定能解决出来。</p><p>但关键问题在于如何存储篮子中放置水果的情况，对此我是直接用了两个二维数组分别存储每个篮子内放置的水果的种类和数量，这样做还要在每次增加和删除时作两次比较，降低了算法效率，这样得到了如下的结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(<span class="keyword">int</span>[] fruits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> startIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] basket = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] basketNum = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> endIndex = <span class="number">0</span>; endIndex &lt; fruits.length; endIndex++)&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;<span class="number">2</span> ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(basket[i] == -<span class="number">1</span> || fruits[endIndex] == basket[i])&#123;</span><br><span class="line">                basketNum[i]++;</span><br><span class="line">                basket[i] = fruits[endIndex];</span><br><span class="line">                sum++;</span><br><span class="line">                total = Math.max(sum,total);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sum--;</span><br><span class="line">            <span class="keyword">if</span>(basket[<span class="number">0</span>] == fruits[startIndex])&#123;</span><br><span class="line">                <span class="keyword">if</span>(basketNum[<span class="number">0</span>] == <span class="number">1</span>)</span><br><span class="line">                    basket[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">                basketNum[<span class="number">0</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(basket[<span class="number">1</span>] == fruits[startIndex])&#123;</span><br><span class="line">                <span class="keyword">if</span>(basketNum[<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">                    basket[<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">                basketNum[<span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">            startIndex++;</span><br><span class="line">            endIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/%E6%AF%94%E7%89%B9%E6%88%AA%E5%9B%BE2022-01-26-18-44-31.png" alt="比特截图2022-01-26-18-44-31.png"></p><p>实际上，对于这种情况最好的存储办法是使用<strong>HashMap</strong>，存放若干键值对的集合。修改后的写法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(<span class="keyword">int</span>[] tree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        Counter count = <span class="keyword">new</span> Counter();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tree.length; ++j) &#123;</span><br><span class="line">            count.add(tree[j], <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (count.size() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                count.add(tree[i], -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (count.get(tree[i]) == <span class="number">0</span>)</span><br><span class="line">                    count.remove(tree[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containsKey(k) ? <span class="keyword">super</span>.get(k) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        put(k, get(k) + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而实际上速度反而慢了。。。</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/%E6%AF%94%E7%89%B9%E6%88%AA%E5%9B%BE2022-01-26-18-59-05.png" alt="比特截图2022-01-26-18-59-05.png"></p><h3 id="76-最小覆盖子串（困难）—字节在线一面原题">76. 最小覆盖子串（困难）—字节在线一面原题</h3><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/solution/zui-xiao-fu-gai-zi-chuan-by-leetcode-solution/">最小覆盖子串 - 最小覆盖子串 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>方法一： 使用滑动窗口方法（我当时解题使用的方法）也是最终答案给出的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Character,Integer&gt; orign=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Character,Integer&gt;window=<span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">//记录滑动窗口中的character及频率</span></span><br><span class="line">    <span class="keyword">int</span> ansL=-<span class="number">1</span>;<span class="comment">//全局的左指针</span></span><br><span class="line">    <span class="keyword">int</span> ansR=-<span class="number">1</span>;<span class="comment">//全局的右指针</span></span><br><span class="line">    <span class="keyword">int</span> len=Integer.MAX_VALUE; <span class="comment">//记录每次匹配符合时子串的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length() ; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c=t.charAt(i);</span><br><span class="line">            orign.put(c,orign.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左、右指针</span></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (r&lt;s.length())&#123;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="comment">//可能window中一个字符出现的次数要多于我们要比对的那个字符串中字符的个数</span></span><br><span class="line">            <span class="keyword">if</span>(r&lt;s.length()&amp;&amp;orign.containsKey(s.charAt(r)))&#123;</span><br><span class="line">                window.put(s.charAt(r),window.getOrDefault(s.charAt(r),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (check()&amp;&amp;l&lt;=r)&#123; <span class="comment">//这里检查左指针是否可以收缩窗口，注意左指针可以收缩窗口的条件在于：窗口中包含了字符t</span></span><br><span class="line">                <span class="comment">//能够走到这里就说明已经符合要求了,但是要找到全局最小的子串，所以每次都要判断一下</span></span><br><span class="line">                <span class="keyword">if</span>(r-l+<span class="number">1</span>&lt;len)&#123;</span><br><span class="line">                    ansL=l;</span><br><span class="line">                    ansR=r;</span><br><span class="line">                    len=r-l+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果window中的左边出现了t中的字符，直接减1，然后看是否还能满足完全覆盖的要求</span></span><br><span class="line">                <span class="keyword">if</span>(orign.containsKey(s.charAt(l)))&#123;</span><br><span class="line">                    window.put(s.charAt(l),window.getOrDefault(s.charAt(l),<span class="number">0</span>)-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansR==-<span class="number">1</span>?<span class="string">&quot;&quot;</span>:s.substring(ansL,ansR+<span class="number">1</span>); <span class="comment">//ansR==-1 说明没有符合的，就返回空字符串</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//用于检测是否窗口中是否完全覆盖了子串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry e:orign.entrySet())&#123;</span><br><span class="line">             <span class="keyword">int</span> val= (<span class="keyword">int</span>) e.getValue();</span><br><span class="line">             <span class="keyword">if</span>(window.getOrDefault(e.getKey(), <span class="number">0</span>)&lt;val)&#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补充：遍历Hashmap的几种方法：">补充：遍历Hashmap的几种方法：</h3><ol><li><p>使用迭代器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">　Iterator iter = map.entrySet().iterator();</span><br><span class="line">　<span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">　Map.Entry entry = (Map.Entry) iter.next();</span><br><span class="line">　Object key = entry.getKey();</span><br><span class="line">　Object val = entry.getValue();</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure></li><li><p>For each遍历：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">entry.getKey();</span><br><span class="line">entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：最坏情况下左右指针对 s 的每个元素各遍历一遍，哈希表中对 s中的每个元素各插入、删除一次，对 t 中的元素各插入一次。每次检查是否可行会遍历整个 t 的哈希表，哈希表的大小与字符集的大小有关，设字符集大小为 C，则渐进时间复杂度为 O(C⋅∣s∣+∣t∣).</p></li></ol><h2 id="59-螺旋矩阵2—模拟行为">59.螺旋矩阵2—模拟行为</h2><p><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>无特殊算法，注意边界条件即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        result[i][j] = num;</span><br><span class="line">        <span class="keyword">while</span>(num &lt; n*n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span> &lt; n &amp;&amp; result[i][j+<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; (i-<span class="number">1</span>&lt;<span class="number">0</span> || result[i-<span class="number">1</span>][j] != <span class="number">0</span>))</span><br><span class="line">                result[i][++j] = ++num;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i+<span class="number">1</span> &lt;n &amp;&amp; result[i+<span class="number">1</span>][j] == <span class="number">0</span> &amp;&amp; (j+<span class="number">1</span> == n || result[i][j+<span class="number">1</span>] != <span class="number">0</span>))</span><br><span class="line">                result[++i][j] = ++num;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; result[i][j-<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; (i+<span class="number">1</span> == n || result[i+<span class="number">1</span>][j] != <span class="number">0</span>))</span><br><span class="line">                result[i][--j] = ++num;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i-<span class="number">1</span> &gt;=<span class="number">0</span> &amp;&amp; result[i-<span class="number">1</span>][j] == <span class="number">0</span> &amp;&amp; (j-<span class="number">1</span> &lt;<span class="number">0</span> || result[i][j-<span class="number">1</span>] != <span class="number">0</span>))</span><br><span class="line">                result[--i][j] = ++num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="54-螺旋矩阵">54. 螺旋矩阵</h3><p><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵 - 力扣（LeetCode） (leetcode-cn.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
