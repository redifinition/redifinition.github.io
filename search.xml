<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>1000米进3分之路</title>
      <link href="/2022/03/01/running/"/>
      <url>/2022/03/01/running/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 运动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中长跑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode刷题笔记--数组</title>
      <link href="/2022/02/05/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84/"/>
      <url>/2022/02/05/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-gaGpiIaS" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="482655706" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#FF4081"    ></div><h1>LeetCode数组专题</h1><h2 id="1-数组的二分查找">1. 数组的二分查找</h2><p>该类型题的一个典型特点是时间复杂度为O(logn)型，且数组都是有序的序列，一般这个时候查找某些元素的位置就会想到二分查找算法。</p><h3 id="704-二分查找">704.二分查找</h3><p>二分查找条件：有序+无重复数组</p><p>注意边界条件和区间的写法</p><ol><li><p>左闭右闭[left≤right]，这时while循环的条件为while(left≤right)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span>(target &lt; nums[mid])&#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">                mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; nums[mid])&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">                mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>左闭右开区间[left,right)，此时的循环条件是while(left&lt;right)</p></li></ol><h3 id="35-搜索插入位置">35.搜索插入位置</h3><h3 id="34-在排序数组中查找元素的第一个和最后一个位置">34.<strong>在排序数组中查找元素的第一个和最后一个位置</strong></h3><p>使用两次二分查找依次寻找要查找的元素的左区间和右区间。做法是仅需对两个边界大小条件对应的操作做出一些修改。</p><p>（当时做的时候是直接使用了两个while循环从mid往两边查找，这样不符合时间复杂度O(log(n))的要求）</p><h3 id="69-求x的平方根">69. 求x的平方根</h3><p>本题使用暴力解法的时间复杂度为O（log(n)），使用二分查找的时间复杂度为O(log(n/2))，实际会更快，注意搜索的区间最开始为1-n/2，并且为了避免 **乘法溢出，**改用除法。</p><h2 id="2-数组的元素移除问题-27">2. 数组的元素移除问题-27</h2><h3 id="27-移除元素-力扣（LeetCode）-leetcode-cn-com">@<a href="https://leetcode-cn.com/problems/remove-element/submissions/">27. 移除元素 - 力扣（LeetCode） (leetcode-cn.com)</a></h3><p>若要在O(n)的复杂度，即一遍扫描完成元素移除，且原地解决，即空间复杂度为1，则需要用到 <strong>快慢指针的方法，慢指针代码要返回的长度，而快指针代表扫描指针。</strong></p><h3 id="26-删除有序数组中的重复项-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项 - 力扣（LeetCode） (leetcode-cn.com)</a></h3><p>只需注意快慢指针的更新</p><h3 id="283-移动零-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零 - 力扣（LeetCode） (leetcode-cn.com)</a></h3><blockquote><p>给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，请你判断二者是否相等。# 代表退格字符。</p></blockquote><blockquote><p>如果相等，返回 true ；否则，返回 false 。</p></blockquote><blockquote><p>注意：如果对空文本输入退格字符，文本继续为空。</p></blockquote><p>此 题我当时想的做法是偏暴力，直接分别对每个字符串求出其实际字符串，时间复杂度为O(N+M)，空间复杂度为O(N+M),因为都需初始化一个StringBuffer.</p><p><strong>最高效的做法：</strong></p><p>使用双指针，因为每个字符是否需要被退格取决于其之后相邻的#，而跟之前的退格无关，因此我们仅仅需要分别对每个字符串同时从最后一个开始递归，然后每次对不需要退格的字符进行比较。</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/%E6%AF%94%E7%89%B9%E6%88%AA%E5%9B%BE2022-01-25-17-15-11.png" alt="比特截图2022-01-25-17-15-11.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = s.length() -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = t.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> skipS = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> skipT = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>||j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                    skipS++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(skipS &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    skipS--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t.charAt(j) == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                    skipT++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(skipT &gt; <span class="number">0</span>)</span><br><span class="line">                    skipT--;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) != t.charAt(j))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="977-有序数组的平方">977. 有序数组的平方</h2><p><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">977. 有序数组的平方 - 力扣（LeetCode） (leetcode-cn.com)</a></p><blockquote><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p></blockquote><blockquote><p>示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p></blockquote><blockquote><p>示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]</p></blockquote><p>要求时间复杂度在O(n)内</p><p>这道题的暴力解法就是平方后再排序输出。但我们知道最快速的排序算法的时间复杂度也是O(nlogn)，不符合题目要求</p><p>这里我们依然用到**双指针法，**先找到临界位置，然后将两个指针的初始位置均设置为最大的负数和最小的正数，然后依次向两边扫描做归并排序，最慢需要n趟扫描。</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/1.png" alt="1.png"></p><h2 id="209-长度最小的子数组—滑动窗口（sliding-window）">209. 长度最小的子数组—滑动窗口（sliding-window）</h2><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209. 长度最小的子数组 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p><strong>本题要求时间复杂度为O(nlog(n))</strong></p><p>我当时的想法是滑动窗口大小从1一直到最大，每次需要循环移动滑动窗口，最后的时间复杂度为O(n*n)。力扣上的效率很低。</p><p>滑动窗口：不断调节子序列的起始位置和终止位置</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/%E6%AF%94%E7%89%B9%E6%88%AA%E5%9B%BE2022-01-26-18-00-01.png" alt="比特截图2022-01-26-18-00-01.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> startIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minLength = <span class="number">0</span>;<span class="comment">//如果未改变该值，则表示没有找到最短数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> endIndex = <span class="number">0</span>; endIndex&lt;nums.length; endIndex++)&#123;</span><br><span class="line">        sum += nums[endIndex];</span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(minLength &gt; <span class="number">0</span>)</span><br><span class="line">                minLength = Math.min((endIndex - startIndex + <span class="number">1</span>), minLength);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                minLength = endIndex - startIndex + <span class="number">1</span>;</span><br><span class="line">            sum -= nums[startIndex++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="904-水果成篮-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/fruit-into-baskets/">904. 水果成篮 - 力扣（LeetCode） (leetcode-cn.com)</a></h3><p><a href="https://leetcode-cn.com/problems/fruit-into-baskets/">904. 水果成篮 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>我最开始想到了用滑动窗口，即使用startIndex和endIndex,对于每个递增的endIndex,都对应一个最小的startIndex,即有f(endIndex) = startIndex, f函数表示使得从startIndex到endIndex的所有水果成功放入蓝中的startIndex的最小值。可见该函数是一个递增函数，因此使用滑动窗口一定能解决出来。</p><p>但关键问题在于如何存储篮子中放置水果的情况，对此我是直接用了两个二维数组分别存储每个篮子内放置的水果的种类和数量，这样做还要在每次增加和删除时作两次比较，降低了算法效率，这样得到了如下的结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(<span class="keyword">int</span>[] fruits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> startIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] basket = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] basketNum = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> endIndex = <span class="number">0</span>; endIndex &lt; fruits.length; endIndex++)&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;<span class="number">2</span> ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(basket[i] == -<span class="number">1</span> || fruits[endIndex] == basket[i])&#123;</span><br><span class="line">                basketNum[i]++;</span><br><span class="line">                basket[i] = fruits[endIndex];</span><br><span class="line">                sum++;</span><br><span class="line">                total = Math.max(sum,total);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sum--;</span><br><span class="line">            <span class="keyword">if</span>(basket[<span class="number">0</span>] == fruits[startIndex])&#123;</span><br><span class="line">                <span class="keyword">if</span>(basketNum[<span class="number">0</span>] == <span class="number">1</span>)</span><br><span class="line">                    basket[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">                basketNum[<span class="number">0</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(basket[<span class="number">1</span>] == fruits[startIndex])&#123;</span><br><span class="line">                <span class="keyword">if</span>(basketNum[<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">                    basket[<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">                basketNum[<span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">            startIndex++;</span><br><span class="line">            endIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/%E6%AF%94%E7%89%B9%E6%88%AA%E5%9B%BE2022-01-26-18-44-31.png" alt="比特截图2022-01-26-18-44-31.png"></p><p>实际上，对于这种情况最好的存储办法是使用<strong>HashMap</strong>，存放若干键值对的集合。修改后的写法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(<span class="keyword">int</span>[] tree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        Counter count = <span class="keyword">new</span> Counter();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tree.length; ++j) &#123;</span><br><span class="line">            count.add(tree[j], <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (count.size() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                count.add(tree[i], -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (count.get(tree[i]) == <span class="number">0</span>)</span><br><span class="line">                    count.remove(tree[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containsKey(k) ? <span class="keyword">super</span>.get(k) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        put(k, get(k) + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而实际上速度反而慢了。。。</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/%E6%AF%94%E7%89%B9%E6%88%AA%E5%9B%BE2022-01-26-18-59-05.png" alt="比特截图2022-01-26-18-59-05.png"></p><h3 id="76-最小覆盖子串（困难）—字节在线一面原题">76. 最小覆盖子串（困难）—字节在线一面原题</h3><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/solution/zui-xiao-fu-gai-zi-chuan-by-leetcode-solution/">最小覆盖子串 - 最小覆盖子串 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>方法一： 使用滑动窗口方法（我当时解题使用的方法）也是最终答案给出的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Character,Integer&gt; orign=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Character,Integer&gt;window=<span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">//记录滑动窗口中的character及频率</span></span><br><span class="line">    <span class="keyword">int</span> ansL=-<span class="number">1</span>;<span class="comment">//全局的左指针</span></span><br><span class="line">    <span class="keyword">int</span> ansR=-<span class="number">1</span>;<span class="comment">//全局的右指针</span></span><br><span class="line">    <span class="keyword">int</span> len=Integer.MAX_VALUE; <span class="comment">//记录每次匹配符合时子串的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length() ; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c=t.charAt(i);</span><br><span class="line">            orign.put(c,orign.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左、右指针</span></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (r&lt;s.length())&#123;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="comment">//可能window中一个字符出现的次数要多于我们要比对的那个字符串中字符的个数</span></span><br><span class="line">            <span class="keyword">if</span>(r&lt;s.length()&amp;&amp;orign.containsKey(s.charAt(r)))&#123;</span><br><span class="line">                window.put(s.charAt(r),window.getOrDefault(s.charAt(r),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (check()&amp;&amp;l&lt;=r)&#123; <span class="comment">//这里检查左指针是否可以收缩窗口，注意左指针可以收缩窗口的条件在于：窗口中包含了字符t</span></span><br><span class="line">                <span class="comment">//能够走到这里就说明已经符合要求了,但是要找到全局最小的子串，所以每次都要判断一下</span></span><br><span class="line">                <span class="keyword">if</span>(r-l+<span class="number">1</span>&lt;len)&#123;</span><br><span class="line">                    ansL=l;</span><br><span class="line">                    ansR=r;</span><br><span class="line">                    len=r-l+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果window中的左边出现了t中的字符，直接减1，然后看是否还能满足完全覆盖的要求</span></span><br><span class="line">                <span class="keyword">if</span>(orign.containsKey(s.charAt(l)))&#123;</span><br><span class="line">                    window.put(s.charAt(l),window.getOrDefault(s.charAt(l),<span class="number">0</span>)-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansR==-<span class="number">1</span>?<span class="string">&quot;&quot;</span>:s.substring(ansL,ansR+<span class="number">1</span>); <span class="comment">//ansR==-1 说明没有符合的，就返回空字符串</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//用于检测是否窗口中是否完全覆盖了子串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry e:orign.entrySet())&#123;</span><br><span class="line">             <span class="keyword">int</span> val= (<span class="keyword">int</span>) e.getValue();</span><br><span class="line">             <span class="keyword">if</span>(window.getOrDefault(e.getKey(), <span class="number">0</span>)&lt;val)&#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补充：遍历Hashmap的几种方法：">补充：遍历Hashmap的几种方法：</h3><ol><li><p>使用迭代器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">　Iterator iter = map.entrySet().iterator();</span><br><span class="line">　<span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">　Map.Entry entry = (Map.Entry) iter.next();</span><br><span class="line">　Object key = entry.getKey();</span><br><span class="line">　Object val = entry.getValue();</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure></li><li><p>For each遍历：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">entry.getKey();</span><br><span class="line">entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：最坏情况下左右指针对 s 的每个元素各遍历一遍，哈希表中对 s中的每个元素各插入、删除一次，对 t 中的元素各插入一次。每次检查是否可行会遍历整个 t 的哈希表，哈希表的大小与字符集的大小有关，设字符集大小为 C，则渐进时间复杂度为 O(C⋅∣s∣+∣t∣).</p></li></ol><h2 id="59-螺旋矩阵2—模拟行为">59.螺旋矩阵2—模拟行为</h2><p><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>无特殊算法，注意边界条件即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        result[i][j] = num;</span><br><span class="line">        <span class="keyword">while</span>(num &lt; n*n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span> &lt; n &amp;&amp; result[i][j+<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; (i-<span class="number">1</span>&lt;<span class="number">0</span> || result[i-<span class="number">1</span>][j] != <span class="number">0</span>))</span><br><span class="line">                result[i][++j] = ++num;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i+<span class="number">1</span> &lt;n &amp;&amp; result[i+<span class="number">1</span>][j] == <span class="number">0</span> &amp;&amp; (j+<span class="number">1</span> == n || result[i][j+<span class="number">1</span>] != <span class="number">0</span>))</span><br><span class="line">                result[++i][j] = ++num;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; result[i][j-<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; (i+<span class="number">1</span> == n || result[i+<span class="number">1</span>][j] != <span class="number">0</span>))</span><br><span class="line">                result[i][--j] = ++num;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i-<span class="number">1</span> &gt;=<span class="number">0</span> &amp;&amp; result[i-<span class="number">1</span>][j] == <span class="number">0</span> &amp;&amp; (j-<span class="number">1</span> &lt;<span class="number">0</span> || result[i][j-<span class="number">1</span>] != <span class="number">0</span>))</span><br><span class="line">                result[--i][j] = ++num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="54-螺旋矩阵">54. 螺旋矩阵</h3><p><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵 - 力扣（LeetCode） (leetcode-cn.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
