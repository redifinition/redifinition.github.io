<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端个人面经问题汇总</title>
      <link href="/2022/03/20/mianjing/"/>
      <url>/2022/03/20/mianjing/</url>
      
        <content type="html"><![CDATA[<h1>前端个人面经问题汇总</h1><h2 id="Vue的生命周期-（蔚来）">Vue的生命周期-（蔚来）</h2><p>vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt;渲染、更新 -&gt; 渲染、卸载等⼀系列过程，即vue实例从创建到销毁的过程，我们称这是vue的⽣命周期</p><p><img src="%E5%89%8D%E7%AB%AF%E4%B8%AA%E4%BA%BA%E9%9D%A2%E7%BB%8F%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%20dfad4/Untitled.png" alt="Untitled"></p><p>挂载：（初始化相关属性）</p><p>1.beforeCreate：完成实例初始化，初始化非响应式变量<br>2.created：实例初始化完成，属性已绑定(未挂载DOM)，此时是我们最早能够访问Vue示例中数据和方法的地方<br>3.beforeMount：找到对应的template，并编译成render函数<br>4.mounted：完成创建vm.$el和双向绑定，完成DOM挂载<br>5.beforeUpdate：数据更新之前(可在更新前访问现有的DOM)<br>6.updated：完成虚拟DOM的重新渲染和打补丁<br>7.activated：子组件需要在每次加载时候进行某些操作，可以使用activated钩子触发<br>8.deactivated：keep-alive 组件被移除时使用<br>9.beforeDestroy：可做一些删除提示，销毁定时器，解绑全局时间 销毁插件对象<br>10.destroyed：当前组件已被销毁</p><p>这个代码示例很好：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myVue=<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">msg</span>:<span class="string">&quot;aaa&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="function"><span class="title">update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.data = <span class="string">&#x27;bbb&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">destroy</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.$destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">beforeCreate</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">     在调用beforeCreate的时候, 仅仅表示Vue实例刚刚被创建出来</span></span><br><span class="line"><span class="comment">     此时此刻还没有初始化好Vue实例中的数据和方法, 所以此时此刻还不能访问Vue实例中保存的数据和方法</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.msg);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.update);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">created</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在调用created的时候, 是我们最早能够访问Vue实例中保存的数据和方法的地方</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.msg);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.update);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">beforeMount</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在调用beforeMount的时候, 表示Vue已经编译好了最终模板, 但是还没有将最终的模板渲染到界面上</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">&quot;p&quot;</span>).innerHTML);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">&quot;p&quot;</span>).innerText);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mounted</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在调用mounted的时候, 表示Vue已经完成了模板的渲染, 表示我们已经可以拿到界面上渲染之后的内容了</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">&quot;p&quot;</span>).innerHTML);</span><br><span class="line">    &#125;,</span><br><span class="line">   <span class="attr">beforeUpdate</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在调用beforeUpdate的时候, 表示Vue实例中保存的数据被修改了</span></span><br><span class="line"><span class="comment">            注意点: 在调用beforeUpdate的时候, 数据已经更新了, 但是界面还没有更新</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;beforeUpdate&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.msg);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">&quot;p&quot;</span>).innerHTML);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">updated</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">/*在调用updated的时候, 表示Vue实例中保存的数据被修改了, 并且界面也同步了修改的数据了* */</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.msg);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">&quot;p&quot;</span>).innerHTML);</span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="attr">beforeDestroy</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在调用beforeDestroy的时候, 表示当前组件即将被销毁了</span></span><br><span class="line"><span class="comment">                    beforeDestroy函数是我们最后能够访问到组件数据和方法的钩子函数</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;beforeDestroy&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.msg);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.say);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">destroyed</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在调用destroyed的时候, 表示当前组件已经被销毁了，不要在这个生命周期方法中再去操作组件中数据和方法</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;destroyed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="created和mounted使用情景">created和mounted使用情景</h3><p>create方法，在页面还未渲染成html前，调用函数，从后端获取数据，在实现对页面的数据进行显示<br>mounted通常是在一些插件的使用或者组件的使用中进行操作 也就是页面渲染之后执行 通常情况下我们会在没有相应的点击事件，但需要在页面展示过程中去不断调用某一函数情况下使用。</p><h2 id="谈谈Js中的this指向问题">谈谈Js中的this指向问题</h2><p><a href="https://www.zhihu.com/search?type=content&amp;q=js%E4%B8%AD%E7%9A%84this">(46 封私信 / 81 条消息) js中的this - 搜索结果 - 知乎 (zhihu.com)</a></p><p><a href="https://github.com/axuebin/articles/issues/6">https://github.com/axuebin/articles/issues/6</a></p><p>用一句最简单的话来说就是谁直接调用产生这个this指针的函数，this就指向谁。this具有运行时绑定的特性。具体来说：</p><ol><li><p>普通函数在全局环境中被调用，this指向window，即function是作为一个window的方法被调用的。</p></li><li><p>作为对象的属性被调用，this指向这个对象</p><p><strong>但是当在在对象方法中再定义函数，这时候 this 又是 window</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Jane&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Abby&#x27;</span>,</span><br><span class="line">    <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>);      <span class="comment">//window</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);    <span class="comment">//Jane</span></span><br><span class="line">        &#125;</span><br><span class="line">        fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.sayName();</span><br></pre></td></tr></table></figure><p>如果想让 this 指向 person 的话，只需要用 that 保存下来 this 的值即可，也可以使用 apply 等改变 this。</p></li><li><p>作为构造函数被调用，this 代表即将实例化的对象，但是如果在实例化时不加new,则this指向window</p></li><li><p>作为 call/apply/bind 方法的调用,指向传入的值</p></li></ol><h2 id="什么是同源，什么是跨域-（蔚来，字节）">什么是同源，什么是跨域-（蔚来，字节）</h2><p><a href="https://zhuanlan.zhihu.com/p/104984869">同源策略与跨域 - 知乎 (zhihu.com)</a></p><h3 id="同源Same-Origin-Policy（域名，协议，端口相同）">同源Same-Origin Policy（域名，协议，端口相同）</h3><p>同源是Netscape提出的一种安全策略，即所有支持js的浏览器都会使用改策略。同源策略是浏览器的行为</p><p>**同源指域名，协议，端口相同。**在请求数据执行脚本时，浏览器会检查脚本是否同源，若非同源会报异常提示拒绝访问。具体行为是拦截返回的数据，无法被浏览器接收</p><h3 id="跨域的情形"><strong>跨域的情形</strong></h3><p><img src="%E5%89%8D%E7%AB%AF%E4%B8%AA%E4%BA%BA%E9%9D%A2%E7%BB%8F%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%20dfad4/Untitled%201.png" alt="Untitled"></p><p>简单来说，是否跨域的3个因素：协议+域名+端口。</p><p>字节面试官在面试时用一句话概括了跨域：<strong>就是浏览器和服务端的信任问题，所有解决方案都是围绕着浏览器和服务端的信任问题来展开的。</strong></p><p>但有若干个标签是允许跨域的，比如：</p><ul><li><img src="xxx"/></li><li><link href="xxx"/></li><li><script src="xxx"/></li></ul><p>这些标签一般加载静态资源，和后端关系不大，因此重点关注AJAX跨域问题</p><h3 id="解决跨域"><strong>解决跨域</strong></h3><ol><li><p><strong>JSONP(Json with Padding)</strong></p><p>利用<script>元素的开放策略，可以从其他来源得到Json字段</p><p>缺点：</p><ol><li>JSONP只支持get请求而不支持post请求，如果想传给后台一个json格式的数据,此时问题就来了,浏览器会报一个http状态码415错误，请求格式不正确</li><li>JSONP本质是一种代码注入，存在安全问题</li></ol></li><li><p><strong>CORS</strong></p><p>W3C标准，全称（Cross-Origin resource sharing）</p><p>简单地说：<strong>JSONP是前端代码层面带一些东西给后端，CORS则是浏览器层面带一些东西给后端。本质上都需要前后端协商。</strong></p><p><img src="%E5%89%8D%E7%AB%AF%E4%B8%AA%E4%BA%BA%E9%9D%A2%E7%BB%8F%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%20dfad4/Untitled%202.png" alt="Untitled"></p><p>可以在服务端全局配置跨域规则（归宿的解决方案就是这样）</p><p>位于gateway/src/resources/application.yml内：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">globalcors:</span></span><br><span class="line">        <span class="attr">corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;localhost://*&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;localhost://8080&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;localhost://8082&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://localhost:8082&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://*.guisu.website&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;https://*.guisu.website&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://8.131.225.65&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;https://8.131.225.65&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">GET</span></span><br><span class="line">                <span class="string">POST</span></span><br><span class="line">                <span class="string">DELETE</span></span><br><span class="line">                <span class="string">PUT</span></span><br><span class="line">                <span class="string">OPTION</span></span><br></pre></td></tr></table></figure><p>也可以在controller的方法加入@CrossOrigin注解</p><p>还可以使用@Bean配置跨域Filter</p><p><strong>原理</strong></p><p>浏览器认为只要后端没返回CORS头(Access-Control-Allow-Origin)，就认为后端不允许跨域，返回的数据不可靠。</p></li></ol><h2 id="如何封装可复用组件（蔚来）">如何封装可复用组件（蔚来）</h2><p><a href="https://juejin.cn/post/6844903833898844174">vue组件封装指南 - 掘金 (juejin.cn)</a></p><p>组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性低等问题。</p><p>组件封装的大概过程<br>使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。但是我们一般用脚手架开发项目，每个 .vue单文件就是一个组件。在另一组件import 导入，并在components中注册，子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。<br><a href="https://blog.csdn.net/weixin_42312074/article/details/103878186?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=vue%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-103878186.nonecase&amp;spm=1018.2226.3001.4187">(25条消息) Vue组件封装（以封装一个button组件为例）_键盘捕手的博客-CSDN博客</a></p><h2 id="如何实现水平垂直居中">如何实现水平垂直居中</h2><h3 id="flex实现水平垂直居中">f<strong>lex实现水平垂直居中</strong></h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line"> <span class="attribute">display</span>: flex;</span><br><span class="line"> <span class="attribute">justify-content</span>: center;</span><br><span class="line"> <span class="attribute">align-items</span>: center;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line"> <span class="attribute">margin</span>: auto;</span><br><span class="line"> <span class="attribute">border</span>: <span class="number">1px</span> solid yellow;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.child</span> &#123;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"> <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="利用相对定位和绝对定位的margin-auto">**<strong>利用相对定位和绝对定位的<code>margin:auto</code></strong></h3><p>.</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">background</span>: skyblue;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: deepskyblue;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：首先子元素的<code>position:absolute</code>和父元素的<code>position:relative</code>定位配合使用，这样子元素就会相对于父元素进行定位，而不是基于整个页面进行定位，因为absolute的参照对象是离他最近的已定位的祖先元素。而position默认是static值,即没有定位，而<code>position:absolute</code>定位方式就是<strong>相对于定位方式不是static的第一个父元素进行定位</strong>，向上寻找元素一直到根元素为止，即body</p><p>为什么一般都是用相对定位呢，因为相对定位的特性是虽然它定位了，就算给了偏移量它离开了原来的地方，但是它原来占的地方也不会让出来的，这样的好处是原来在它周围的其他元素<strong>不会因为它的离开而改变位置而使页面乱套</strong>，因为在你这个例子里我们只是要让A作为B的一个参照偏移位置，并不需要A元素以及它周围的元素有所改变，所以用相对定位是非常合适的（如果你另有其他需要，祖先元素绝对定位也不是不可以）</p><h3 id="利用相对定位和绝对定位，再加上外边距和平移的配合"><strong><strong>利用相对定位和绝对定位，再加上外边距和平移的配合</strong></strong></h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">background</span>: skyblue;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: deepskyblue;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父元素relative和子元素absolute的原理和上面的方法相同，不过本方法首先使用top:50%和left：50%让子元素的左上角到了父元素的中心位置，然后在使用translate,第一个值为沿着x移动，第二个值为沿y移动，使其到达水平垂直居中的位置</p><h3 id="利用textAlign和verticalAlign">**<strong>利用<code>textAlign</code>和<code>verticalAlign</code></strong></h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">background</span>: skyblue;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span>:after &#123;</span><br><span class="line">  content: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用<code>textAlign:center</code>实现行内元素的水平居中，再利用<code>verticalAlign:middle</code>(vertical-align 属性设置该元素相对于所在行基线的垂直对齐方式）。前提是要先加上伪元素并给设置高度为100%</p><p><img src="%E5%89%8D%E7%AB%AF%E4%B8%AA%E4%BA%BA%E9%9D%A2%E7%BB%8F%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%20dfad4/Untitled%203.png" alt="Untitled"></p><p>vertical-align的默认属性是baseline</p><p><a href="https://www.jianshu.com/p/dea069fecb62">利用vertical-align:middle垂直居中 - 简书 (jianshu.com)</a></p><p><a href="https://www.zhihu.com/pub/reader/119583440/chapter/1057340705168474112">5.3.1 vertical-align 家族基本认识 - CSS 世界 - 知乎书店 (zhihu.com)</a></p><p>上面这本书对vertical-align有详细说明</p><p><strong>有关伪元素</strong></p><p>css的<code>伪元素</code>，之所以被称为伪元素，是因为他们不是真正的页面元素，html没有对应的元素，但是其所有用法和表现行为与真正的页面元素一样，可以对其使用诸如页面元素一样的css样式，表面上看上去貌似是页面的某些元素来展现，实际上是css样式展现的行为，因此被称为伪元素。如下图，是伪元素在html代码机构中的展现，可以看出无法伪元素的结构无法审查。</p><p><a href="https://www.cnblogs.com/wonyun/p/5807191.html">css伪元素:before和:after用法详解 - wonyun - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试知识手册--html/css篇</title>
      <link href="/2022/03/19/frontendpreparation1-html/"/>
      <url>/2022/03/19/frontendpreparation1-html/</url>
      
        <content type="html"><![CDATA[<hr><p>转载自一位大牛的总结仓库，搬运过来方便自己查阅~<br><a href="https://github.com/okaychen/FE-Interview-Brochure">原仓库地址</a></p><p>HTML&amp;CSS篇（第一个版本该篇预计总结常见问题20个左右），HTML&amp;CSS不少问题都能体现应届生对于前端基础的掌握程度，是应届生求职时不可忽视的重要一环</p><h1>HTML/CSS</h1><h2 id="浏览器解析渲染页面过程">浏览器解析渲染页面过程</h2><p>大致过程：</p><p>HTML解析构建DOM-&gt;CSS解析构建CSSOM树-&gt;根据DOM树和CSSOM树构建render树-&gt;根据render树进行布局渲染render layer-&gt;根据计算的布局信息进行绘制</p><p>不同浏览器的内核不同，所以渲染过程其中有部分细节有不一样，以webkit主流程为例：</p><p><img src="https://cdn.jsdelivr.net/gh/okaychen/CDN@2.0/brochure/image/browser.jpg" alt=""></p><p>一篇很棒的文章(需科学上网)：<a href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/">How Browser Work</a></p><blockquote><p>编者有话说：浏览器解析渲染页面过程是一个复杂的过程，其中有不少的细节和规则，如果把上面分享的文章翻译成译文，至少有3～5页PDF左右，所以这里只能总结大致过程（作为面试回答【很可能让回答的尽可能详细】了解来说已经足够，更深入的了解可以好好读下上面那篇文章）</p></blockquote><p>较详细过程：</p><p>HTML解析构建DOM树：其中HTML Parser就起到了将HTML标记解析成DOM Tree的作用，HTML Parser将文本的HTML文档，提炼出关键信息，嵌套层级的树形结构，便于计算拓展；这其中也有很多的规则和操作，比如容错机制，识别特殊标签<code>&lt;br&gt;&lt;/br&gt;</code>等</p><p>CSS解析构建CSSOM树：CSS Parser将很多个CSS文件中的样式合并解析出具有树形结构Style Rules，也叫做CSSOM。</p><blockquote><p>※其中还有一个细节是浏览器解析文档：当遇到<code>&lt;script&gt;</code>标签的时候会停止解析文档，立即解析脚本，将脚本中改变DOM和CSS的地方分别解析出来，追加到DOM Tree和CSSOM上</p></blockquote><p>根据DOM树和CSSOM树构建Render树：Render Tree的构建其实就是DOM Tree和CSSOM Attach的过程，在webkit中，解析样式和创建呈现器的过程称为&quot;附加&quot;，每个DOM节点都有一个&quot;attach&quot;方法，Render Tree其实就相当于一个计算好样式，与HTML对应的Tree</p><p>根据Render树进行布局渲染render layer：创建渲染树后，Layout根据根据渲染树中渲染对象的信息，计算好每一个渲染对象的位置和尺寸，将其放在浏览器窗口的正确位置，某些时候会在文档布局完成之后进行DOM修改，重新布局的过程就称为回流</p><blockquote><p>※其中计算（样式计算）一个复杂的过程，因为DOM中的一个元素可以对应样式表中的多个元素，Firefox采用了规则树和样式上下文树来简化样式计算，规则树包含了所有已知规则的匹配路径，样式上下文包含端值，webkit也有样式对象，但它们不保存在类似上下文树这样的结构中，只是由DOM节点指向此类对象的相关样式</p></blockquote><p>根据计算的布局信息进行绘制：绘制阶段则会遍历呈现树，并调用呈现器的paint方法，将呈现器的内容显示在屏幕上，绘制的顺序其实就是元素进入堆栈样式上下文的顺序，例如，块呈现器的堆栈顺序如下：1.背景颜色，2.背景图片，3.边框，4.子代，5.轮廓</p><h2 id="回流和重绘区别-减少回流重绘次数的方法">回流和重绘区别&amp;减少回流重绘次数的方法</h2><p>区别：</p><ul><li>回流指当前窗口发生改变，发生滚动操作，或者元素的位置大小相关属性被更新时会触发布局过程，发生在render树，比如元素的几何尺寸变化，就需要重新验证并计算Render Tree</li><li>重绘指当前视觉样式属性被更新时触发的绘制过程，发生在渲染层render layer</li><li>所以相比之下，回流的成本要比重绘高得多</li></ul><p>减少回流重绘次数的方法：</p><ul><li>1）避免一条一条的修改DOM样式，而是修改className或者style.classText</li><li>2）对元素进行一个复杂的操作，可以先隐藏它，操作完成后在显示</li><li>3）在需要经常获取那些引起浏览器回流的属性值时，要缓存到变量中</li><li>4）不使用table布局，一个小的改动可能就会引起整个table重新布局</li><li>5）在内存中多次操作节点，完成后在添加到文档中</li></ul><h2 id="关于transform开启GPU加速渲染，相比top-left，优势在哪里">关于transform开启GPU加速渲染，相比top&amp;left，优势在哪里</h2><blockquote><p>页面性能优化有一条，用transform代替top，left来实现动画。那么transform的优势在哪里？如何开启GPU加速渲染？开启GPU硬件加速可能会触发的问题，如何解决？</p></blockquote><p>首先相比定位的top&amp;left来说，transform不会引起整个页面的回流和重绘。其次我们可以通过transform开启GPU硬件加速，提高渲染速度，但相应的transform也会占用更多的内存。</p><h2 id="transform如何开启GPU硬件加速">transform如何开启GPU硬件加速</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">translateZ</span>(<span class="number">0</span>);</span><br><span class="line">    //或者</span><br><span class="line">    transfor:<span class="built_in">translate3d</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开启GPU硬件加速可能会触发哪些问题，如何处理">开启GPU硬件加速可能会触发哪些问题，如何处理</h2><p>可能会导致浏览器频繁闪烁或者抖动，解决方案：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">backface-visibility</span>: hidden;</span><br><span class="line">    <span class="attribute">perspective</span>: <span class="number">1000</span>;</span><br><span class="line">    -webkit-<span class="attribute">backface-visibility</span>: hidden;</span><br><span class="line">    -webkit-<span class="attribute">perspective</span>: <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="移动端点透现象有遇到过嘛">移动端点透现象有遇到过嘛</h2><p>首先需要了解的是，移动端在touch上一共有4个事件，</p><p>执行顺序为<code>touchstart -&gt; touchmove -&gt; touchend -&gt; touchcancel</code></p><p>当用户点击屏幕时，会触发touch和click事件，touch事件会优先处理，touch事件经过捕获，目标，冒泡一系列流程处理完成之后，才会触发click，所有我们经常会谈到移动端点击事件300ms延迟的问题</p><p>移动端点击事件300ms问题，常见的解决方案：</p><ul><li>阻止用户双击缩放，并限制视口大小</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; <span class="attribute">content</span>=&quot;<span class="attribute">width</span>=device-<span class="attribute">width</span>,<span class="attribute">initial</span>-scale=<span class="number">1</span>,minimum-scale=<span class="number">1</span>,maximum-scale=<span class="number">1</span>,user-scalable=no&quot;/&gt;</span><br></pre></td></tr></table></figure><ul><li>设置css<code>touch-action</code>用于指定某个给定的区域是否允许用户操作，以及如何相应用户操作</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  touch-action: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>fastclick.js来解决，其原理是在检测到touchend事件的时候，会通过自定义事件立即触发模拟一个click事件，并在300ms之后把真正的click事件阻止掉</li></ul><p>点透现象：</p><p>发生条件：①按钮A和按钮B不是后代继承关系，②A发生touch，A touch后立即消失，B绑定click，③A z-index大于B，即 A 显示在 B 浮层之上</p><p>发生原因：当点击屏幕时，系统生成touch和click两个事件，touch先执行，touch执行完之后A消失，然后要执行click的时候，就会发现用户点击的是B，所以就执行了B的click</p><p>解决方法：①阻止默认事件，在touch的某个时间段执行event.preventDefault，去取消系统生成的click事件，一半在 touchend 中执行。②要消失的元素延迟300ms后在消失</p><h2 id="Doctype是什么，三种模式的区别在什么地方">Doctype是什么，三种模式的区别在什么地方</h2><p>Doctype是一种DTD文档定义类型，必须声明在HTML文档的第一行，用来规范文档使用哪种方式解析HTML，三种模式分别是怪异模式，标准模式，近乎模式(IE8的一种近乎于前两者之间的一种模式)；标准模式按照HTML和CSS定义渲染，怪异模式会模拟更旧的浏览器行为</p><h2 id="说说对两种盒模型的理解">说说对两种盒模型的理解</h2><p>标准盒模型和IE怪异盒模型，标准盒模型下：盒子总宽度/高度=width/height+padding+border+margin</p><p><img src="https://cdn.jsdelivr.net/gh/okaychen/CDN@2.0/brochure/image/box_model01.png" alt=""></p><p>怪异盒模型，IE5.X 和 6 在怪异模式中使用自己的非标准模型，盒子的总宽度和高度是包含内边距padding和边框border宽度在内的：盒子总宽度/高度=width/height + margin = width/height + margin;</p><p><img src="https://cdn.jsdelivr.net/gh/okaychen/CDN@2.0/brochure/image/box_model02.png" alt=""></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">box-sizing</span> : content-box || border-box || inherit;</span><br></pre></td></tr></table></figure><p>boxsizing属性content-box使用标准盒模型的计算方式，border-box则使用怪异盒模型的计算方式</p><h2 id="margin塌陷和合并问题">margin塌陷和合并问题</h2><p>首先，margin塌陷是相对于父子级关系的两个元素，而margin合并是相对两个兄弟级关系的两个元素</p><p>两个兄弟级关系的元素，垂直方向上的margin，其外边距会发生重叠现象，两者两个的外边距取的是两个所设置margin的最大值，就是所说的margin合并问题</p><p>两个父子级关系的元素，垂直方向上的margin会粘合在一起，外层和模型的margin-top取两个元素中margin-top的最大值，发生margin塌陷的内层元素相对于整个文档移动</p><p>解决方案：两者都可以通过触发BFC来解决</p><h2 id="关于IFC和BFC，哪些元素会触发BFC">关于IFC和BFC，哪些元素会触发BFC</h2><p>首先需要知道文档流分为定位流，浮动流和普通流三种，而普通流则是BFC中的FC（格式化上下文），它是页面的一块渲染区域，有一套渲染规则，决定了子元素如何布局，以及和其他元素之间的关系和作用，常见的FC有BFC，IFC，还有GFC和FFC</p><p>BFC块级格式化上下文，IFC行级格式化上下文，</p><p>哪些元素会触发BFC：</p><ul><li>根元素</li><li>float的属性不为none</li><li>position属性为absolute或fixed</li><li>display为inline-block，table-cell，table-caption，flex</li><li>overflow不为visible</li></ul><h2 id="CSS定位的方式有哪些分别相对于谁">CSS定位的方式有哪些分别相对于谁</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">static(默认值)</span><br><span class="line">absolute(绝对定位，相对于最近已定位的父元素，如果没有则相对于&lt;<span class="selector-tag">html</span>&gt;)</span><br><span class="line">fixed(固定定位，相对于窗口)</span><br><span class="line">relative(相对定位，相对于自身)</span><br><span class="line">sticky(<span class="number">2017</span>年浏览器开始支持，粘性定位)</span><br></pre></td></tr></table></figure><p>absolute会使元素位置与文档流无关，不占据空间，absolute 定位的元素和其他元素重叠</p><p>relative相对定位时，无论元素是否移动，仍然占据原来的空间</p><p>sticky是2017年浏览器才开始支持，会产生动态效果，类似relative和fixed的结合，一个实例是&quot;<a href="http://www.ruanyifeng.com/blog/2019/11/css-position.html">动态固定</a>&quot;，生效前提是必须搭配<code>top,left,bottom,right</code>一起使用，不能省略，否则等同于<code>relative</code>定位，不产生&quot;动态固定&quot;的效果</p><h2 id="移动端布局的解决方案，平时怎么做的处理">移动端布局的解决方案，平时怎么做的处理</h2><ul><li>使用Flexbox</li><li>百分比布局结合媒体查询</li><li>使用rem</li></ul><p>rem转换像素大小（根元素的大小乘以rem值），取决与页面根元素的字体大小，即HTML元素的字体大小</p><p>em转换像素大小（em值乘以使用em单位的元素的字体大小），比如一个div的字体大小为16px，那么10em就是180px（或者接近它）</p><p>rem平时怎么做的转换：为了方便计算，时常将html的字体大小设置为62.5%，那么12px就会是1.2rem</p><h2 id="垂直水平居中的多种解决方案">垂直水平居中的多种解决方案</h2><h3 id="未知宽高元素实现垂直水平居中">未知宽高元素实现垂直水平居中</h3><p>① flex实现水平垂直居中</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>② 进行垂直水平居中（利用transform中translate偏移的百分比值是相对于自身大小的特性）</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">      <span class="attribute">position</span>: relative;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">      <span class="attribute">margin</span>: auto;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">1px</span> solid yellow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">      <span class="attribute">position</span>: absolute;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.method3</span> &#123;</span><br><span class="line">      <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">      <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="已知宽高元素的垂直水平居中">已知宽高元素的垂直水平居中</h3><p>① 绝对定位+<code>margin:auto</code></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>② 使用绝对定位与负边距</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: -<span class="number">50px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="经典的三栏布局的实现方式">经典的三栏布局的实现方式</h2><p>三栏布局：两侧定宽中间自适应，在开发中很常见的布局方式，主要有下面六种实现方式：</p><ul><li>最简单的方式就是通过float实现</li><li>利用绝对定位</li><li>利用BFC规则</li><li>圣杯布局（通过margin负值调整）</li><li>双飞翼布局（和双飞翼布局类似，只是处理中间栏被遮挡的方式不同：双飞翼布局在中间栏内部加一个div，设置其margin来避开遮挡）</li><li>利用flex布局 👇 <em>Q14</em></li></ul><h2 id="对flex布局的了解，flex如何实现经典的三栏布局">对flex布局的了解，flex如何实现经典的三栏布局</h2><p>flex意为弹性布局，有两大概念，一是容器(container)，二是项目(item)，两者都有各自的六个常用属性</p><p>用在容器上的六个属性：</p><ul><li><code>flex-direction</code>主轴的方向，</li><li><code>flex-wrap</code>一条轴线装满，如何换行，</li><li><code>flex-flow</code>是前两者的简写，</li><li><code>justify-content</code>项目在主轴上的对齐方式</li><li><code>align-items</code>在交叉轴上如何对齐</li><li><code>align-content</code>多跟轴线的对齐方式</li></ul><p>用在项目上的六个属性:</p><ul><li><code>order</code>排序顺序，默认为0，越小越靠前</li><li><code>flex-grow</code>项目的放大比例，默认为0，不放大</li><li><code>flex-shrink</code>项目的缩小比例，默认为1，空间不足该项目会缩小</li><li><code>flex-basis</code>项目占据主轴空间大小</li><li><code>flex</code>是上面放大，缩小，大小三者的简写，默认为0 1 auto</li><li><code>align-self</code>允许单个项目有不同于其他的对齐方式</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--flex实现经典的三栏布局--&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.flex-container&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.middle &#123;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: yellowgreen;</span><br><span class="line">    flex-grow: 1;</span><br><span class="line">&#125;</span><br><span class="line">.left,.right &#123;</span><br><span class="line">    height: 200px;</span><br><span class="line">    flex: 0 1 200px;</span><br><span class="line">    background-color: green;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;flex-container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;左侧内容&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;middle&quot;&gt;中间内容&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;右侧内容&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/okaychen/CDN@2.0/brochure/image/layout01.png" alt=""></p><h2 id="说说你知道的清除浮动的方法，知道其中的原理嘛">说说你知道的清除浮动的方法，知道其中的原理嘛</h2><p>清除浮动主要是为了解决父元素因为子元素浮动内部高度为0的问题</p><ul><li>额外标签，即在最后一个浮动标签后加一个空div，给其设置<code>clear:both</code>，缺点是增加无意义标签，语义化差</li><li>给父级元素添加<code>overflow:不为visible</code>通过触发BFC的方式清除浮动</li><li>使用after伪元素，缺点是IE6-7不支持伪元素，zoom:1触发hasLayout</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>:after&#123;</span><br><span class="line">    content:<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">    <span class="attribute">visibility</span>:hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">    *zoom:<span class="number">1</span>; <span class="comment">/*ie6清除浮动的方式 *只有IE6-IE7执行*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用before和after双伪元素清除浮动</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>:after,.clearfix:before&#123;</span><br><span class="line">    content:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>:table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>:after&#123;</span><br><span class="line">    clear:both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clear</span>&#123;</span><br><span class="line">    *zoom:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对css-sprits的理解，好处是什么">对css sprits的理解，好处是什么</h2><p>css sprits又名雪碧图，也叫css精灵，开发人员会将很多小图标合并在一起之后的图片成为雪碧图，使用时通过background-image、background-position和background-size属性，将对应的小图标添加元素中</p><p>优点是：</p><ul><li>减少加载多张图片的HTTP请求数</li><li>可以提前加载资源</li></ul><p>缺点是：</p><ul><li>维护成本较高，需要改动这张合并的图片</li><li>加载优势在http2之后不复存在，http2采用多路复用，多张图片也可以重复使用一个连接</li></ul><h2 id="说一下前端的几种存储方式">说一下前端的几种存储方式</h2><p>cookie，localstorage，sessionstorage，IndexedDB</p><p>（追问）这些方式的区别是什么，分别介绍一下：</p><ul><li>cookie：HTML5标准前本地存储主要方式，请求头带着数据，缺点是大小只有4k左右，并且自动请求头加入cookie浪费流量，每个domain限制20个cookie，使用起来也麻烦需要自行封装</li><li>localstorage：HTML5标准后加入，以键值对（key-value）方式存储，永久存储，永不失效，除非手动删除，IE8+支持，每个域名限制5M</li><li>sessionstorage：和localstorage操作方法一样，区别在于sessionstorage在关闭页面后即被清空，刷新不会清空，但是不能在所有同源窗口中共享，是会话级别的存储方式</li><li>IndexedDB：被纳入HTML5标准的数据库存储方案，它是一个NoSql数据库，用键值对进行存储，可以快速读取操作，适合web场景和JavaScript操作</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode刷题笔记-链表</title>
      <link href="/2022/03/18/leetcode-2/"/>
      <url>/2022/03/18/leetcode-2/</url>
      
        <content type="html"><![CDATA[<h1>Leetcode—链表专题</h1><h2 id="1-链表基础知识">1. 链表基础知识</h2><p>单链表在C++中的定义方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    <span class="keyword">int</span> val;  <span class="comment">// 节点上存储的元素</span></span><br><span class="line">    ListNode *next;  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(NULL) &#123;&#125;  <span class="comment">// 节点的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在java中的定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结点的值</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="comment">// 下一个结点</span></span><br><span class="line">    ListNode next;</span><br><span class="line">    <span class="comment">// 节点的构造函数(无参)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 节点的构造函数(有一个参数)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 节点的构造函数(有两个参数)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val, ListNode next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-移除链表元素203">2.移除链表元素203</h2><p><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">203. 移除链表元素 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>对此可以设置虚拟头节点，以便对头节点和非头节点作统一处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode virtualHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, head);</span><br><span class="line">        ListNode pre = virtualHead;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val == val)&#123;</span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> virtualHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-707-设计链表707">3. 707 设计链表707</h2><p><a href="https://leetcode-cn.com/problems/design-linked-list/submissions/">707. 设计链表 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>这道题做了几乎是两个多小时，错了很多遍才得到满分，可以说对链表还很不熟练。</p><p>和答案相比，有以下不同：</p><ol><li>首先是答案使用了虚拟头节点，在初始化的时候就实例化了一个头节点，并将值设为默认值0.</li><li>设置了一个属性size，能快速判断index是否超过范围</li></ol><p><strong>get方法：</strong></p><p>me:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        LinkNode cur = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt; index; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="keyword">null</span>)</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> cur.val;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>没有考虑到index&lt;0的情况</p><p>使用size后不用每次都判断cur是否为空了</p><p>key:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取第index个节点的数值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果index非法，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode currentNode = head;</span><br><span class="line">        <span class="comment">//包含一个虚拟头节点，所以查找第 index+1 个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentNode.val;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>addAtHead()方法</strong></p><p>me：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkNode node = <span class="keyword">new</span> LinkNode(val);</span><br><span class="line">        node.next = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">this</span>.head = node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>key：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在链表最前面插入一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>addAtTail()方法</strong></p><p>me:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkNode cur = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkNode(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = <span class="keyword">new</span> LinkNode(val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>key:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在链表的最后插入一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        addAtIndex(size, val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再次体现出size的好处，直接调用addAtIndex方法</p><p><strong>addAtIndex方法</strong></p><p>me:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkNode(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index == <span class="number">1</span>)&#123;</span><br><span class="line">                head.next = <span class="keyword">new</span> LinkNode(val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">                LinkNode node = <span class="keyword">new</span> LinkNode(val);</span><br><span class="line">                node.next = <span class="keyword">this</span>.head;</span><br><span class="line">                <span class="keyword">this</span>.head = node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        LinkNode pre = <span class="keyword">this</span>.head;</span><br><span class="line">        LinkNode cur = <span class="keyword">this</span>.head.next;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">            LinkNode node = <span class="keyword">new</span> LinkNode(val);</span><br><span class="line">            node.next = <span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">this</span>.head = node;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num == index)&#123;</span><br><span class="line">                LinkNode node = <span class="keyword">new</span> LinkNode(val);</span><br><span class="line">                pre.next = node;</span><br><span class="line">                node.next = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num == index)</span><br><span class="line">            pre.next = <span class="keyword">new</span> LinkNode(val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>key:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span></span><br><span class="line">    <span class="comment">// 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span></span><br><span class="line">    <span class="comment">// 如果 index 大于链表的长度，则返回空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">//找到要插入节点的前驱</span></span><br><span class="line">        ListNode pred = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode toAdd = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        toAdd.next = pred.next;</span><br><span class="line">        pred.next = toAdd;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>deleteAtIndex方法</strong></p><p>me:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        LinkNode pre = <span class="keyword">this</span>.head;</span><br><span class="line">        LinkNode cur = pre.next;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">if</span>(num == index)</span><br><span class="line">            &#123;</span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>key:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除第index个节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    size--;</span><br><span class="line">    ListNode pred = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        pred = pred.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pred.next = pred.next.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还可以使用双链表的方法，节点设置前驱和后置两个属性，然后链表设置头节点和尾节点。同时也设置虚拟头节点，尾节点的next属性指向头节点。</p><h2 id="4-206反转链表">4. 206反转链表</h2><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></p><blockquote><p>给你单链表的头节点 <code>head</code>，请你反转链表，并返回反转后的链表。</p></blockquote><p>第一次真的没有做出来…感觉基础很不扎实，所以这里记录下思路吧。大致可以分为迭代和递归两种方法。首先是迭代，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">ListNode cur = head;</span><br><span class="line"><span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">ListNode next = cur.next;</span><br><span class="line">cur.next = pre;</span><br><span class="line">pre = cur;</span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在遍历链表时，将当前节点的 \textit{next}next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)<em>O</em>(<em>n</em>)，其中 n<em>n</em> 是链表的长度。需要遍历链表一次。</li><li>空间复杂度：O(1)<em>O</em>(1)。</li></ul><p>其次是递归方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">ListNode newHead =  reverseList(head.next);</span><br><span class="line">head.next.next = head;</span><br><span class="line">head.next = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如对于链表：1→2→3→4→5,当递归到最底层时，head为5，此时相当于让null指向head;第二轮返出栈后head=4,head→next为5，让5指向4，除此之外还要让4不指向5，因此head→next = null；直到全部出栈完成。</p><h2 id="24-两两交换链表中的节点">24. 两两交换链表中的节点</h2><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点 - 力扣（LeetCode） (leetcode-cn.com)</a></p><blockquote><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p></blockquote><p><img src="Leetcode%E2%80%94%E9%93%BE%203f9d1/Untitled.png" alt="Untitled"></p><p>最开始也是卡了很久，感觉还是不太熟练，链表指针的赋值思路很乱，花了很久才写出来下面的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        newHead.next = head;</span><br><span class="line">        ListNode pre = newHead;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            pre.next = next;</span><br><span class="line">            ListNode nextNode = next.next;</span><br><span class="line">            next.next = cur;</span><br><span class="line">            cur.next = nextNode;</span><br><span class="line">            <span class="keyword">if</span>(nextNode != <span class="keyword">null</span> &amp;&amp; nextNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = nextNode;</span><br><span class="line">                next = nextNode.next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准答案的迭代方法明显更加简洁：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 虚拟头结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ListNode dummyNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line">    ListNode prev = dummyNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (prev.next != <span class="keyword">null</span> &amp;&amp; prev.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ListNode temp = head.next.next; <span class="comment">// 缓存 next</span></span><br><span class="line">      prev.next = head.next;          <span class="comment">// 将 prev 的 next 改为 head 的 next</span></span><br><span class="line">      head.next.next = head;          <span class="comment">// 将 head.next(prev.next) 的next，指向 head</span></span><br><span class="line">      head.next = temp;               <span class="comment">// 将head 的 next 接上缓存的temp</span></span><br><span class="line">      prev = head;                    <span class="comment">// 步进1位</span></span><br><span class="line">      head = head.next;               <span class="comment">// 步进1位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，力扣还提供了递归的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = head.next;</span><br><span class="line">        head.next = swapPairs(newHead.next);</span><br><span class="line">        newHead.next = head;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>递归的终止条件是链表中没有节点，或者链表中只有一个节点，此时无法进行交换。</p><p>如果链表中至少有两个节点，则在两两交换链表中的节点之后，原始链表的头节点变成新的链表的第二个节点，原始链表的第二个节点变成新的链表的头节点。链表中的其余节点的两两交换可以递归地实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换。</p><p>用 head 表示原始链表的头节点，新的链表的第二个节点，用 newHead 表示新的链表的头节点，原始链表的第二个节点，则原始链表中的其余节点的头节点是 newHead.next。令 head.next = swapPairs(newHead.next)，表示将其余节点进行两两交换，交换后的新的头节点为 head 的下一个节点。然后令 newHead.next = head，即完成了所有节点的交换。最后返回新的链表的头节点 newHead。</p><h2 id="19-删除链表的倒数第N个节点">19 删除链表的倒数第N个节点</h2><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/submissions/">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>在提示下做出来了，双指针法，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更推荐虚拟头节点的写法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        ListNode slow = dummy;</span><br><span class="line">        ListNode fast = dummy;</span><br><span class="line">        <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记住 待删除节点slow 的上一节点</span></span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            prev = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上一节点的next指针绕过 待删除节点slow 直接指向slow的下一节点</span></span><br><span class="line">        prev.next = slow.next;</span><br><span class="line">        <span class="comment">// 释放 待删除节点slow 的next指针, 这句删掉也能AC</span></span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-链表相交">7 链表相交</h2><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/submissions/">面试题 02.07. 链表相交 - 力扣（LeetCode） (leetcode-cn.com)</a></p><blockquote><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p></blockquote><p><img src="Leetcode%E2%80%94%E9%93%BE%203f9d1/Untitled%201.png" alt="Untitled"></p><p>因为题目定义的相交是第一个相等的节点后面的所有节点都相等，可知重合的部分长度都是相等的，因此只需将链表对齐即可。</p><p>思路是先分别得出两个链表的长度，然后求出差值，对其链表，然后依次向后移动，直到第一个相等的节点出现，就是首次重叠的节点。</p><h2 id="142-环形链表II">142 环形链表II</h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>考研书上的一道题，第一次做没什么思路，代码随想录的答案总结就写的挺好的，如下：</p><p><a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p><p>看了题解后写的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fastNode = head;<span class="comment">//fast iterator</span></span><br><span class="line">        ListNode slowNode = head;<span class="comment">//slow iterator</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slowNode == <span class="keyword">null</span> || fastNode == <span class="keyword">null</span> || fastNode.next == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            fastNode = fastNode.next.next;</span><br><span class="line">            slowNode = slowNode.next;</span><br><span class="line">            <span class="keyword">if</span>(fastNode != slowNode)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时必有环</span></span><br><span class="line">        ListNode newNode = head;</span><br><span class="line">        <span class="keyword">while</span>(newNode != slowNode)&#123;</span><br><span class="line">            newNode = newNode.next;</span><br><span class="line">            slowNode = slowNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要问题是一开始while(条件)内的条件不知道如何写合适，因为如果写while(slowNode ≠ fastNode)这样最开始就无法进入循环，所以只好写while(true)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;<span class="comment">// 有环</span></span><br><span class="line">                ListNode index1 = fast;</span><br><span class="line">                ListNode index2 = head;</span><br><span class="line">                <span class="comment">// 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口</span></span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了标答觉得slowNode ≠ null没有必要写</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用ildasm工具分析C# 闭包外部变量实现原理</title>
      <link href="/2022/03/17/ildasm/"/>
      <url>/2022/03/17/ildasm/</url>
      
        <content type="html"><![CDATA[<p>在使用工具分析之前，我们需要先明白什么是闭包。闭包不是针对于C#提出的，在许多语言尤其是函数式编程的语言中都有广泛使用，比如javascript。但是不同语言对于闭包的实现方式不同，本文档着手通过反编译工具来探究C# 闭包外部变量的实现原理。</p><h3 id="闭包定义"><strong>闭包定义</strong></h3><p>我们把在Lambda表达式(或匿名方法)中所引用的外部变量称为<strong>捕获变量</strong>。而捕获变量的表达式就称为<strong>闭包</strong>。</p><p>而在《javascript高级程序设计》中，对闭包有更加准确的解释：</p><p><strong>闭包是指有权访问另一个函数作用域中的变量的函数。</strong></p><p>捕获的变量会在真正<strong>调用委托</strong>时“赋值”，而不是在捕获时“赋值”，即总是使用捕获变量的<strong>最新的值</strong>。</p><p>比如如下所示的代码：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> age = <span class="number">28</span>;</span><br><span class="line"><span class="comment">//定义委托，通用委托，返回string,有一个参数int</span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; consoleAge = i =&gt; <span class="string">$&quot;洋小豆今年<span class="subst">&#123;i&#125;</span>岁了&quot;</span>;</span><br><span class="line">age = <span class="number">30</span>;</span><br><span class="line"><span class="comment">//调用委托</span></span><br><span class="line"><span class="built_in">string</span> outputMsg = consoleAge(age);</span><br><span class="line">outputMsg.Dump();</span><br></pre></td></tr></table></figure><h3 id="捕获迭代变量">捕获迭代变量</h3><p>当捕获的外部变量为for循环的迭代变量时，C#认为变量i是定义在循环体外的。所以，当添加委托集合的for循环执行完时，i的值已经变为3了；因此，我们在foreach中循环调用委托时，i的值为3。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">List&lt;Action&gt; levyActions =<span class="keyword">new</span> List&lt;Action&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">   levyActions.Add(()=&gt; i.Dump());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span> (Action actionin levyActions)</span><br><span class="line">&#123;</span><br><span class="line">   action();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的值均为3.</p><p>从C#5.0开始，foreach认为循环变量都是新的变量，所以每次循环中创建委托时捕获的变量都不是同一个变量，比如如下的代码：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] names =newstring[] &#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">List&lt;Action&gt; levyActions =<span class="keyword">new</span> List&lt;Action&gt;();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> namein names)</span><br><span class="line">&#123;</span><br><span class="line">   levyActions.Add(()=&gt; name.Dump());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出值为”1，2，3”</p><h3 id="闭包原理">闭包原理</h3><p>分析IL代码我们可以得知，编译器在背后生成了一个私有的密封类c__DisplayClass4_0，它将外部变量包装成类的成员变量，而委托方法包装成类的方法。所以，上述捕获for迭代变量的示例代码就可以修改成如下：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> List&lt;Action&gt; levyActions =<span class="keyword">new</span> List&lt;Action&gt;();</span><br><span class="line"> c__DisplayClass4_0 local =<span class="keyword">new</span> c__DisplayClass4_0();</span><br><span class="line"><span class="keyword">for</span> (local.i = <span class="number">0</span>; local.i &lt; <span class="number">3</span>; local.i++)</span><br><span class="line"> &#123;</span><br><span class="line">    levyActions.Add(() =&gt; local.Main_b__0());</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">foreach</span> (Action actionin levyActions)</span><br><span class="line"> &#123;</span><br><span class="line">    action();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">c__DisplayClass4_0</span>&#123;</span><br><span class="line">publicint i;</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">Main_b__0</span>(<span class="params"></span>)<span class="comment">//使用interval关键字，限制只能在同一程序集内访问</span></span></span><br><span class="line"> &#123;</span><br><span class="line">    i.Dump();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用ildasm工具分析实例代码：">使用ildasm工具分析实例代码：</h3><p>在课上老师带我们分析了如下的实例代码：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//相当于 int fnAdd(int a, int b);</span></span><br><span class="line"><span class="comment">//public delegate TResult Func&lt;in T1, in T2, out TResult&gt;(T1 arg1, T2 arg2);</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; <span class="title">someFunc</span>(<span class="params"><span class="built_in">int</span> one</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> two = <span class="number">500</span>;</span><br><span class="line"><span class="comment">//返回函数(委托)使用lamda表达式</span></span><br><span class="line"><span class="keyword">return</span> (o1, o2) =&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//使用外部变量</span></span><br><span class="line">two += one;</span><br><span class="line"><span class="keyword">return</span> one + two + o1 + o2;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;返回函数,使用外部变量&quot;</span>);</span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; fnOne = someFunc(<span class="number">500</span>);</span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; fnTwo = someFunc(<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">int</span> r1 = fnOne(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">int</span> r2 = fnTwo(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;r1: <span class="subst">&#123;r1&#125;</span>  r2: <span class="subst">&#123;r2&#125;</span>&quot;</span>);</span><br><span class="line">r1 = fnOne(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">r2 = fnTwo(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;r1: <span class="subst">&#123;r1&#125;</span>  r2: <span class="subst">&#123;r2&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先分析<code>someFunc</code>，该函数返回一个通用委托，其函数签名为以两个<code>int</code>作为参数，返回一个<code>int</code>，因此该函数内使用了闭包，用匿名函数返回，匿名函数中使用了作用域外的<code>two</code>变量。</p><p>在Main()函数中，定义了两个通用委托<code>fnOne</code> <code>fnTwo</code>,因此分别有两个变量two，在不同的存储空间地址，我们暂时命名为<code>two1</code> <code>two2</code> .之后定义了两个<code>int</code>调用委托，委托内的表达式首次被执行，此时委托对外部变量进行相加操作，因此<code>two1</code> <code>two2</code>变为1000和1500，因此<code>r1</code>和<code>r2</code>分别为1503和2503.之后再次调用委托，因此<code>r1</code>和<code>r2</code>变为了2503和3503.</p><p>因此整个<code>Main()</code>的输出结果如下：</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720220317133315.png" alt=""></p><p>此时我们打开ildasm工具，代开项目空间内的<code>dll</code>文件，查看<code>test.cs</code>的IL代码，首先我们发现里面新定义了一个类，如下所示：</p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720220317133534.png" style="zoom:67%;" /><p>定义了一个私有类<code>c_DisplayClass0_0</code>将外部变量定义为内部的成员变量，查看SommFunc的代码，如下所示：</p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720220317133656.png" style="zoom:67%;" /><p>我们可以发现函数内调用的均为类中的成员变量<code>two</code>和<code>one</code></p><p>打开其运行时代码，如下所示：</p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720220317134023.png" style="zoom:67%;" /><p>可以看到在函数中创建了一个该类的实例，局部变量实际上是作为匿名类中的字段存在的。</p><h3 id="C-7-0对于不作为返回值的闭包的优化">C#7.0对于不作为返回值的闭包的优化</h3><p>如果在vs2017中编写匿名函数时会得到一个提示，询问是否把lambda表达式（匿名函数）托转为本地函数。本地函数是c#7提供的一个新语法。</p><p>此时若使用反编译工具分析，可以发现有如下两点变化：</p><ol><li>定义的类变为定义临时结构体</li><li>不再构建委托实例，直接调用值类型的实例方法</li></ol><p>上述这两点变化在一定程度上能够带来性能的提升，目前的理解是，<strong>用结构体代替类，结构体实例能够在方法跑完后就立即释放，不需要等待垃圾回收</strong>，所以在官方的推荐中，如果委托的使用不是必要的，更推荐使用本地函数而非匿名函数。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蔚来面试问题记录</title>
      <link href="/2022/03/11/weilai/"/>
      <url>/2022/03/11/weilai/</url>
      
        <content type="html"><![CDATA[<h1>蔚来前端实习生面试流程</h1><p>2022年3月11日，睡午觉到四点后，四点半迎来了自己人生中第一场实习面试。进飞书和老师打招呼后，老师直截了当地给我发了题目地址，进行1小时的javascript题目测试，14道做出来5道就行。（这个东西，dddd，《提前准备》）</p><p>半小时做完题目后，（没有自我介绍环节），面试官直接让我简单介绍一下自己的项目（其实是他提了下项目，我主动说要介绍的），我当时是只介绍了我做的部分，花了两三分钟介绍完后，面试官就开始问题轰炸了。连续轰炸了一小时…</p><p>凭我仅存的记忆，他大概问了这些问题：</p><ol><li><strong>阐述一下Vue的生命周期</strong>（答得不好，没怎么看过这块，就直说了created，mounted这些）</li><li><strong>谈谈js中this</strong></li><li><strong>如何通过SSO的机制实现网站通过搜索引擎可以直接搜索到</strong>（当时以为是网站收录，结果说了一堆面试官说不是想要的答案，就不知道了）</li><li><strong>如何实现组件化设计，比如首页的这些卡片，如何写能够使其他地方服用，即如何封装成一个组件</strong>（也没有答得很好，因为确实没有封装过组件，最后老师转而问组件之间的沟通方式）</li><li><strong>组件之间是如何沟通的</strong>（算是答出来了，v-bind,props这些）</li><li><strong>如何让图片以不进行任何压缩的形式展示到网页上，以个人主页上上传的图片预览如何不压缩为例</strong>（想了半天，最后憋出来fit属性居然就是老师想要的答案）</li><li><strong>对于页面某些关键信息，可以通过什么手段来防止非法访客窃取信息？</strong>（当时答了加密和反爬，感觉老师还想要答案）</li><li><strong>对于一组v-for的div，有哪些方法实现除了第一个div的margin-top为0以外其他的div均有margin-top</strong>（第一时间想到了grid布局，然后是js实现，最后老师提示了好久憋出来可以用css选择器）</li><li><strong>开始问什么是css选择器，什么是伪css元素</strong>（没学过，不知道）</li><li><strong>表单如何实现默认信息的填入</strong>（因为看我没有实现默认信息的填入）</li><li><strong>侧边栏的动画咋实现的</strong>（纯css）</li><li>**如何实现keep alive，大概就是如何实现点击到另外一个页面再回来的时候还能显示上次显示的信息，避免再次调api，尤其是手机端很常用（**扯了半天localstorage,最后说不知道）</li><li><strong>顶栏的选中状态，如点击到论坛，论坛显示被选中的样式，当跳转到不同的页面时，这个被选中的状态是如何被保存的</strong>（没答出来…）</li><li><strong>js如何快速获取一组数组内为偶数的元素</strong>(最开始说foreach,map，经过提示说了filter)</li><li><strong>阐述一下网页的整个登录如何实现的</strong>(token)</li><li><strong>你们的项目是如何存的登陆状态的</strong>（没答好）</li><li><strong>如何实现点击回到顶部，并且要求非线性动画</strong>（说了下自己作wiki的经历）</li><li><strong>首页鼠标移入头像旋转是如何实现的</strong></li><li><strong>如何实现某一动画的循环播放</strong></li><li><strong>什么是computed</strong>(没答好)</li><li><strong>什么是非同源，什么是同源，什么是跨域，什么是同站</strong>（乱答的）</li><li><strong>你还有啥想问的</strong>（问了下蔚来前端的主要业务范围）</li><li><strong>一周能来几天，来不了三天gun</strong></li></ol><p>希望能进</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说健身这件事</title>
      <link href="/2022/03/09/muscle/"/>
      <url>/2022/03/09/muscle/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 运动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 撸铁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些日常跑步记录</title>
      <link href="/2022/03/09/running-1/"/>
      <url>/2022/03/09/running-1/</url>
      
        <content type="html"><![CDATA[<p>从2022年3月9号开始，记录一下自己每天的日常跑步吧~<br>至于为什么要选择这一天作为记录的第一天，因为咱们的汪汪汪今天开始跑步了！！！建议把3.9号定一个纪念日</p><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2022</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-09</p></div></div><div class='timeline-item-content'><p>有氧轻松跑–绕着体育场跑了4.38公里，用时20：47，平均配速4：44，步频172步幅122，平均心率180；还是不习惯路跑，各种上下坡和拐弯消耗了很多体力，然后心率还是居高不下哇，是因为自己跑的太用力吗？</p><div class="fj-gallery"><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220309234903644.png" alt="image-20220309234903644"><br><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220309235034152.png" alt="image-20220309235034152"></p>          </div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-11</p></div></div><div class='timeline-item-content'><p>日常刷锻&amp;两公里训练，2.02公里，用时7分52，平均配速3：53，步频172步幅149和上次步频一样但是步幅提升很多，平均心率177；今天状态很不错，也是最近2000m跑的最快的一次了，跑完很有成就感！</p><div class="fj-gallery"><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220314201304004.png" alt="image-20220314201304004"></p>          </div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-12</p></div></div><div class='timeline-item-content'><p>日常刷锻&amp;两公里训练，2.0公里，用时8分21，平均配速4分10，步频163步幅147和上次步幅差不多但是步频慢了很多，平均心率170；为什么慢了这么多呢？因为今天穿的便装哈哈哈！长袖长裤老爹鞋，能跑快才怪了</p><div class="fj-gallery"><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220314201552814.png" alt="image-20220314201552814"></p>          </div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-13</p></div></div><div class='timeline-item-content'><p>第一次间歇跑！，2.0公里，用时6分26，平均配速3分17，五次400m的时间分别是1：15，1：16，1：16，1：19，1：20.前三次都还顶得住，但是到了第四次就很难受了，特别是第五次间歇的时候，甚至有种头晕的感觉，看来间歇跑一周不能练超过两次，不然真的顶不住，不过今天刚好是封操场的第一天，也练不了了哈哈哈</p><div class="fj-gallery"><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220314201948651.png" alt="image-20220314201948651"></p>          </div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-15</p></div></div><div class='timeline-item-content'><p>有氧跑，因为操场关了，所以很不情愿地去了体育馆hh，5.31km,用时14：14，配速4：33，差不多时配速递增这样子，步频168步幅130，心率178，最大心率187，步频没提起来步幅还下降了，不过是有氧跑，管他呢？</p><div class="fj-gallery"><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/IMG_9993.PNG" alt="IMG_9993"><br><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/IMG_9985.PNG" alt="IMG_9985"></p>          </div></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 运动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中长跑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web端服务器部署基本步骤</title>
      <link href="/2022/03/07/screen/"/>
      <url>/2022/03/07/screen/</url>
      
        <content type="html"><![CDATA[<h1>服务器部署常用指令</h1><p>常常面临前后端（特别是后端）部署到服务器的需求，每次部署的时候都到处搜指令，效率十分低下，所以就在这个博客里面慢慢记录一些常用的指令吧。</p><p>参考：</p><p><a href="https://www.runoob.com/linux/linux-comm-screen.html">Linux screen命令 | 菜鸟教程 (runoob.com)</a></p><h2 id="后端（Spring-cloud）ubuntu服务器部署">后端（Spring cloud）ubuntu服务器部署</h2><p>首先在本地build相应的<code>jar</code>文件，然后在服务器的<code>\root</code>目录新建一个文件夹（用于放置你项目的所有文件）然后放入build的<code>jar</code>包。</p><h3 id="新建screen会话">新建screen会话</h3><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720220307185958.png" alt=""></p><p>使用</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctrl+a d键</span><br></pre></td></tr></table></figure><p>退出当前会话</p><p>运行每一个jar包在独立的screen，就完成部署了</p><h3 id="删除会话">删除会话</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">screen -X -S $tr_name quit</span><br></pre></td></tr></table></figure><h2 id="前端部署">前端部署</h2><p>本地运行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>然后会生成一个<code>dist</code>文件</p><p>放进服务器相应的文件里面</p><p>然后开启nginx服务，具体安装和配置方法参考网站。</p><p>大概是首先修改confi文件，然后干嘛…反正不难</p><p>更新中…</p>]]></content>
      
      
      <categories>
          
          <category> 技术博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html/css/js三件套复习--grid布局</title>
      <link href="/2022/03/05/grid/"/>
      <url>/2022/03/05/grid/</url>
      
        <content type="html"><![CDATA[<h1>CSS Grid 网格布局教程</h1><p>还有一个月就开始蓝桥杯了。为了血洗”如何看待蓝桥杯只拿三等奖“之耻，是时候复习下三件套啦！</p><blockquote><p>教程来源：CSS grid网格布局教程 --阮一峰的博客</p></blockquote><p>另外推荐一个学习grid布局的网站：scrima，这个网站本来是首收费（$108）但是唯独grid布局是免费的！</p><p><a href="https://scrimba.com/learn/cssgrid/intro-to-the-css-grid-course-cg9PpTb">Intro to the CSS Grid course - Scrimba.com</a></p><p>体验了一下，这个网站做的很牛逼，直接把可编辑的代码和视频教学结合在了一起，值得一试！</p><h2 id="1-Grid-与-Flex-的区别">1 Grid 与 Flex 的区别</h2><p>Flex 布局是轴线布局，只能指定&quot;项目&quot;针对轴线的位置，可以看作是<strong>一维布局</strong>。Grid 布局则是将容器划分成&quot;行&quot;和&quot;列&quot;，产生单元格，然后指定&quot;项目所在&quot;的单元格，可以看作是<strong>二维布局</strong>。Grid 布局远比 Flex 布局强大。</p><h2 id="2-基本概念">2 基本概念</h2><h3 id="2-1-容器和项目">2.1 容器和项目</h3><p>采用网格布局的区域，称为&quot;容器&quot;（container）。容器内部采用网格定位的子元素，称为&quot;项目&quot;（item）</p><p>项目只能是容器的顶层子元素，不包含项目的子元素，Grid 布局只对项目生效。</p><h3 id="2-2-行和列">2.2 行和列</h3><p><img src="https://www.wangbase.com/blogimg/asset/201903/1_bg2019032502.png" alt="img"></p><p>容器里面的水平区域称为&quot;行&quot;（row），垂直区域称为&quot;列&quot;（column）。</p><h3 id="2-3-单元格和网格线">2.3 单元格和网格线</h3><p>行和列的交叉区域，称为&quot;<strong>单元格</strong>&quot;（cell）。划分网格的线，称为&quot;<strong>网格线</strong>&quot;（grid line）。水平网格线划分出行，垂直网格线划分出列。</p><h2 id="3-容器属性">3 容器属性</h2><h3 id="3-1-display属性">3.1 display属性</h3><p><code>display: grid</code>指定一个容器采用网格布局。</p><p>默认情况下，容器元素都是块级元素，但也可以设成行内元素。</p><ul><li><p>容器是块级元素</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032504.png" alt="img"></p></li><li><p>容器是行内元素</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032505.png" alt="img"></p></li></ul><p>​</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，设为网格布局以后，容器子元素（项目）的<code>float</code>、<code>display: inline-block</code>、<code>display: table-cell</code>、<code>vertical-align</code>和<code>column-*</code>等设置都将失效。</p><h3 id="3-2-grid-template-columns-属性，-grid-template-rows-属性">3.2 grid-template-columns 属性， grid-template-rows 属性</h3><p>容器指定了网格布局以后，接着就要划分行和列。<code>grid-template-columns</code>属性定义每一列的列宽，<code>grid-template-rows</code>属性定义每一行的行高。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  grid-template-rows: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了使用绝对单位，也可以使用百分比。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">33.33%</span> <span class="number">33.33%</span> <span class="number">33.33%</span>;</span><br><span class="line">  grid-template-rows: <span class="number">33.33%</span> <span class="number">33.33%</span> <span class="number">33.33%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用<code>repeat()</code>函数简化写法：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">33.33%</span>);</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">2</span>, <span class="number">100px</span> <span class="number">20px</span> <span class="number">80px</span>);</span><br></pre></td></tr></table></figure><h4 id="auto-fill-关键字">auto-fill 关键字</h4><p>有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用<code>auto-fill</code>关键字表示自动填充。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(auto-fill, <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="grid中auto-fit和auto-fill的区别"><strong>grid中auto-fit和auto-fill的区别</strong></h4><pre><code>auto-fill:在轨道重复过程中，尽可能多的根据元素创建轨道，如果创建的轨道数量是小数比如6.5，那么0.5就被称为剩余空间，剩余的空间不够一个轨道了，就相当于每个轨道1fr进行分配这个0.5的剩余空间，没有元素填充的空轨道不会折叠依然保留（相当于留了空白）。auto-fit:在轨道重复过程中，尽可能多的根据元素创建轨道，并均分不到一个轨道的剩余空间。轨道分配完以后如果轨道中没有元素则将所有没有元素填充的空轨道折叠为0，即把没有元素填充的空轨道全被分配给有元素的轨道（相当于有元素填充的轨道全部为1fr）。最后没有空轨道剩余</code></pre><p><strong>scrima中给出的直观解释：</strong></p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305215542906.png" alt="image-20220305215542906"></p><h4 id="auto-fit关键字">auto-fit关键字</h4><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305210303497.png" alt="image-20220305210303497"></p><p>这个写法真的很棒！！！</p><p><a href="https://scrimba.com/learn/cssgrid/auto-fit-and-minmax-css-grid-tutorial-cg92LA6">Auto-fit and minmax - CSS Grid tutorial - Scrimba.com</a></p><p><code>minmax</code>的加入使得每个块可以根据屏幕大小变化宽度适应整个画面</p><h4 id="fr关键字">fr关键字</h4><p>为了方便表示比例关系，网格布局提供了<code>fr</code>关键字（fraction 的缩写，意为&quot;片段&quot;）。如果两列的宽度分别为<code>1fr</code>和<code>2fr</code>，就表示后者是前者的两倍。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">150px</span> <span class="number">1</span>fr <span class="number">2</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="minmax">minmax()</h4><p><code>minmax()</code>函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="built_in">minmax</span>(<span class="number">100px</span>, <span class="number">1</span>fr);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>minmax(100px, 1fr)</code>表示列宽不小于<code>100px</code>，不大于<code>1fr</code>。</p><h4 id="auto关键字">auto关键字</h4><p><code>auto</code>关键字表示由浏览器自己决定长度。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> auto <span class="number">100px</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了<code>min-width</code>，且这个值大于最大宽度。</p><h4 id="grid-template">grid-template</h4><p>是<code>grid-template-columns</code>和<code>grid-template-rows</code>的合体，比如下面的写法：</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305160832455.png" alt="image-20220305160832455"></p><p>可以想象使用”L“绘制网页：先规定rows也就是纵向，后规定columns也就是横向。</p><h4 id="网格线的名称">网格线的名称</h4><p><code>grid-template-columns</code>属性和<code>grid-template-rows</code>属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: [c1] <span class="number">100px</span> [c2] <span class="number">100px</span> [c3] auto [c4];</span><br><span class="line">  grid-template-rows: [r1] <span class="number">100px</span> [r2] <span class="number">100px</span> [r3] auto [r4];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。</p><p>网格布局允许同一根线有多个名字，比如<code>[fifth-line row-5]</code>。</p><h4 id="布局实例">布局实例</h4><p><code>grid-template-columns</code>属性对于网页布局非常有用。两栏式布局只需要一行代码。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">70%</span> <span class="number">30%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码将左边栏设为70%，右边栏设为30%。</p><p>传统的十二网格布局，写起来也很容易。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">12</span>, <span class="number">1</span>fr);</span><br></pre></td></tr></table></figure><h3 id="3-3-grid-row-gap属性-grid-colum-gap属性，grid-gap属性">3.3 grid-row-gap属性 grid-colum-gap属性，grid gap属性</h3><p><code>row-gap</code>属性设置行与行的间隔（行间距），<code>column-gap</code>属性设置列与列的间隔（列间距）。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    row-gap: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">column-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gap</code>属性为两个属性的合并简写形式：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  grid-gap: <span class="number">20px</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-grid-template-areas属性">3.4 grid-template-areas属性</h3><p>网格布局允许指定&quot;区域&quot;（area），一个区域由单个或多个单元格组成。<code>grid-template-areas</code>属性用于定义区域。</p><p>下面是一个布局实例。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-areas: <span class="string">&quot;header header header&quot;</span></span><br><span class="line">                     <span class="string">&quot;main main sidebar&quot;</span></span><br><span class="line">                     <span class="string">&quot;footer footer footer&quot;</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，顶部是页眉区域<code>header</code>，底部是页脚区域<code>footer</code>，中间部分则为<code>main</code>和<code>sidebar</code>。</p><p>如果某些区域不需要利用，则使用&quot;点&quot;（<code>.</code>）表示。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-areas: <span class="string">&#x27;a . c&#x27;</span></span><br><span class="line">                     <span class="string">&#x27;d . f&#x27;</span></span><br><span class="line">                     <span class="string">&#x27;g . i&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。</p><p>注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为<code>区域名-start</code>，终止网格线自动命名为<code>区域名-end</code>。</p><p>比如，区域名为<code>header</code>，则起始位置的水平网格线和垂直网格线叫做<code>header-start</code>，终止位置的水平网格线和垂直网格线叫做<code>header-end</code>。</p><h3 id="3-5-grid-auto-flow属性">3.5 grid-auto-flow属性</h3><p>grid-auto-flow决定了容器的子元素放入的顺序，默认为”先行后列“。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-<span class="attribute">auto</span>-flow: column;</span><br></pre></td></tr></table></figure><p>这样就变成先列后行</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032513.png" alt="img"></p><p>如上所示的效果</p><p>使用了如下的css:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#container</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  grid-template-rows: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  grid-<span class="attribute">auto</span>-flow: row;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ef342a</span>;</span><br><span class="line">  grid-column-start: <span class="number">1</span>;</span><br><span class="line">  grid-column-end: <span class="number">3</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item-2</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f68f26</span>;</span><br><span class="line">  grid-column-start: <span class="number">1</span>;</span><br><span class="line">  grid-column-end: <span class="number">3</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>grid-column-start</code>和<code>grid-column-end</code>让1和2 占据了两个单元格</p><p>现在修改设置，设为<code>row dense</code>，表示&quot;先行后列&quot;，并且尽可能紧密填满，尽量不出现空格。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-<span class="attribute">auto</span>-flow: row dense;</span><br></pre></td></tr></table></figure><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032514.png" alt="img"></p><p>上图会先填满第一行，再填满第二行，所以3号项目就会紧跟在1号项目的后面。8号项目和9号项目就会排到第四行。</p><h4 id="使用dense实现照片墙的例子">使用dense实现照片墙的例子</h4><p><a href="https://scrimba.com/learn/cssgrid/an-awesome-image-grid-css-grid-tutorial-cBq3PsP">An awesome image grid - CSS Grid tutorial - Scrimba.com</a></p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305213136445.png" alt="image-20220305213136445"></p><h3 id="3-6-justify-items，align-items-place-items属性">3.6 justify-items，align-items,place-items属性</h3><p><code>justify-items</code>属性设置单元格内容的水平位置（左中右），<code>align-items</code>属性设置单元格内容的垂直位置（上中下）。</p><p>这两个属性的写法完全相同，都可以取下面这些值。</p><ul><li>start：对齐单元格的起始边缘。</li><li>end：对齐单元格的结束边缘。</li><li>center：单元格内部居中。</li><li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  justify-items: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032516.png" alt="img"></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示，单元格的内容头部对齐，效果如下图。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032517.png" alt="img"></p><p><code>place-items</code>属性是<code>align-items</code>属性和<code>justify-items</code>属性的合并简写形式。如：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-items: start end;</span><br></pre></td></tr></table></figure><h3 id="3-7-justify-content-align-content-place-content属性">3.7 justify-content,align content,place-content属性</h3><p>先上一个有趣的教程示例：</p><p><a href="https://scrimba.com/learn/cssgrid/justify-content-and-align-content-css-grid-tutorial-cGpB8t7">justify-content and align-content - CSS Grid tutorial - Scrimba.com</a></p><p><code>justify-content</code>属性是整个内容区域在容器里面的水平位置（左中右），<code>align-content</code>属性是整个内容区域的垂直位置（上中下）。</p><p>这两个属性的写法完全相同，都可以取下面这些值。（下面的图都以<code>justify-content</code>属性为例，<code>align-content</code>属性的图完全一样，只是将水平方向改成垂直方向。）</p><blockquote><ul><li>start - 对齐容器的起始边框。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032519.png" alt="img"></p><blockquote><ul><li>end - 对齐容器的结束边框。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032518.png" alt="img"></p><blockquote><ul><li>center - 容器内部居中。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032520.png" alt="img"></p><blockquote><ul><li>stretch - 项目大小没有指定时，拉伸占据整个网格容器。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032521.png" alt="img"></p><blockquote><ul><li>space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032522.png" alt="img"></p><blockquote><ul><li>space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032523.png" alt="img"></p><blockquote><ul><li>space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032524.png" alt="img"></p><p><code>place-content</code>属性是<code>align-content</code>属性和<code>justify-content</code>属性的合并简写形式。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-<span class="attribute">content</span>: &lt;align-content&gt; &lt;justify-content&gt;</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-<span class="attribute">content</span>: space-around space-evenly;</span><br></pre></td></tr></table></figure><h3 id="3-8-grid-auto-columns，grid-auto-rows属性">3.8 grid-auto-columns，grid-auto-rows属性</h3><p>有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。</p><p><code>grid-auto-columns</code>属性和<code>grid-auto-rows</code>属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与<code>grid-template-columns</code>和<code>grid-template-rows</code>完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p><p>例子：</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305211409763.png" alt="image-20220305211409763"></p><h2 id="4-项目属性">4 项目属性</h2><p>下面这些属性定义在项目上面。</p><h3 id="4-1-grid-row-start，grid-row-end属性">4.1 grid-row-start，grid-row-end属性</h3><p>项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。</p><ul><li><code>grid-column-start</code>属性：左边框所在的垂直网格线</li><li><code>grid-column-end</code>属性：右边框所在的垂直网格线</li><li><code>grid-row-start</code>属性：上边框所在的水平网格线</li><li><code>grid-row-end</code>属性：下边框所在的水平网格线</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  grid-column-start: <span class="number">2</span>;</span><br><span class="line">  grid-column-end: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032526.png" alt="img"></p><p>比如上面的指定了左右边框所在的网格线。</p><p>除了1号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的<code>grid-auto-flow</code>属性决定，这个属性的默认值是<code>row</code>，因此会&quot;先行后列&quot;进行排列。读者可以把这个属性的值分别改成<code>column</code>、<code>row dense</code>和<code>column dense</code>，看看其他项目的位置发生了怎样的变化。</p><p><a href="https://jsbin.com/yukobuf/edit?css,output">JS Bin - Collaborative JavaScript Debugging</a></p><p>可点击如上的网址进行理解和练习。</p><p>这四个属性的值还可以使用<code>span</code>关键字，表示&quot;跨越&quot;，即左右边框（上下边框）之间跨越多少个网格。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  grid-column-start: span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这四个属性，如果产生了项目的重叠，则使用<code>z-index</code>属性指定项目的重叠顺序。</p><h3 id="4-2-grid-column属性，grid-row属性">4.2 grid-column属性，grid-row属性</h3><p><code>grid-column</code>属性是<code>grid-column-start</code>和<code>grid-column-end</code>的合并简写形式，<code>grid-row</code>属性是<code>grid-row-start</code>属性和<code>grid-row-end</code>的合并简写形式。</p><h3 id="4-3-grid-area属性">4.3 grid-area属性</h3><p><code>rid-area</code>属性还可用作<code>grid-row-start</code>、<code>grid-column-start</code>、<code>grid-row-end</code>、<code>grid-column-end</code>的合并简写形式，直接指定项目的位置。</p><blockquote><p>.item {<br>grid-area: <row-start> / <column-start> / <row-end> / <column-end>;<br>}</p></blockquote><p>下面是一个<a href="https://jsbin.com/duyafez/edit?css,output">例子</a>。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  grid-area: <span class="number">1</span> / <span class="number">1</span> / <span class="number">3</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，scimba网站还给出了grid-area的另一种用法：</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305203819913.png" alt="image-20220305203819913"></p><p><strong>另外一个有趣的用法</strong></p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305213953945.png" alt="image-20220305213953945"></p><h3 id="4-4-justify-self，align-self-place-self属性">4.4 justify-self，align-self,place-self属性</h3><p><code>justify-self</code>属性设置单元格内容的水平位置（左中右），跟<code>justify-items</code>属性的用法完全一致，但只作用于单个项目。</p><p><code>align-self</code>属性设置单元格内容的垂直位置（上中下），跟<code>align-items</code>属性的用法完全一致，也是只作用于单个项目。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  justify-self: start | end | center | stretch;</span><br><span class="line">  <span class="attribute">align-self</span>: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个属性都可以取下面四个值。</p><ul><li>start：对齐单元格的起始边缘。</li><li>end：对齐单元格的结束边缘。</li><li>center：单元格内部居中。</li><li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li></ul><p>下面是<code>justify-self: start</code>的例子。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span>  &#123;</span><br><span class="line">  justify-self: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032532.png" alt="img"></p><p><code>place-self</code>属性是<code>align-self</code>属性和<code>justify-self</code>属性的合并简写形式。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-self: &lt;align-self&gt; &lt;justify-self&gt;;</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-self: center center;</span><br></pre></td></tr></table></figure><p>如果省略第二个值，<code>place-self</code>属性会认为这两个值相等。</p><h2 id="5-scrima上面的示例">5 scrima上面的示例</h2><p><a href="https://scrimba.com/learn/cssgrid/positioning-items-css-grid-tutorial-cbVn4t4">Positioning items - CSS Grid tutorial - Scrimba.com</a></p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305161906343.png" alt="image-20220305161906343"></p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305162045130.png" alt="image-20220305162045130"></p><h2 id="6-flex-和-grid配合使用">6 flex 和 grid配合使用</h2><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305220701719.png" alt="image-20220305220701719"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个梦---谈谈保留这首歌</title>
      <link href="/2022/03/02/emo202232/"/>
      <url>/2022/03/02/emo202232/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-TUIFtbNp" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="442869203" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#FF4081"    ></div><p>2022年3月2日23：59分。</p><p>刚才在寝室洗衣服时，耳机里放着网易云”我喜欢“的歌单，随机播放。因为我的歌单里有很多首歌，快1000首了，大抵都是听一遍觉得不错便扔进了歌单里，所以每次随机播放时，都能稍稍体会到好奇下一首是哪首歌的快感</p><p>突然脑海里播放了这首歌。<br>郭顶的《保留》。这首歌没有前奏，不给人任何心理准备，一来就是“看见，你在我眼前。”<br>听后遍有一种心里很沉重很难受的感觉。是的，因为这首歌以它的方式提醒我：我三年来一直秉持的信仰和坚持（虽然中途放弃过），破碎了。<br>我本以为我快要走出来了，可是一听到这首歌，立马发现自己还在原地踏步，并且还时不时地回头看。<br>三年前，我和她走在大学路的街道上，突然听见远方唱歌的声音。一位弹着吉他的流浪歌手，唱着《保留》，声音低沉悠扬。我们当时不知道这首歌，但都被歌词和旋律深深吸引。一首歌，几句歌词，让两个人的世界第一次相交，碰撞，重叠，燃烧。<br>这首歌一听就是三年，两个人。在四平路，在嘉定。在呼伦贝尔，在成都的夜晚。在中国。在法国。<br>最终歌曲放完了。对我而言很像是一场梦，有时候会觉得是噩梦想要抽离，可真的快抽离时却发现自己十分迷恋，想一直做下去。<br>正当自己认为这场梦可以一直做，做到毕业，做到工作，做到自己有自己的一片乐土时，它碎了。<br>可能自己心里真的未放下吧，所以写的十分的抽象。或许有一天自己真正放下向前看的时候，这个梦会变得越来越清晰，清晰到我能够真正真切地去面对，能真正的觉得它是一段美好的回忆。</p><p>好了，抽象emo结束。有一说一，这首歌我还是很喜欢的。郭顶是我很喜欢的歌手，而这首歌也是他的歌里面我最喜欢的。下面是他的完整歌词，因为个人经历会觉得歌词承载的太多，不敢去过度理解，不过不影响这真的是一首好作品。</p><p>不emo了，明早还有游泳课，有的爽了。</p><p>看见 你在我眼前</p><p>不去猜想我们隔多远</p><p>当我 夜幕中准备</p><p>只想让沉默的能开解</p><p>在不同的遭遇里我发现你的瞬间</p><p>有种不可言说的温柔直觉</p><p>在有限的深夜消失之前触摸你的脸</p><p>我情愿这是幻觉 也不愿是种告别</p><p>已经忘了 你的名字</p><p>就在这座 寂静星石</p><p>怎么还有 你的样子</p><p>被保留</p><p>给我 一整个拥抱</p><p>好让我不至于 太潦倒</p><p>时间 过一分一秒</p><p>还是觉得相遇 太美好</p><p>在不同的遭遇里我发现你的瞬间</p><p>有种不可言说的温柔直觉</p><p>当不远的蓝色渐渐显现这无边境界</p><p>我始终等待再见 只不愿再也不见</p><p>已经忘了 你的名字</p><p>就在这座 寂静星石</p><p>怎么还有 你的样子</p><p>想形容你的句子 关于你所有心事</p><p>一眼能及的钻石 哪一个是你地址</p><p>忘了 你的名字</p><p>就在这座 寂静星石</p><p>怎么还有 你的样子</p><p>我始终等待再见 只不愿再也不见</p><p>真的忘了 你的名字</p><p>是在哪座 寂静星石</p><p>一直还有 你的样子</p><p>被保留</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> emo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>被讨厌的勇气--读书心得</title>
      <link href="/2022/03/02/book1/"/>
      <url>/2022/03/02/book1/</url>
      
        <content type="html"><![CDATA[<p>最近受某位同学的推荐阅读了这本书，通篇大部分为一个年轻人和哲人的对话，初读感觉里面讲的人生哲学非常的唯心主义，他否定了过去经历和所处环境对人性格形成的影响，而将我们后来对自己”人设“的认知和性格的形成归结为我们自己的选择。说实话，这种观点目前我是无法苟同的，不过现在还没读完这本书，等读完了在这里记录一下看法和感受吧！</p><p>虽然不会承认，但我敢保证每个人都有过这样一个心理。“某个非常要好的朋友获得了比我更加厉害的成功，但是心里总是无法真心祝福过的幸福的他人”。说真的，我自己常常为这样的心理困惑，为什么自己总是不能真正地由内而外地为我好兄弟的成功感到由衷的祝福呢？可能自己潜意识把他当成了自己的竞争者，自己如果没有他成功，就代表自己失败了，所以别人成功的时候自己常常会有挫败感吧。不过本书最让我感到震惊的价值观还是哲人所说的目的论。</p><p>在看这本书之前，我是十分信奉原因论的。包括我骨子里的性格，都与我小时候的经历有关。我很相信原生家庭对一个人带来的不可忽视的影响。但书中的哲人用目的论解释了这一切。书里说，我们赋予过去的经历什么样的价值，比我们经历什么更为重要。经历是过去的客观存在，但无法真正决定我们未来的生活方式，也即性格。赋予过去的事情什么样的价值才是现在的我们面临的课题。</p><p>有句有关“爱的课题”的话我觉得说的很好。“当人能够感觉到‘与这个人在一起可以无拘无束的‘时候，才能够体会到爱。既没有自卑感也不必炫耀优越性，能够保持一种平静而自然的状态。真正的爱是这样的。”这让我会想起上一段没有结果的感情。现在想来，彼此好像都束缚的太多，我因为她，很多时候想和兄弟出去玩而不得。自己会尽自己最大的努力抽出时间陪她。扪心自问，自己是真的因为爱她而发自内心的想和她呆在一起而不是怕她生气吗？是的，我怕她生气。很多时候她陪我也是怕我会不高兴吧。两个人在一起的原因竟然成了一种负担，一种对对方不高兴的恐惧，这样相处真的很累。最近看的那部漫画，也是说一对情侣，男生和女生就快要结婚了，但是女生不想生孩子但男生想。男生知道女生不想生孩子的想法后很伤心，但是因为爱她，只好妥协。但是男生很不喜欢女生演戏，一方面是绝对这个职业太忙太累，另一方面是因为女生演戏会和其他男生交流，自己会吃醋。但演戏确实女生的梦想，自己的追求。男生很希望自己的未婚妻能为自己妥协，但是女生不答应。最后男生思考了很久，最后和女生分手了。可能认为这段感情就像是把彼此囚禁在了彼此设置的牢笼里吧，维护爱情付出的代价是不断妥协，甚至是妥协自己最珍惜的东西，那这段感情是否还需要继续下去呢？会想起自己过去的那段感情，无法无拘无束，总是担心自己会因为某些事情失去，患得患失。根本不是一种平静而自然的状态，或许分开是更好的选择吧。况且，她总说她在我面前很自卑，怕自己因为变胖我不喜欢她，怕自己不运动我会不喜欢她。过去她是喜欢运动的，但是现在我却赋予了运动沉重的意义，这样的压力压的她喘不过气。或许在外人看来这些话看起来很可笑，但就是这样的状态。这段感情的维护本身就需要彼此不断妥协，而不是一种自然而平静的状态，所以分开对彼此是最好的选择。</p>]]></content>
      
      
      <categories>
          
          <category> 读书心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说跑步这件事</title>
      <link href="/2022/03/01/running/"/>
      <url>/2022/03/01/running/</url>
      
        <content type="html"><![CDATA[<h2 id="说说为啥喜欢长跑">说说为啥喜欢长跑</h2><p>长跑这项运动算是高中的时候就喜欢上了吧。其实初中的时候挺讨厌长跑的，因为不及格，老师让我跳蛙跳。不服气呗，所以后来1000米就死命跑，心里想的就是拼了命也要超过别人。最后中考马马虎虎，刚好过线。</p><p>​高中的时候流行夜跑嘛，晚上下了课喜欢几个人约着一起到操场夜跑+散步。后来高三压力大了，我因为个人原因整个高三就蛮抑郁的，突然想起来初中跑1000米那种拼劲，和考试相比，这可能是唯一一个付出100%努力，就能跑的比别人快的事情了。同时跑步的时候可以什么都不想，当作白天学习后释放压力放空自己的活动很合适（并且我很喜欢那种跑步超过别人的感觉？）于是那时就开始每天夜跑，不多不少5公里。</p><p>​再后来到了高三上期中的时候，开始想在这方面出一点成绩，于是就拿起个小本本开始做计划（那个小本子其实是我的日记本，现在还在我宿舍的书架上）开始设定目标，设定每个阶段应该达成的进步（记得当时的目标是参加1500米校运会，跑到5：15秒以内，也就是每1000米3：30以内完成），然后还专门留了一页纸，画了一个坐标系，横轴是时间，纵轴是1500米所用分钟数，然后画了一个基准线就是5：15的时间，基准线还画在中间的位置，因为觉得自己可以练到更快。哈哈哈，当时设想的美好画面当然是一条单调递减的曲线，晚自习的时候瞎画在那里咯咯咯的笑。同桌看了笑出声：”别人写学习计划，你tmd写跑步计划，宁这是高三？“不过yysy，我高三就是压力太大了，其实超努力的qaq.</p><p>​理想很丰满，现实很艹蛋。我现在还记得那时第一次训练，1500米跑了6：18.整整比目标慢了一分钟。起点低没事，咱慢慢练嘛。结果呢，那个坐标系里压根就是条正弦曲线，一会跑到5：50，以后又回到6：20去了，就尼玛离谱，每次跑的时候还贼累。</p><p>​现在看来当时那根本就不叫训练，完全就是瞎练，不知道啥是间歇跑，不知道啥是力量训练。不过也算是死磕了吧（日记本好像忘家里了hehe，不过记得很清楚当时至少标注了三十个点），虽然没有一次到达过目标。</p><p>​然后就去报校运会了。笑死，本来1500米就是一个大家不愿意报的运动项目，又正值高三，大家都觉得主动报的要么是行为艺术要么就是想逃习题课。一般如果没人报的话就得抓壮丁了。我记得当时举手之后，大家像看救世主一样看我。这个班级又少了一次磨难。</p><p>​说句实话，当时心里很期待那种自己在赛场上拼（zhuang）搏(bi)，台下同学加油呐喊的感觉，懂得都懂，不懂的都不懂。不过很可惜，高三学业繁重，没有运动项目的同学就在教室自习不去操场了。当时心里还是挺失落的。（怎么说呢，可能是骨子里自卑，喜欢通过这件事获得别人的认可，我承认哈哈哈）不过班主任很人道主义，规定每个项目必须有至少两名同学陪同加油助威。带着这份感恩，我就穿上丝袜去操场参赛了。</p><p>​具体比赛细节就不说了哈，其实当时还有很多同学偷偷跑下来给我加油了，当时真的很热血，或许他们是我这份爱好养成的突出贡献者哈哈哈，最后5：18，第三名（高三大家的身体素质是真的普遍退步了）虽然没达到自己定的目标，不过真的很满意了。</p><p>​这件很不起眼的小事，为啥要这么罗嗦呢？说真的它真的算是我高三抑郁生活的一大精神支柱了。很多时候心态快崩的时候都靠跑步顶住了。</p><p>​大学算是轻松了，也就开始随便跑跑，偶尔参加参加学校的校园活动，偶尔看看训练技巧，大一校运会1500米马马虎虎5：03，第九名（刚好没奖状，哈哈），摸爬滚打到了现在。</p><p>所以说现在到底为啥喜欢长跑呢？<br><strong>喜欢到每次跑步必须把仪式感拉满，必须穿背心、短裤、紧身长袖长袜<br>喜欢到上学期直接跑到腿瘸（被xian哥多次警告别再练了hhh）<br>喜欢到像现在这样作为自己值得骄傲的一件事<br>它带给我的挺简单的，我在跑步的时候感受到自己尚存的自律和拼劲<br>找回自己其实并不经常存在的自信的状态<br>跑步的时候真的可以什么都不想 或者想明白一些平时想不明白的事情<br>唯一一点不喜欢的是<br>和健身增肌是冲突的！！！跑完能感觉到自己刚练的肌肉又掉了…</strong></p><h2 id="知乎的一篇回答">知乎的一篇回答</h2><p>​上学期（大三上）又是喜欢长跑到近乎狂热的一学期。为啥呢？因为我长胖了！！！长胖了！！！长胖了！！！能想象？一个千年玉米杆子因为一学期+一个暑假没咋运动直接有小肚子，135斤。想想以前经常长跑，还参加校运会，都快不认识这么肥宅的自己了。</p><p>​于是又是以增肌减脂为起因（这个时候也办了1年健身再健身的健身卡）开始慢慢恢复。刚开始跑步的时候那叫一个酸爽，跟双腿安了假肢一样，第一次跑了2公里，配速直接飞到6：30，那绝望是真的绝望。然后就继续死磕吧，每次都几乎用到90%的力气，死磕5公里，慢慢配速降到了4：30，算是可以接受的地步。</p><p>​也是在这个时候开始在知乎小破站学习训练速耐的技巧（暂时不敢接触半马这种长距离，怕腿受伤w），练习间歇跑。给自己定下的flag很简单：1000米体测3：10内。最后跑了3：06，说实话，真的超有成就感。在经历了长胖危机后，刷新了1000米速耐pb.</p><p>​之后带着这种自负和狂妄在知乎上发了篇回答：</p><p><a href="https://www.zhihu.com/question/325715679/answer/2088568177">(44 封私信 / 80 条消息) 大学生体测1000米满分（3分16秒）有多难? - 知乎 (zhihu.com)</a><br>上原回答：<br>2021.11.7号更新</p><p>今天下午去体测啦 听说上海今天要降温十多度 立马赶着降温前去测试了 当时下着小雨。</p><p>然后结果出来了<br><img src="https://pic1.zhimg.com/80/v2-ec606df9aec7585674236616f4e807e5_720w.jpg?source=1940ef5c" alt="img"></p><p>3:06 比上次的PB快了十秒…</p><p>算是了却了自己的心愿吧！！！</p><p>2021.11.3更新</p><p>间歇跑真香！！！</p><p>开学以来陆陆续续跑了两个月了。跑量大概150km左右，每月80。</p><p>最开始还是死磕五公里，配速不上不下，4:30左右，然后真就感觉越跑越累。</p><p>然后在知乎上问了各路大神后，听取了“练1000不要尝试接触3:30-5:00的配速的建议。</p><p>开始每周2-3次400米间歇。大概是400米间歇1:20跑完，中间休息2min，连续5组。最开始跑真的很吃力，第三组的时候已经没力气了，跑完也很难受…不过不得不说间歇跑对提高1000米速耐真的很有帮助。</p><p>陆陆续续练了有十次吧。现在基本一组400可以1:14内跑完，五组下来不是特别累。其他时间就是5km5分配慢跑，练练有氧顺便减脂。</p><p>然后有一天发现，4:55跑完五公里后，试了试冲刺一下800。结果看时间， 800用了2:35。最后6公里配速4:40，这可比以前累死累活4:30舒服多了。</p><p>所以这里给大家的建议是平时可以慢跑间歇交替进行。慢跑的话25min跑个5公里就好啦，间歇的话400跑不下来就从200开始，这样正好跑200走200，非常方便。相信我，间歇对于1000的进步太大了。</p><p>现在跑1000和以前的跑姿也有了变化。以前都是一个劲冲，姿势从头到尾都是变形的。现在3:00配冲哥800身体基本比较稳，跑姿不会有什么变化，核心力量也提升了。</p><p>马上就要体测啦，希望大家都可以跑到自己满意的成绩！！！</p><p>我也希望今年能进一次3:05….加油！</p><p>————————————————分割线———————————</p><p>先放个图吧。去年（2020）十一月大二体测跑的。</p><p>当时拿着手机用keep记录了一下。刚好满分。（老师测的3:16，keep有些许延迟）</p><p><img src="https://pic3.zhimg.com/80/v2-1e82d5845156be6e836d49bad727fe4f_720w.jpg?source=1940ef5c" alt="img"><br>再随便截一张平时跑步的图<br><img src="https://pic2.zhimg.com/80/v2-0968fb4d245b33ac75818b5c9c077618_720w.jpg?source=1940ef5c" alt="img"></p><p>大学生1000米满分对于正常人来说的确有点难。</p><p>我在初中的时候因为1000米不及格被老师叫着去操场跳蛙跳，间歇跑，练着练着成绩就上来了。记得初中体考的时候3:33（当时满分是3:48）</p><p>高中的时候因为压力大就把参加运动会1500米项目作为自己的目标之一，下了晚自习就跑，每天晚上五公里左右，速度不算快，4:30-5:00配速的样子，当作发泄吧。</p><p>然后我记得高三那次校运会1500米5:15秒，居然还拿了个第三 （可见高中大家的身体素质都比较一般）</p><p>到了大学的跑步频率明显减少了，加了个跑协混混，偶尔参加个校园跑，偶尔跑个五公里，大一校运会1500米前一个月突击训练了一下，然后跑了5:03，第九名 （第一名我记得是4:30好像）大学高手还是很多的。那个时候我记得体育体测1000米好像3:10秒的样子，跑满分还算轻松。</p><p>后来到了大二，因为各种原因运动减少了，很少跑步，然后就有了图一的成绩，3:16，非常吃力，跑完半条命没了。</p><p>然后到了这学期 ，基本一学期没运动过，体重直接重5kg，耐力明显下降了。（最近有开始恢复训练，但跑5公里五分配速都很吃力。）</p><p>可见，要想大学1000米拿满分并且保持这个成绩的话。除了体重要控制的较好以外，一定频率的训练还是必不可少的。我的建议是至少一周2-3次五公里跑或者间歇跑，用自己60-70%的力气，5公里的话一开始配速5:30就行，然后慢慢减。如果练到5公里21:00以内跑完的话，其实1000米跑满分也不算难了。跑进20:00的话，可以尝试一下1500校运会，说不定能拿名次。</p><h2 id="这学期的训练计划">这学期的训练计划</h2><p>截至2022年3月8号，开学的跑量大概也有40km的样子了，用了两周的时间完成了别人一次就能跑完的全马…每次2km-5km不等，配速大概在4：00-4：20不等<br><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/IMG_9868.PNG" alt="IMG_9868"><br>keep上大概记录了25km左右，还有一些在iwatch和搞笑体育上。下面说说近一个月的训练安排吧！！</p><p><strong>每周跑步的频率在3-5次，不宜太多，给自己充分的休息时间(充分的精力撸铁，由于增肌和有氧训练冲突，思考了很久还是决定以增肌为主了)。然后每周安排1-2次的间歇跑，其他时候为有氧跑，下面具体说说这两种吧！</strong></p><h3 id="间歇跑">间歇跑</h3><p>很肝也很爽的训练，不过得等到人稍微少的时候-_-<br>热身跑1圈，配速6：00-6：30左右，身子一定要跑热<br>然后开始400m间歇，每次完成的时间很重要<br>这学期我给自己的目标是1000m跑到3：00（感觉会很难qaq）<br>所以换算下来，400m要在1：12内完成。（等等，真的能做到？）<br>由于这个要求有点太高，那就给自己的休息时间长一点，休息2分钟左右<br>然后继续<br>这样持续下来，最好能跑完5组，也就是2km。<br>最开始可以从圈速1：14开始，慢慢减。（感觉每减1秒都会很难)<br>跑完后再慢跑一圈<br>然后拉伸</p><h3 id="有氧跑">有氧跑</h3><p>这个就很轻松了，就是越轻松越好，热身后跑5-10km吧<br>配速5：00左右就行，5：30也可，调整调整自己的心肺节奏</p><p>另外这学期还是不打算接触半马全马这种超长距离了，一跑感觉自己增肌的努力就白费了<br>加油！！！<br>另外暑期实习面试加油！！！</p>]]></content>
      
      
      <categories>
          
          <category> 运动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中长跑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode刷题笔记--数组</title>
      <link href="/2022/02/05/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84/"/>
      <url>/2022/02/05/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-DQUqSOzA" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="482655706" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#FF4081"    ></div><h1>LeetCode数组专题</h1><h2 id="1-数组的二分查找">1. 数组的二分查找</h2><p>该类型题的一个典型特点是时间复杂度为O(logn)型，且数组都是有序的序列，一般这个时候查找某些元素的位置就会想到二分查找算法。</p><h3 id="704-二分查找">704.二分查找</h3><p>二分查找条件：有序+无重复数组</p><p>注意边界条件和区间的写法</p><ol><li><p>左闭右闭[left≤right]，这时while循环的条件为while(left≤right)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span>(target &lt; nums[mid])&#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">                mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; nums[mid])&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">                mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>左闭右开区间[left,right)，此时的循环条件是while(left&lt;right)</p></li></ol><h3 id="35-搜索插入位置">35.搜索插入位置</h3><h3 id="34-在排序数组中查找元素的第一个和最后一个位置">34.<strong>在排序数组中查找元素的第一个和最后一个位置</strong></h3><p>使用两次二分查找依次寻找要查找的元素的左区间和右区间。做法是仅需对两个边界大小条件对应的操作做出一些修改。</p><p>（当时做的时候是直接使用了两个while循环从mid往两边查找，这样不符合时间复杂度O(log(n))的要求）</p><h3 id="69-求x的平方根">69. 求x的平方根</h3><p>本题使用暴力解法的时间复杂度为O（log(n)），使用二分查找的时间复杂度为O(log(n/2))，实际会更快，注意搜索的区间最开始为1-n/2，并且为了避免 **乘法溢出，**改用除法。</p><h2 id="2-数组的元素移除问题-27">2. 数组的元素移除问题-27</h2><h3 id="27-移除元素-力扣（LeetCode）-leetcode-cn-com">@<a href="https://leetcode-cn.com/problems/remove-element/submissions/">27. 移除元素 - 力扣（LeetCode） (leetcode-cn.com)</a></h3><p>若要在O(n)的复杂度，即一遍扫描完成元素移除，且原地解决，即空间复杂度为1，则需要用到 <strong>快慢指针的方法，慢指针代码要返回的长度，而快指针代表扫描指针。</strong></p><h3 id="26-删除有序数组中的重复项-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项 - 力扣（LeetCode） (leetcode-cn.com)</a></h3><p>只需注意快慢指针的更新</p><h3 id="283-移动零-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零 - 力扣（LeetCode） (leetcode-cn.com)</a></h3><blockquote><p>给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，请你判断二者是否相等。# 代表退格字符。</p></blockquote><blockquote><p>如果相等，返回 true ；否则，返回 false 。</p></blockquote><blockquote><p>注意：如果对空文本输入退格字符，文本继续为空。</p></blockquote><p>此 题我当时想的做法是偏暴力，直接分别对每个字符串求出其实际字符串，时间复杂度为O(N+M)，空间复杂度为O(N+M),因为都需初始化一个StringBuffer.</p><p><strong>最高效的做法：</strong></p><p>使用双指针，因为每个字符是否需要被退格取决于其之后相邻的#，而跟之前的退格无关，因此我们仅仅需要分别对每个字符串同时从最后一个开始递归，然后每次对不需要退格的字符进行比较。</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/%E6%AF%94%E7%89%B9%E6%88%AA%E5%9B%BE2022-01-25-17-15-11.png" alt="比特截图2022-01-25-17-15-11.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = s.length() -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = t.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> skipS = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> skipT = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>||j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                    skipS++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(skipS &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    skipS--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t.charAt(j) == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                    skipT++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(skipT &gt; <span class="number">0</span>)</span><br><span class="line">                    skipT--;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) != t.charAt(j))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="977-有序数组的平方">977. 有序数组的平方</h2><p><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">977. 有序数组的平方 - 力扣（LeetCode） (leetcode-cn.com)</a></p><blockquote><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p></blockquote><blockquote><p>示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p></blockquote><blockquote><p>示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]</p></blockquote><p>要求时间复杂度在O(n)内</p><p>这道题的暴力解法就是平方后再排序输出。但我们知道最快速的排序算法的时间复杂度也是O(nlogn)，不符合题目要求</p><p>这里我们依然用到**双指针法，**先找到临界位置，然后将两个指针的初始位置均设置为最大的负数和最小的正数，然后依次向两边扫描做归并排序，最慢需要n趟扫描。</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/1.png" alt="1.png"></p><h2 id="209-长度最小的子数组—滑动窗口（sliding-window）">209. 长度最小的子数组—滑动窗口（sliding-window）</h2><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209. 长度最小的子数组 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p><strong>本题要求时间复杂度为O(nlog(n))</strong></p><p>我当时的想法是滑动窗口大小从1一直到最大，每次需要循环移动滑动窗口，最后的时间复杂度为O(n*n)。力扣上的效率很低。</p><p>滑动窗口：不断调节子序列的起始位置和终止位置</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/%E6%AF%94%E7%89%B9%E6%88%AA%E5%9B%BE2022-01-26-18-00-01.png" alt="比特截图2022-01-26-18-00-01.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> startIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minLength = <span class="number">0</span>;<span class="comment">//如果未改变该值，则表示没有找到最短数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> endIndex = <span class="number">0</span>; endIndex&lt;nums.length; endIndex++)&#123;</span><br><span class="line">        sum += nums[endIndex];</span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(minLength &gt; <span class="number">0</span>)</span><br><span class="line">                minLength = Math.min((endIndex - startIndex + <span class="number">1</span>), minLength);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                minLength = endIndex - startIndex + <span class="number">1</span>;</span><br><span class="line">            sum -= nums[startIndex++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="904-水果成篮-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/fruit-into-baskets/">904. 水果成篮 - 力扣（LeetCode） (leetcode-cn.com)</a></h3><p><a href="https://leetcode-cn.com/problems/fruit-into-baskets/">904. 水果成篮 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>我最开始想到了用滑动窗口，即使用startIndex和endIndex,对于每个递增的endIndex,都对应一个最小的startIndex,即有f(endIndex) = startIndex, f函数表示使得从startIndex到endIndex的所有水果成功放入蓝中的startIndex的最小值。可见该函数是一个递增函数，因此使用滑动窗口一定能解决出来。</p><p>但关键问题在于如何存储篮子中放置水果的情况，对此我是直接用了两个二维数组分别存储每个篮子内放置的水果的种类和数量，这样做还要在每次增加和删除时作两次比较，降低了算法效率，这样得到了如下的结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(<span class="keyword">int</span>[] fruits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> startIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] basket = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] basketNum = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> endIndex = <span class="number">0</span>; endIndex &lt; fruits.length; endIndex++)&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;<span class="number">2</span> ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(basket[i] == -<span class="number">1</span> || fruits[endIndex] == basket[i])&#123;</span><br><span class="line">                basketNum[i]++;</span><br><span class="line">                basket[i] = fruits[endIndex];</span><br><span class="line">                sum++;</span><br><span class="line">                total = Math.max(sum,total);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sum--;</span><br><span class="line">            <span class="keyword">if</span>(basket[<span class="number">0</span>] == fruits[startIndex])&#123;</span><br><span class="line">                <span class="keyword">if</span>(basketNum[<span class="number">0</span>] == <span class="number">1</span>)</span><br><span class="line">                    basket[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">                basketNum[<span class="number">0</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(basket[<span class="number">1</span>] == fruits[startIndex])&#123;</span><br><span class="line">                <span class="keyword">if</span>(basketNum[<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">                    basket[<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">                basketNum[<span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">            startIndex++;</span><br><span class="line">            endIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/%E6%AF%94%E7%89%B9%E6%88%AA%E5%9B%BE2022-01-26-18-44-31.png" alt="比特截图2022-01-26-18-44-31.png"></p><p>实际上，对于这种情况最好的存储办法是使用<strong>HashMap</strong>，存放若干键值对的集合。修改后的写法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(<span class="keyword">int</span>[] tree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        Counter count = <span class="keyword">new</span> Counter();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tree.length; ++j) &#123;</span><br><span class="line">            count.add(tree[j], <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (count.size() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                count.add(tree[i], -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (count.get(tree[i]) == <span class="number">0</span>)</span><br><span class="line">                    count.remove(tree[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containsKey(k) ? <span class="keyword">super</span>.get(k) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        put(k, get(k) + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而实际上速度反而慢了。。。</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/%E6%AF%94%E7%89%B9%E6%88%AA%E5%9B%BE2022-01-26-18-59-05.png" alt="比特截图2022-01-26-18-59-05.png"></p><h3 id="76-最小覆盖子串（困难）—字节在线一面原题">76. 最小覆盖子串（困难）—字节在线一面原题</h3><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/solution/zui-xiao-fu-gai-zi-chuan-by-leetcode-solution/">最小覆盖子串 - 最小覆盖子串 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>方法一： 使用滑动窗口方法（我当时解题使用的方法）也是最终答案给出的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Character,Integer&gt; orign=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Character,Integer&gt;window=<span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">//记录滑动窗口中的character及频率</span></span><br><span class="line">    <span class="keyword">int</span> ansL=-<span class="number">1</span>;<span class="comment">//全局的左指针</span></span><br><span class="line">    <span class="keyword">int</span> ansR=-<span class="number">1</span>;<span class="comment">//全局的右指针</span></span><br><span class="line">    <span class="keyword">int</span> len=Integer.MAX_VALUE; <span class="comment">//记录每次匹配符合时子串的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length() ; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c=t.charAt(i);</span><br><span class="line">            orign.put(c,orign.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左、右指针</span></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (r&lt;s.length())&#123;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="comment">//可能window中一个字符出现的次数要多于我们要比对的那个字符串中字符的个数</span></span><br><span class="line">            <span class="keyword">if</span>(r&lt;s.length()&amp;&amp;orign.containsKey(s.charAt(r)))&#123;</span><br><span class="line">                window.put(s.charAt(r),window.getOrDefault(s.charAt(r),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (check()&amp;&amp;l&lt;=r)&#123; <span class="comment">//这里检查左指针是否可以收缩窗口，注意左指针可以收缩窗口的条件在于：窗口中包含了字符t</span></span><br><span class="line">                <span class="comment">//能够走到这里就说明已经符合要求了,但是要找到全局最小的子串，所以每次都要判断一下</span></span><br><span class="line">                <span class="keyword">if</span>(r-l+<span class="number">1</span>&lt;len)&#123;</span><br><span class="line">                    ansL=l;</span><br><span class="line">                    ansR=r;</span><br><span class="line">                    len=r-l+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果window中的左边出现了t中的字符，直接减1，然后看是否还能满足完全覆盖的要求</span></span><br><span class="line">                <span class="keyword">if</span>(orign.containsKey(s.charAt(l)))&#123;</span><br><span class="line">                    window.put(s.charAt(l),window.getOrDefault(s.charAt(l),<span class="number">0</span>)-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansR==-<span class="number">1</span>?<span class="string">&quot;&quot;</span>:s.substring(ansL,ansR+<span class="number">1</span>); <span class="comment">//ansR==-1 说明没有符合的，就返回空字符串</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//用于检测是否窗口中是否完全覆盖了子串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry e:orign.entrySet())&#123;</span><br><span class="line">             <span class="keyword">int</span> val= (<span class="keyword">int</span>) e.getValue();</span><br><span class="line">             <span class="keyword">if</span>(window.getOrDefault(e.getKey(), <span class="number">0</span>)&lt;val)&#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补充：遍历Hashmap的几种方法：">补充：遍历Hashmap的几种方法：</h3><ol><li><p>使用迭代器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">　Iterator iter = map.entrySet().iterator();</span><br><span class="line">　<span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">　Map.Entry entry = (Map.Entry) iter.next();</span><br><span class="line">　Object key = entry.getKey();</span><br><span class="line">　Object val = entry.getValue();</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure></li><li><p>For each遍历：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">entry.getKey();</span><br><span class="line">entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：最坏情况下左右指针对 s 的每个元素各遍历一遍，哈希表中对 s中的每个元素各插入、删除一次，对 t 中的元素各插入一次。每次检查是否可行会遍历整个 t 的哈希表，哈希表的大小与字符集的大小有关，设字符集大小为 C，则渐进时间复杂度为 O(C⋅∣s∣+∣t∣).</p></li></ol><h2 id="59-螺旋矩阵2—模拟行为">59.螺旋矩阵2—模拟行为</h2><p><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>无特殊算法，注意边界条件即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        result[i][j] = num;</span><br><span class="line">        <span class="keyword">while</span>(num &lt; n*n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span> &lt; n &amp;&amp; result[i][j+<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; (i-<span class="number">1</span>&lt;<span class="number">0</span> || result[i-<span class="number">1</span>][j] != <span class="number">0</span>))</span><br><span class="line">                result[i][++j] = ++num;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i+<span class="number">1</span> &lt;n &amp;&amp; result[i+<span class="number">1</span>][j] == <span class="number">0</span> &amp;&amp; (j+<span class="number">1</span> == n || result[i][j+<span class="number">1</span>] != <span class="number">0</span>))</span><br><span class="line">                result[++i][j] = ++num;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; result[i][j-<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; (i+<span class="number">1</span> == n || result[i+<span class="number">1</span>][j] != <span class="number">0</span>))</span><br><span class="line">                result[i][--j] = ++num;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i-<span class="number">1</span> &gt;=<span class="number">0</span> &amp;&amp; result[i-<span class="number">1</span>][j] == <span class="number">0</span> &amp;&amp; (j-<span class="number">1</span> &lt;<span class="number">0</span> || result[i][j-<span class="number">1</span>] != <span class="number">0</span>))</span><br><span class="line">                result[--i][j] = ++num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="54-螺旋矩阵">54. 螺旋矩阵</h3><p><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵 - 力扣（LeetCode） (leetcode-cn.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
