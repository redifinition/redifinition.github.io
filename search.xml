<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>归宿项目复盘体会--技术回顾</title>
      <link href="/2022/04/07/gohomeproject/"/>
      <url>/2022/04/07/gohomeproject/</url>
      
        <content type="html"><![CDATA[<h1>归宿项目复盘体会</h1><h1>登录鉴权部分</h1><p>总体思想： <strong>前端同域 + 后端同redis</strong></p><h2 id="登录鉴权-单点登录">登录鉴权-单点登录</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">customerLogin</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">顾客登录</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">axios.defaults.withCredentials = <span class="literal">true</span>; <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">let</span> param = <span class="keyword">new</span> URLSearchParams(data)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;paramss&#x27;</span>, param);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;data&#x27;</span>, data);</span><br><span class="line">    <span class="keyword">var</span> config = &#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>:getDomainUrl() + <span class="string">&#x27;/sso/doLogin&#x27;</span>,</span><br><span class="line">        <span class="attr">params</span>: data,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> axios(config)</span><br><span class="line"><span class="comment">// return request(&#123;</span></span><br><span class="line">    <span class="comment">//     url: &#x27;/sso/doLogin&#x27;,</span></span><br><span class="line">    <span class="comment">//     method: &#x27;GET&#x27;,</span></span><br><span class="line">    <span class="comment">//     params: param</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>axio.defaults.withCredentials = true;表示允许跨域请求带上cookie，这是浏览器的同源策略导致的问题：不允许JS访问跨域的Cookie。为什么要用cookie来存token呢？因为http是无状态的协议，每次请求都是重新建立链接的过程，因此需要在发送请求的时候额外携带与登录状态有关的信息，这个额外携带的信息就是cookie.</p><p>在首页展示是，created里面判断获取本地localStorage来判断登录状态（图为网页的F12 application里的localStorage部分）</p><p><img src="%E5%BD%92%E5%AE%BF%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E4%BD%93%E4%BC%9A%2080a36/Untitled.png" alt="Untitled"></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否有&quot;记住我&quot;信息</span></span><br><span class="line">    <span class="keyword">let</span> rememberState = <span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;rememberPhone&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>前端点击登录按钮输入用户名密码后，调取前述的api,然后使用如下的js代码进行处理：</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断当前登录对象</span></span><br><span class="line">customerLogin(param).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否登录成功</span></span><br><span class="line"><span class="keyword">if</span> (response.data.code === <span class="number">200</span>) &#123;</span><br><span class="line">getCustomerInfo().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;登录成功的返回值为&quot;</span>,response.data)</span><br><span class="line">            <span class="keyword">if</span> (response.status === <span class="number">200</span>) &#123;</span><br><span class="line">              <span class="built_in">this</span>.userName = response.data.userName;</span><br><span class="line">              <span class="built_in">this</span>.userAvatar = response.data.userAvatar;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">&quot;用户id为&quot;</span>,response.data.userId)</span><br><span class="line"></span><br><span class="line"><span class="comment">//后端返回身份</span></span><br><span class="line"><span class="comment">//将用户token保存到vuex中，vuex将一些变量存入内存中，相当于项目的全局变量</span></span><br><span class="line"><span class="built_in">this</span>.changeLogin(&#123;</span><br><span class="line">                <span class="attr">Authorization</span>: <span class="built_in">this</span>.userToken,<span class="comment">//该代码在使用sa-token方案后没有用了</span></span><br><span class="line">                <span class="attr">userId</span>:response.data.userId,</span><br><span class="line">                <span class="attr">userName</span>: response.data.userName,</span><br><span class="line">                <span class="attr">userAvatar</span>: response.data.userAvatar,</span><br><span class="line">                <span class="attr">userIdentity</span>: <span class="string">&#x27;Customer&#x27;</span>,</span><br><span class="line">                <span class="attr">userPermissions</span>: response.data.userPermissions</span><br><span class="line">              &#125;);</span><br><span class="line"></span><br><span class="line">              <span class="built_in">this</span>.dialogTableVisible = <span class="literal">false</span>;</span><br><span class="line">              <span class="built_in">this</span>.loginState = <span class="number">1</span>;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">&#x27;顾客成功登录&#x27;</span>)</span><br><span class="line"></span><br><span class="line">              <span class="built_in">this</span>.$message(&#123;</span><br><span class="line">                <span class="attr">message</span>: <span class="string">&#x27;登录成功！&#x27;</span>,</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&#x27;success&#x27;</span></span><br><span class="line">              &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//跳转路由</span></span><br><span class="line"><span class="built_in">this</span>.$router.push(&#123;<span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查是否勾选了&quot;记住我&quot;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.$refs.loginComponent.rememberMe) &#123;</span><br><span class="line">                <span class="built_in">this</span>.rememberLogin(&#123;</span><br><span class="line">                  <span class="attr">rememberPhone</span>: <span class="built_in">this</span>.$refs.loginComponent.phonenumber,</span><br><span class="line">                  <span class="attr">rememberPassword</span>: <span class="built_in">this</span>.$refs.loginComponent.password</span><br><span class="line">                &#125;)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.delRemember();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="built_in">this</span>.$message(&#123;</span><br><span class="line">                <span class="attr">message</span>: <span class="string">&#x27;用户信息获取失败！&#x27;</span>,</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&#x27;warning&#x27;</span></span><br><span class="line">              &#125;);</span><br><span class="line"><span class="comment">// function returned</span></span><br><span class="line">&#125;</span><br><span class="line">          &#125;</span><br><span class="line">      ).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.$message(&#123;</span><br><span class="line">          <span class="attr">message</span>: <span class="string">&#x27;用户信息获取失败！&#x27;</span>,</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&#x27;warning&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;error&#x27;</span>, error)</span><br><span class="line"><span class="comment">// function returned</span></span><br><span class="line">&#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.$message(&#123;</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&#x27;账号不存在或密码错误！&#x27;</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;warning&#x27;</span></span><br><span class="line">      &#125;);</span><br><span class="line"><span class="comment">// function returned</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  &#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$message(&#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;登录失败，请稍后重试&#x27;</span>,</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;warning&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;error&#x27;</span>, errohoudjuan </span><br></pre></td></tr></table></figure><p><img src="%E5%BD%92%E5%AE%BF%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E4%BD%93%E4%BC%9A%2080a36/Untitled%201.png" alt="Untitled"></p><h3 id="登录鉴权的解决方案：">登录鉴权的解决方案：</h3><p><a href="https://blog.csdn.net/jiangshangchunjiezi/article/details/104433135">(25条消息) Cookie原理、Set-Cookie常用字段、应用_FixedStarHaHa的博客-CSDN博客_set-cookie</a></p><p><img src="%E5%BD%92%E5%AE%BF%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E4%BD%93%E4%BC%9A%2080a36/Untitled%202.png" alt="Untitled"></p><p>如上图所示，主要技术是sa-token在返回的响应头中设置cookie，服务端生成保存在客户端，请求头对应Cookie字段，响应头对应set-Cookie字段。cookie存储了token信息，今后在调用所有的api发送请求时都会自动携带cookie信息。</p><p><strong>set-cookie字段</strong></p><p>示例:</p><p>Set-Cookie: satoken=903eb0fd-c4db-42ee-ada3-48c136541f1c; Max-Age=2592000; Expires=Sun, 17 Apr 2022 16:09:06 +0800; Path=/</p><p>Set-Cookie:value [ ;expires=date][ ;domain=domain][ ;path=path][ ;secure]</p><p>value: 键值对</p><p>expires: 表示会在多长时间后失效</p><p>domain: 默认是主机名</p><p>一般所说的<strong>不可跨域</strong>是指二级域名层次，<a href="http://xn--bvs393b.yahoo.xn--com-cj4e.baidu.com">比如.yahoo.com和.baidu.com</a>。</p><p>path: 若path=/admin，则页面/admin和/admin/sth是可以访问的（当前及子域），而/home、/adminpage是不能访问的；通常设置为path=/，让网站的所有页面均可以访问。若不设置,默认是 /项目名称/当前路径的上一层地址</p><p><strong>Cookie的限制</strong><br>Cookie数量和长度的限制。每个domain最多只能有20条cookie（取决于浏览器），若达到上限，则浏览器随机删除cookie；每个cookie长度不能超过4KB，否则会被截掉；浏览器最多300个cookie。<br>安全性问题。如果cookie被人拦截了，那人就可以取得所有的cookie信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。<br>（cookie是服务端给客户端的用户标识，而不是进行身份认证）<br>ho</p><h3 id="后端Sa-token的SSO实现方案">后端Sa-token的SSO实现方案</h3><p><a href="https://x8uwstyih4.feishu.cn/wiki/wikcnk4KoGynbJo5HdFe6DPL1fh#">SSO 集成方案 - 飞书云文档 (feishu.cn)</a></p><p>注意领会单点登录和Oauth2登录的区别</p><p>单点登录（Single Sign On），简称为 SSO，是比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</p><table><thead><tr><th>系统架构</th><th>简介</th><th>文档链接</th></tr></thead><tbody><tr><td>前端同域—+后端同redis</td><td>共享Cookie同步会话</td><td>SSO模式一 共享Cookie同步会话 - Sa-Token (<a href="http://dev33.cn">dev33.cn</a>)</td></tr><tr><td>前端不同域+后端同redis</td><td>URL重定向传播会话</td><td>SSO模式二 URL重定向传播会话 - Sa-Token (<a href="http://dev33.cn">dev33.cn</a>)</td></tr><tr><td>前端不同域 + 后端不同 Redis</td><td>http请求获取会话</td><td>SSO模式三 Http请求获取会话 - Sa-Token (<a href="http://dev33.cn">dev33.cn</a>)</td></tr></tbody></table><p><a href="https://sa-token.dev33.cn/doc/index.html#/">介绍 - Sa-Token (dev33.cn)</a></p><p>附上Sa - Token的官方文档</p><h2 id="为什么要用redis">为什么要用redis</h2><p>Sa-token默认将数据保存在内存中，此模式读写速度最快，且避免了序列化与反序列化带来的性能消耗，但是此模式也有一些缺点，比如：</p><ol><li>重启后数据会丢失</li><li>无法在分布式环境中共享数据</li></ol><p>为此，Sa-Token提供了扩展接口，你可以轻松将会话数据存储在 <code>Redis</code><br>、<code>Memcached</code>等专业的缓存中间件中， 做到重启数据不丢失，而且保证分布式环境下多节点的会话一致性</p><h2 id="有关微服务的登录鉴权">有关微服务的登录鉴权</h2><p>首先我们要明白，分布式环境下为什么<code>Session</code>会失效？因为用户在一个节点对会话做出的更改无法实时同步到其它的节点， 这就导致一个很严重的问题：如果用户在节点一上已经登录成功，那么当下一次的请求落在节点二上时，对节点二来讲，此用户仍然是未登录状态。</p><p>要怎么解决这个问题呢？目前的主流方案有四种：</p><ol><li><strong>Session同步</strong>：只要一个节点的数据发生了改变，就强制同步到其它所有节点</li><li><strong>Session粘滞</strong>：通过一定的算法，保证一个用户的所有请求都稳定的落在一个节点之上，对这个用户来讲，就好像还是在访问一个单机版的服务</li><li><strong>建立会话中心</strong>：将Session存储在专业的缓存中间件上，使每个节点都变成了无状态服务，例如：<code>Redis</code></li><li><strong>颁发无状态token</strong>：放弃Session机制，将用户数据直接写入到令牌本身上，使会话数据做到令牌自解释，例如：<code>jwt</code></li></ol><p>我们项目使用的是方案三，并且使用**网关统一鉴权，**实现鉴权接口，返回loginId和lodinType对应的权限列表。然后在网关处注册全局过滤器进行鉴权操作。</p>]]></content>
      
      
      <categories>
          
          <category> 技术博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目复盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript学习笔记--this指向问题</title>
      <link href="/2022/04/07/js-this/"/>
      <url>/2022/04/07/js-this/</url>
      
        <content type="html"><![CDATA[<h1>javascript ——this指向问题</h1><p>在总结节流和防抖问题时涉及到了this指向，加之在平时写项目时也会经常遇到，所以开个专题搞清楚一下这个很重要的概念吧。</p><p>在 JavaScript 中，<code>this</code>是“自由”的，它的值是在调用时计算出来的，它的值并不取决于方法声明的位置，而是取决于在“点符号前”的是什么对象。需要刻在DNA里的是，箭头函数没有自己的this，从箭头函数内部访问到的this都是从外部获取的。</p><p><strong>为什么要有this呢？</strong></p><p>因为每一个函数中的变量都由运行环境（词法环境）提供，而不同的运行环境变量的含义不同，需要有一种机制能够在函数体内部获得当前的运行环境(context)。<strong>因此this设计的目的就是在函数体内部指代函数当前的运行环境</strong>。</p><p>在理解this之前，我们需要记住以下两点：</p><p><strong>1：this永远指向一个对象；</strong></p><p><strong>2：this的指向完全取决于函数调用的位置，也可以说是函数的运行环境；</strong></p><p>接下来对this使用最频繁的几种情况做一个总结，总共分为以下5种：</p><h2 id="对象中的方法">对象中的方法</h2><p>在对象中，当方法被作为属性时，存储的是属性的引用，即存储一个地址，指向堆中的函数。当函数进行调用时，this会根据运行环境的改变而改变，同时，函数中的this也<strong>只能在运行时才能最终确定运行环境</strong>；根据运行环境指向不同的对象。</p><p>对于函数而言，引擎会将函数单独存在内存中，然后将函数的地址赋值给foo属性的value属性。而属性原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。</p><p><img src="https://www.wangbase.com/blogimg/asset/201806/bg2018061803.png" alt="https://www.wangbase.com/blogimg/asset/201806/bg2018061803.png"></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">f</span>: f,</span><br><span class="line">  <span class="attr">x</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独执行</span></span><br><span class="line">f() <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// obj 环境执行</span></span><br><span class="line">obj.f() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>在全局环境执行，<code>this.x</code>指向全局环境的<code>x</code>。</p><p><img src="javascript%20a9cf3/Untitled.png" alt="Untitled"></p><p>在<code>obj</code>环境执行，<code>this.x</code>指向<code>obj.x</code>。</p><p><img src="javascript%20a9cf3/Untitled%201.png" alt="Untitled"></p><h2 id="事件绑定中的this">事件绑定中的this</h2><p>事件绑定共有三种方式：行内绑定、动态绑定、事件监听；</p><p><strong>行内绑定的两种情况：</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;input type**=**<span class="string">&quot;button&quot;</span> value**=**<span class="string">&quot;按钮&quot;</span> onclick**=**<span class="string">&quot;clickFun()&quot;</span>&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    **<span class="function"><span class="keyword">function</span>** <span class="title">clickFun</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        **<span class="built_in">this</span>** *<span class="comment">// 此函数的运行环境在全局window对象下，因此this指向window;*</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>**=<span class="string">**</span>&quot;<span class="attr">button</span>&quot; <span class="attr">value</span>**=<span class="string">**</span>&quot;按钮&quot; <span class="attr">onclick</span>**=<span class="string">**</span>&quot;<span class="attr">this</span>&quot;&gt;</span></span></span><br><span class="line"><span class="xml">*<span class="comment">&lt;!-- 运行环境在节点对象中，因此this指向本节点对象 --&gt;</span>*</span></span><br></pre></td></tr></table></figure><p>行内绑定事件的语法是在html节点内，以节点属性的方式绑定，属性名是事件名称前面加’on’，属性的值则是一段可执行的 JS 代码段；而属性值最常见的就是一个函数调用；</p><p><strong>动态绑定与事件监听：</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;按钮&quot;</span> id=<span class="string">&quot;btn&quot;</span>&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">var</span> btn= <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    btn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">this</span> ;<span class="comment">// this指向本节点对象</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>因为动态绑定的事件本就是为节点对象的属性(事件名称前面加’on’)重新赋值为一个匿名函数，因此函数在执行时就是在节点对象的环境下，this自然就指向了本节点对象；</p><p>事件监听中this指向的原理与动态绑定基本一致，所以不再阐述；</p><h2 id="构造函数中的this">构造函数中的this</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Pro</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.x= <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="built_in">this</span>.y=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p=<span class="keyword">new</span> Pro();</span><br></pre></td></tr></table></figure><p><img src="https://pic2.zhimg.com/80/v2-7ce5f71bd0865872b513a88fabb597fd_720w.jpg" alt="https://pic2.zhimg.com/80/v2-7ce5f71bd0865872b513a88fabb597fd_720w.jpg"></p><h2 id="window定时器中的this">window定时器中的this</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">fun</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(obj.fun,<span class="number">1000</span>);      <span class="comment">// this指向window对象</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="string">&#x27;obj.fun()&#x27;</span>,<span class="number">1000</span>);  <span class="comment">// this指向obj对象</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>setInterval(obj.fun,1000)</code> 的第一个参数是<code>obj</code>对象的<code>fun</code> ，因为 JS 中函数可以被当做值来做引用传递，实际就是将这个函数的地址当做参数传递给了 <code>setInterval</code> 方法，换句话说就是 <code>setInterval</code> 的第一参数接受了一个函数，那么此时1000毫秒后，函数的运行就已经是在window对象下了，也就是函数的调用者已经变成了window对象，所以其中的this则指向的全局window对象；</p><p>而在 <code>setInterval('obj.fun()',1000)</code> 中的第一个参数，实际则是传入的一段可执行的 JS 代码；1000毫秒后当 JS 引擎来执行这段代码时，则是通过 <code>obj</code> 对象来找到 <code>fun</code> 函数并调用执行，那么函数的运行环境依然在 对象 <code>obj</code> 内，所以函数内部的this也就指向了 <code>obj</code> 对象；</p><h2 id="call-apply-中的this">call(),apply()中的this</h2><p>这个两个方法的最大作用基本就是用来强制指定函数调用时this的指向；</p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript--防抖与节流</title>
      <link href="/2022/04/07/debounc/"/>
      <url>/2022/04/07/debounc/</url>
      
        <content type="html"><![CDATA[<h1>javascript—防抖与节流总结</h1><p><strong>防抖是控制次数，节流是控制频率。</strong></p><p>​</p><p>可以说这句话总结的很精辟了。</p><h2 id="防抖-debounce">防抖(debounce)</h2><p><strong>所谓防抖，抖为何意？就是一段函数的持续执行，没有任何节制。这样会大大加重服务端的负担，多次连续点击，<code>mousemove</code>事件都会引起函数的无节制高频率执行。防抖就是防止抖的发生。设置一个<code>时间间隔</code>，当客户端多次请求且请求间隔小于这个预设值时，忽略这些请求，当最后一次请求结束且过了一段大于<code>时间间隔</code>的时间，才请求一次。</strong></p><p>比如以下场景：</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/debounce.gif" alt="debounce"></p><p>鼠标移动触发事件，事件显示当前鼠标所在位置。当鼠标不停移动时，持续触发事件，事件不执行。当鼠标停止时，才真正执行当前事件。</p><p>从上述定义和案例我们可以知道，防抖无非实现两点：</p><ul><li>持续触发不执行</li><li>不触发的一段时间之后再执行</li></ul><p>下面是核心代码：</p><h3 id="写法一：">写法一：</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(timeout) <span class="built_in">clearTimeout</span>(timeout); <span class="comment">// 如果持续触发，那么就清除定时器，定时器的回调就不会执行。</span></span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">box.onmousemove = debounce(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    box.innerHTML = <span class="string">`<span class="subst">$&#123;e.clientX&#125;</span>, <span class="subst">$&#123;e.clientY&#125;</span>`</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>**首先是在不触发的一段时间后执行。**对此</p><p>我们使用<code>setTimeout</code>即可，在<code>delay</code>ms后执行func，<strong>注意要使用apply函数</strong>，让 <code>debounce</code> 函数最终返回的函数 this 指向不变以及依旧能接受到 e 参数。（e参数即事件对象，根据不同的事件有不同的属性值）</p><p>**其次是在函数持续触发是不执行。**对此换一种说法是如果函数被触发则取消调度，重新等待一段事件间隔执行。因此我们直接清除定时器就好了。</p><p>需要注意的是，每次进行事件触发时，函数不是立即执行的（哪怕没有连续触发）。因此对于需要立即执行的应用场景，还有另外一种写法。</p><h3 id="写法二："><strong>写法二：</strong></h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func,wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        <span class="keyword">let</span> callNow = !timeout;</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            timeout = <span class="literal">null</span>;</span><br><span class="line">        &#125;, wait)</span><br><span class="line">        <span class="keyword">if</span> (callNow) func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开发过程中，我们需要根据不同的场景来决定我们需要使用哪一个版本的防抖函数，一般来讲上述的防抖函数都能满足大部分的场景需求。但我们也可以将非立即执行版和立即执行版的防抖函数结合起来，实现最终的防抖函数。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc </span>函数防抖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>func 函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>wait 延迟执行毫秒数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>immediate true 表立即执行，false 表非立即执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func,wait,immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            <span class="keyword">if</span> (callNow) func.apply(context, args)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节流-throttle">节流(throttle)</h2><p>何为流？流可以理解为一个函数被执行的次数。如果函数毫无节制的执行，那就像是水龙头的水流无法控制一样。<strong>节流就是在频繁连续触发事件时，函数在给定的时间内只执行一次。</strong></p><p>对此我们可以分解为两方面：</p><ul><li>持续触发并不会执行多次</li><li>到一定时间再去执行</li></ul><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/throttle.gif" alt="throttle">ht</p><p>达到如上的效果：</p><p>实现节流的关键是设定执行的时机。要做到控制执行的时机，我们可以通过一个开关与定时器<code>setTimeout</code>完成。函数执行的前提条件是开关打开，持续触发时，持续关闭开关，等setTimeout的时间到了再把开关打开，函数就会执行。</p><p>下面是实现的代码：</p><h3 id="写法一：-2">写法一：</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> run = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!run) &#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment">// 如果开关关闭了，那就直接不执行下边的代码</span></span><br><span class="line">      &#125;</span><br><span class="line">      run = <span class="literal">false</span> <span class="comment">// 持续触发的话，run一直是false，就会停在上边的判断那里</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">        run = <span class="literal">true</span> <span class="comment">// 定时器到时间之后，会把开关打开，我们的函数就会被执行</span></span><br><span class="line">      &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">box.onmousemove = throttle(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  box.innerHTML = <span class="string">`<span class="subst">$&#123;e.clientX&#125;</span>, <span class="subst">$&#123;e.clientY&#125;</span>`</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>节流还可以用时间间隔去控制，就是记录上一次函数的执行时间，与当前时间作比较，如果当前时间与上次执行时间的时间差大于一个值，就执行。</p><h3 id="写法二">写法二</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><strong>总结</strong></h1><p><strong>函数防抖</strong>：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。</p><p><strong>函数节流</strong>：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。</p><p><strong>区别</strong>： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。</p>]]></content>
      
      
      <categories>
          
          <category> 技术博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript--柯里化</title>
      <link href="/2022/04/07/js-curring/"/>
      <url>/2022/04/07/js-curring/</url>
      
        <content type="html"><![CDATA[<h1>javascript 学习——Currying</h1><p>参考网站：</p><p><a href="https://zh.javascript.info/currying-partials">柯里化（Currying） (javascript.info)</a></p><p>柯里化是一种函数的转换，它是指将一个函数从可调用的 <code>f(a, b, c)</code><br>转换为可调用的 <code>f(a)(b)(c)</code>。为什么要用柯里化呢？可以看下面的例子：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常正则验证字符串 reg.test(txt)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数封装后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">reg, txt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reg.test(txt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check(<span class="regexp">/\d+/g</span>, <span class="string">&#x27;test&#x27;</span>)       <span class="comment">//false</span></span><br><span class="line">check(<span class="regexp">/[a-z]+/g</span>, <span class="string">&#x27;test&#x27;</span>)    <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Currying后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingCheck</span>(<span class="params">reg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">txt</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reg.test(txt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hasNumber = curryingCheck(<span class="regexp">/\d+/g</span>)</span><br><span class="line"><span class="keyword">var</span> hasLetter = curryingCheck(<span class="regexp">/[a-z]+/g</span>)</span><br><span class="line"></span><br><span class="line">hasNumber(<span class="string">&#x27;test1&#x27;</span>)      <span class="comment">// true</span></span><br><span class="line">hasNumber(<span class="string">&#x27;testtest&#x27;</span>)   <span class="comment">// false</span></span><br><span class="line">hasLetter(<span class="string">&#x27;21212&#x27;</span>)      <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>如上，当很多地方需要检验是否有数字时，柯里化实现了参数复用。但这只是抛砖引玉，柯里化的强大之处远不止于此，下面看详细的总结吧。</p><h2 id="入门">入门</h2><p>其实上面的示例就是一个柯里化最简单的例子。首先<code>curringCheck</code>返回一个包装器<code>function(txt)</code>，然后包装器被以<code>'test1'</code>为参数迪奥用，reg在上一层的词法环境中获取，成功调用。</p><p>例如，我们有一个用于格式化和输出信息的日志（logging）函数 <code>log(date, importance, message)</code>。在实际项目中，此类函数具有很多有用的功能，例如通过网络发送日志（log），在这儿我们仅使用 <code>alert</code>：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">date, importance, message</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">`[<span class="subst">$&#123;date.getHours()&#125;</span>:<span class="subst">$&#123;date.getMinutes()&#125;</span>] [<span class="subst">$&#123;importance&#125;</span>] <span class="subst">$&#123;message&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们将它柯里化！</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">log = _.curry(log);</span><br></pre></td></tr></table></figure><p>柯里化之后，<code>log</code> 仍正常运行：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">log(<span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="string">&quot;DEBUG&quot;</span>, <span class="string">&quot;some debug&quot;</span>); <span class="comment">// log(a, b, c)</span></span><br></pre></td></tr></table></figure><p>……但是也可以以柯里化形式运行：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">log(<span class="keyword">new</span> <span class="built_in">Date</span>())(<span class="string">&quot;DEBUG&quot;</span>)(<span class="string">&quot;some debug&quot;</span>); <span class="comment">// log(a)(b)(c)</span></span><br></pre></td></tr></table></figure><p>现在，我们可以轻松地为当前日志创建便捷函数：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// logNow 会是带有固定第一个参数的日志的偏函数</span></span><br><span class="line"><span class="keyword">let</span> logNow = log(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用它</span></span><br><span class="line">logNow(<span class="string">&quot;INFO&quot;</span>, <span class="string">&quot;message&quot;</span>); <span class="comment">// [HH:mm] INFO message</span></span><br></pre></td></tr></table></figure><p>现在，<code>logNow</code> 是具有固定第一个参数的 <code>log</code>，换句话说，就是更简短的“偏应用函数（partially applied function）”或“偏函数（partial）”。</p><p>我们可以更进一步，为当前的调试日志（debug log）提供便捷函数：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> debugNow = logNow(<span class="string">&quot;DEBUG&quot;</span>);</span><br><span class="line"></span><br><span class="line">debugNow(<span class="string">&quot;message&quot;</span>); <span class="comment">// [HH:mm] DEBUG message</span></span><br></pre></td></tr></table></figure><p>所以：</p><ol><li>柯里化之后，我们没有丢失任何东西：<code>log</code> 依然可以被正常调用。</li><li>我们可以轻松地生成偏函数，例如用于生成今天的日志的偏函数。</li></ol><h2 id="柯里化实现">柯里化实现</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt;= func.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curried.apply(<span class="built_in">this</span>, args.concat(args2));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释如下：</p><p>首先调用柯里化函数后，返回一个包装器<code>curried</code>，如果包装器传入的参数长度大于或等于原来定义的函数，说明直接使用<code>func.apply</code>将调用传递给他即可。否则继续递归，获取偏函数，返回另外一个包装器，将传入的参数与新的参数一起传入继续调用<code>curried</code>.</p><p><strong>值得注意的是，对函数直接调用length表示的是该函数必须要传入的形参个数。</strong></p><p>用例如下：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> curriedSum = curry(sum);</span><br><span class="line"></span><br><span class="line">alert( curriedSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) ); <span class="comment">// 6，仍然可以被正常调用</span></span><br><span class="line">alert( curriedSum(<span class="number">1</span>)(<span class="number">2</span>,<span class="number">3</span>) ); <span class="comment">// 6，对第一个参数的柯里化</span></span><br><span class="line">alert( curriedSum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) ); <span class="comment">// 6，全柯里化</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript--函数进阶总结</title>
      <link href="/2022/04/07/js-function/"/>
      <url>/2022/04/07/js-function/</url>
      
        <content type="html"><![CDATA[<h1>Javascript学习笔记 — 函数进阶内容</h1><h1>递归和堆栈</h1><h2 id="递归">递归</h2><p>使用执行上下文堆栈存储递归的上下文</p><p>递归深度等于堆栈中上下文的最大数量。</p><p><strong>应用：Json的递归遍历</strong></p><p>对于一个有 <code>N</code>个子部门的 <strong>对象</strong> —— 我们可以通过 <code>N</code>层递归调用来求每一个子部门的薪资，然后将它们合并起来。示例代码：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> company = &#123; <span class="comment">// 是同一个对象，简洁起见被压缩了</span></span><br><span class="line">  <span class="attr">sales</span>: [&#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">salary</span>: <span class="number">1000</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">salary</span>: <span class="number">1600</span> &#125;],</span><br><span class="line">  <span class="attr">development</span>: &#123;</span><br><span class="line">    <span class="attr">sites</span>: [&#123;<span class="attr">name</span>: <span class="string">&#x27;Peter&#x27;</span>, <span class="attr">salary</span>: <span class="number">2000</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&#x27;Alex&#x27;</span>, <span class="attr">salary</span>: <span class="number">1800</span> &#125;],</span><br><span class="line">    <span class="attr">internals</span>: [&#123;<span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>, <span class="attr">salary</span>: <span class="number">1300</span>&#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来完成任务的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumSalaries</span>(<span class="params">department</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(department)) &#123; <span class="comment">// 情况（1）</span></span><br><span class="line">    <span class="keyword">return</span> department.reduce(<span class="function">(<span class="params">prev, current</span>) =&gt;</span> prev + current.salary, <span class="number">0</span>); <span class="comment">// 求数组的和</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 情况（2）</span></span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> subdep <span class="keyword">of</span> <span class="built_in">Object</span>.values(department)) &#123;</span><br><span class="line">      sum += sumSalaries(subdep); <span class="comment">// 递归调用所有子部门，对结果求和</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(sumSalaries(company)); <span class="comment">// 7700</span></span><br></pre></td></tr></table></figure><h1>Rest 参数与Spread语法</h1><p>Rest 参数可以通过使用三个点 <code>...</code>并在后面跟着包含剩余参数的数组名称，来将它们包含在函数定义中。这些点的字面意思是“将剩余参数收集到一个数组中”。</p><h2 id="arguments变量">arguments变量</h2><p>有一个名为 <code>arguments</code>的特殊的类数组对象，该对象按参数索引包含所有参数。如果我们在箭头函数中访问 <code>arguments</code>，访问到的 <code>arguments</code>并不属于箭头函数，而是属于箭头函数外部的“普通”函数。</p><h2 id="Spread-语法">Spread 语法</h2><p>当函数需要将数组内的元素依次作为参数传入时，可以使用<code>...</code> 将数组展开到参数列表中。除此以外还可用其合并数组</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">8</span>, <span class="number">9</span>, <span class="number">15</span>];</span><br><span class="line"><span class="keyword">let</span> merged = [<span class="number">0</span>, ...arr, <span class="number">2</span>, ...arr2];</span><br></pre></td></tr></table></figure><p>除此之外，还可用<code>[...str]</code>将字符串转化为字符数组</p><p>当我们在代码中看到 <code>&quot;...&quot;</code> 时，它要么是 rest 参数，要么就是 spread 语法。</p><p>有一个简单的方法可以区分它们：</p><ul><li>若 <code>...</code> 出现在函数参数列表的最后，那么它就是 rest 参数，它会把参数列表中剩余的参数收集到一个数组中。</li><li>若 <code>...</code> 出现在函数调用或类似的表达式中，那它就是 spread 语法，它会把一个数组展开为列表。</li></ul><p><strong>使用场景：</strong></p><ul><li>Rest 参数用于创建可接受任意数量参数的函数。</li><li>Spread 语法用于将数组传递给通常需要含有许多参数的列表的函数。</li></ul><h1>变量作用域，闭包</h1><h2 id="词法环境">词法环境</h2><p>在 JavaScript 中，每个运行的函数，代码块 <code>&#123;...&#125;</code> 以及整个脚本，都有一个被称为 <strong>词法环境（Lexical Environment）</strong> 的内部（隐藏）的关联对象。</p><p>词法环境对象由两部分组成：</p><ol><li><strong>环境记录（Environment Record）</strong> —— 一个存储所有局部变量作为其属性（包括一些其他信息，例如 <code>this</code> 的值）的对象。</li><li>对 <strong>外部词法环境</strong> 的引用，与外部代码相关联。</li></ol><p><img src="Javascript%20e9513/Untitled.png" alt="Untitled"></p><p>当代码执行时，全局词法环境会发生如下变化：</p><p><img src="Javascript%20e9513/Untitled%201.png" alt="Untitled"></p><p>如上，这就是所谓的与整个脚本相关联的 <strong>全局</strong>词法环境。</p><p>而一个函数其实也是一个值，和变量一样，但<strong>不同之处在于函数声明的初始化会被立即完成</strong>。这就是为什么我们可以在（函数声明）的定义之前调用函数声明</p><p>在一个函数运行时，在调用刚开始时，会自动创建一个新的词法环境以存储这个调用的局部变量和参数。</p><p><img src="Javascript%20e9513/Untitled%202.png" alt="Untitled"></p><p><strong>当代码要访问一个变量时 —— 首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。</strong></p><p>如果在任何地方都找不到这个变量，那么在严格模式下就会报错（在非严格模式下，为了向下兼容，给未定义的变量赋值会创建一个全局变量）。</p><p>回到以下例子：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count++;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = makeCounter();</span><br></pre></td></tr></table></figure><p><img src="Javascript%20e9513/Untitled%203.png" alt="Untitled"></p><p><img src="Javascript%20e9513/Untitled%204.png" alt="Untitled"></p><p>所有的函数在诞生时（还没调用）都会创建它们的词法环境，所有函数都有名为 <code>[[Environment]]</code>的隐藏属性，该属性保存了对创建该函数的词法环境的引用。当调用counter()时，会为该调用创建一个新的词法环境，并且其外部词法环境引用获取于 <code>counter.[[Environment]]</code>：</p><p><img src="Javascript%20e9513/Untitled%205.png" alt="Untitled"></p><p><strong>并且在变量的词法环境中更新变量</strong></p><h2 id="闭包的定义">闭包的定义</h2><p>闭包是指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即使在其外部函数被返回（寿命终结）了之后。在 JavaScript 中，所有函数都是天生闭包的（只有一个例外，将在 <a href="https://zh.javascript.info/new-function">“new Function” 语法</a>中讲到）。</p><h2 id="垃圾回收">垃圾回收</h2><p>通常，函数调用完成后，会将词法环境和其中的所有变量从内存中删除。因为现在没有任何对它们的引用了。与 JavaScript 中的任何其他对象一样，词法环境仅在可达时才会被保留在内存中。</p><p>但是，如果有一个嵌套的函数在函数结束后仍可达，则它将具有引用词法环境的 <code>[[Environment]]</code> 属性。</p><p><strong>但在实际开发中会对其进行优化，JavaScript 引擎会试图优化它。它们会分析变量的使用情况，如果从代码中可以明显看出有未使用的外部变量，那么就会将其删除。</strong></p><h1>有关<code>var</code></h1><p>var具有以下几个特点</p><ul><li><p>var没有块级作用域</p></li><li><p>var 允许重新声明</p></li><li><p>var 声明的变量看可以在声明语句前被使用，包括代码块也会被忽略，这就是var的<strong>变量提升(请注意，声明会被提升，但赋值不会)</strong></p><p>例子：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出应该是undefined和20,因为<code>var a</code>声明被提升到了函数顶部，但是赋值没有，代码等价于：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">a = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>因此，var和let/const有两个主要区别：</p><p><code>var</code> 与 <code>let/const</code> 有两个主要的区别：</p><ol><li><code>var</code> 声明的变量没有块级作用域，它们仅在当前函数内可见，或者全局可见（如果变量是在函数外声明的）。</li><li><code>var</code> 变量声明在函数开头就会被处理（脚本启动对应全局变量）。</li></ol><h1>全局对象</h1><p>全局对象提供可在任何地方使用的变量和函数。默认情况下，这些全局变量内建于语言或环境中。如果一个值非常重要，以至于你想使它在全局范围内可用，那么可以直接将其作为属性写入：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将当前用户信息全局化，以允许所有脚本访问它</span></span><br><span class="line"><span class="built_in">window</span>.currentUser = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码中的另一个位置</span></span><br><span class="line">alert(currentUser.name);  <span class="comment">// John</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者，如果我们有一个名为 &quot;currentUser&quot; 的局部变量</span></span><br><span class="line"><span class="comment">// 从 window 显式地获取它（这是安全的！）</span></span><br><span class="line">alert(<span class="built_in">window</span>.currentUser.name); <span class="comment">// John</span></span><br></pre></td></tr></table></figure><p>全局对象有一个通用名称 <code>globalThis</code>。</p><h1>函数对象，NFE</h1><p>在 JavaScript 中，函数就是对象。</p><h2 id="属性”name“">属性”name“</h2><p>一个函数的名字可以通过”name“来访问，并且能通过上下文推测函数的名字</p><h2 id="属性”length“">属性”length“</h2><p>内建属性length会返回函数入参的个数。注意rest参数不参与计数</p><h2 id="自定义属性">自定义属性</h2><p>被赋值给函数的属性，比如 <code>sayHi.counter = 0</code>，<strong>不会</strong> 在函数内定义一个局部变量 <code>counter</code>。换句话说，属性 <code>counter</code>和变量 <code>let counter</code>是毫不相关的两个东西。</p><p>自定义属性有时会用来替代闭包。那么<strong>孰优孰劣？</strong></p><p>两者最大的不同就是如果 <code>count</code>的值位于外层（函数）变量中，那么外部的代码无法访问到它，只有嵌套的函数可以修改它。而如果它是绑定到函数的，那么就很容易。所以说选择哪种实现方式取决于我们的需求是什么。</p><h2 id="命名函数表达式NFE">命名函数表达式NFE</h2><p>命名函数表达式（NFE，Named Function Expression），指带有名字的函数表达式的术语。</p><p>例如，让我们写一个普通的函数表达式：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHi = <span class="function"><span class="keyword">function</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">`Hello, <span class="subst">$&#123;who&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后给它加一个名字：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHi = <span class="function"><span class="keyword">function</span> *<span class="title">func</span>*(<span class="params">who</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">`Hello, <span class="subst">$&#123;who&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中func就使得该表达式变为了函数命名表达式NFE。func有两个特点：</p><ol><li>它允许函数在内部引用自己。这在递归中很常用</li><li>它在函数外是不可见的。例如若在函数外将sayHi赋值给另外一个变量，则func本身不会受到影响</li></ol><h2 id="示例">示例</h2><p><strong>为counter 添加set  和 decrease方法</strong></p><p>修改 <code>makeCounter()</code> 代码，使得 counter 可以进行减一和设置值的操作：</p><ul><li><code>counter()</code> 应该返回下一个数字（与之前的逻辑相同）。</li><li><code>counter.set(value)</code> 应该将 <code>count</code> 设置为 <code>value</code>。</li><li><code>counter.decrease()</code> 应该把 <code>count</code> 减 1。</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ... your code ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> counter = makeCounter();</span><br><span class="line">  </span><br><span class="line">  alert( counter() ); <span class="comment">// 0</span></span><br><span class="line">  alert( counter() ); <span class="comment">// 1</span></span><br><span class="line">  </span><br><span class="line">  counter.set(<span class="number">10</span>); <span class="comment">// set the new count</span></span><br><span class="line">  </span><br><span class="line">  alert( counter() ); <span class="comment">// 10</span></span><br><span class="line">  </span><br><span class="line">  counter.decrease(); <span class="comment">// decrease the count by 1</span></span><br><span class="line">  </span><br><span class="line">  alert( counter() ); <span class="comment">// 10 (instead of 11)</span></span><br></pre></td></tr></table></figure><p>该解决方案在局部变量中使用 <code>count</code>，而进行加法操作的方法是直接写在 <code>counter</code>中的。它们共享同一个外部词法环境，并且可以访问当前的 <code>count</code>。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  counter.set = <span class="function"><span class="params">value</span> =&gt;</span> count = value;</span><br><span class="line"></span><br><span class="line">  counter.decrease = <span class="function">() =&gt;</span> count--;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = makeCounter();</span><br><span class="line">  </span><br><span class="line">  alert( counter() ); <span class="comment">// 0</span></span><br><span class="line">  alert( counter() ); <span class="comment">// 1</span></span><br><span class="line">  </span><br><span class="line">  counter.set(<span class="number">10</span>); <span class="comment">// set the new count</span></span><br><span class="line">  </span><br><span class="line">  alert( counter() ); <span class="comment">// 10</span></span><br><span class="line">  </span><br><span class="line">  counter.decrease(); <span class="comment">// decrease the count by 1</span></span><br><span class="line">  </span><br><span class="line">  alert( counter() ); <span class="comment">// 10 (instead of 11)</span></span><br></pre></td></tr></table></figure><p><strong>写一个函数 <code>sum</code>，它有这样的功能：</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">sum(<span class="number">1</span>)(<span class="number">2</span>) == <span class="number">3</span>; <span class="comment">// 1 + 2</span></span><br><span class="line">sum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) == <span class="number">6</span>; <span class="comment">// 1 + 2 + 3</span></span><br><span class="line">sum(<span class="number">5</span>)(-<span class="number">1</span>)(<span class="number">2</span>) == <span class="number">6</span></span><br><span class="line">sum(<span class="number">6</span>)(-<span class="number">1</span>)(-<span class="number">2</span>)(-<span class="number">3</span>) == <span class="number">0</span></span><br><span class="line">sum(<span class="number">0</span>)(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>) == <span class="number">15</span></span><br></pre></td></tr></table></figure><p>注意体会本题与函数柯里化的区别。</p><p><strong>solution:</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> currentSum = a;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">    currentSum += b;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentSum;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">f.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentSum;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert( sum(<span class="number">1</span>)(<span class="number">2</span>) ); <span class="comment">// 3</span></span><br><span class="line">alert( sum(<span class="number">5</span>)(-<span class="number">1</span>)(<span class="number">2</span>) ); <span class="comment">// 6</span></span><br><span class="line">alert( sum(<span class="number">6</span>)(-<span class="number">1</span>)(-<span class="number">2</span>)(-<span class="number">3</span>) ); <span class="comment">// 0</span></span><br><span class="line">alert( sum(<span class="number">0</span>)(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>) ); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>请注意 <code>sum</code> 函数只工作一次，它返回了函数 <code>f</code>。</p><p>然后，接下来的每一次子调用，<code>f</code> 都会把自己的参数加到和 <code>currentSum</code> 上，然后 <code>f</code> 自身。</p><p><strong>在 <code>f</code> 的最后一行没有递归。</strong></p><p>递归是这样子的：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  currentSum += b;</span><br><span class="line">  <span class="keyword">return</span> f(); <span class="comment">// &lt;-- 递归调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们的例子中，只是返回了函数，并没有调用它：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  currentSum += b;</span><br><span class="line">  <span class="keyword">return</span> f; <span class="comment">// &lt;-- 没有调用自己，只是返回了自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>f</code> 会被用于下一次调用，然后再次返回自己，按照需要重复。然后，当它被用做数字或字符串时 —— <code>toString</code> 返回 <code>currentSum</code>。我们也可以使用 <code>Symbol.toPrimitive</code> 或者 <code>valueOf</code> 来实现转换。</p><h1>new Function语法</h1><h2 id="语法-2">语法</h2><p>创建函数。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="keyword">new</span> <span class="built_in">Function</span> ([arg1, arg2, ...argN], functionBody);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;return a+b&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="创建函数应用场景">创建函数应用场景</h2><p>比如在复杂的Web应用程序中，我们需要从服务器获取代码或动态地从模板编译函数时才会使用。</p><p>与一般函数不同的是，函数均是闭包，即使用一个特殊的属性<code>[[Environment]]</code> 来记录函数自身创建时的环境的函数，指向了函数创建时的词法环境。但创建函数不同，其[[Environment]]属性不指向当前的词法环境，而指向全局环境。<strong>因此，此类函数无法访问外部变量，而只能访问全局变量</strong></p><p><strong>这样做又有什么好处？</strong></p><p>javascript在发布到生产环境之前会使用压缩程序进行压缩，将局部变量命名为较短的变量，在这种情况下，如果使 <code>new Function</code>可以访问自身函数以外的变量，它也很有可能无法找到重命名的 <code>userName</code>，这是因为新函数的创建发生在代码压缩以后，变量名已经被替换了。</p><h1>调度：<code>setTimeout</code>和<code>setInterval</code></h1><ul><li><code>setTimeout</code> 允许我们将函数推迟到一段时间间隔之后再执行。</li><li><code>setInterval</code> 允许我们重复运行一个函数，从一段时间间隔之后开始运行，之后以该时间间隔连续重复运行该函数。</li></ul><h2 id="setTimeout"><code>setTimeout</code></h2><p>语法：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timerId = <span class="built_in">setTimeout</span>(func|code, [delay], [arg1], [arg2], ...)</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>**<code>func|code</code>**想要执行的函数或代码字符串。</p><p>**<code>delay</code><strong>执行前的延时，以毫秒为单位（1000 毫秒 = 1 秒），默认值是 0；</strong><code>arg1</code>，<code>arg2</code>…**要传入被执行函数（或代码字符串）的参数列表（IE9 以下不支持）</p><p>如果第一个参数位传入的是字符串，JavaScript 会自动为其创建一个函数。</p><p>所以这么写也是可以的：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="string">&quot;alert(&#x27;Hello&#x27;)&quot;</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>但是，不建议使用字符串，我们可以使用箭头函数代替它们，如下所示：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> alert(<span class="string">&#x27;Hello&#x27;</span>), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>注意，第一个参数不能加括号！这是因为<code>setTimeout</code>期望得到一个对函数的引用，加了括号就表示执行函数了。</p><h3 id="调度">调度</h3><p><code>setTimeout</code>在调用时会返回一个“定时器标识符（timer identifier）”，我们可以使用它来取消执行。</p><p>取消调度的语法：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timerId = <span class="built_in">setTimeout</span>(...);</span><br><span class="line"><span class="built_in">clearTimeout</span>(timerId);</span><br></pre></td></tr></table></figure><p>此时因为紧接着取消了这次调度，所以什么也没发生</p><h2 id="setInterval"><code>setInterval</code></h2><p>语法和<code>setTimeout</code>的语法相同。但含义是每隔给定的时间周期性地执行。</p><p>想要阻止后续调用，我们需要调用 <code>clearInterval(timerId)</code>。</p><p>下面的例子将每间隔 2 秒就会输出一条消息。5 秒之后，输出停止：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每 2 秒重复一次</span></span><br><span class="line"><span class="keyword">let</span> timerId = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> alert(<span class="string">&#x27;tick&#x27;</span>), <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 秒之后停止</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="built_in">clearInterval</span>(timerId); alert(<span class="string">&#x27;stop&#x27;</span>); &#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><h2 id="嵌套的setTimeout">嵌套的setTimeout</h2><p>周期性调度有两种方式。</p><p>一种是使用 <code>setInterval</code>，另外一种就是嵌套的 <code>setTimeout</code>，就像这样：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** instead of:</span></span><br><span class="line"><span class="comment">let timerId = setInterval(() =&gt; alert(&#x27;tick&#x27;), 2000);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> timerId = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;tick&#x27;</span>);</span><br><span class="line">  *timerId = <span class="built_in">setTimeout</span>(tick, <span class="number">2000</span>); <span class="comment">// (*)*</span></span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>嵌套的 <code>setTimeout</code>要比 <code>setInterval</code>灵活得多。采用这种方式可以根据当前执行结果来调度下一次调用，因此下一次调用可以与当前这一次不同。<strong>比如我们实现一个服务，每隔一定的时间发送一个数据请求，但如果服务器过载了，就要降低请求频率。</strong></p><p><strong>嵌套的 <code>setTimeout</code> 能够精确地设置两次执行之间的延时，而 <code>setInterval</code> 却不能。</strong></p><p>下面来比较这两个代码片段。第一个使用的是 <code>setInterval</code>：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  func(i++);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>第二个使用的是嵌套的 <code>setTimeout</code>：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  func(i++);</span><br><span class="line">  <span class="built_in">setTimeout</span>(run, <span class="number">100</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>对 <code>setInterval</code> 而言，内部的调度程序会每间隔 100 毫秒执行一次 <code>func(i++)</code>：</p><p><img src="Javascript%20e9513/Untitled%206.png" alt="Untitled"></p><p><strong>使用 <code>setInterval</code> 时，<code>func</code> 函数的实际调用间隔要比代码中设定的时间间隔要短。</strong></p><p>这也是正常的，因为 <code>func</code> 的执行所花费的时间“消耗”了一部分间隔时间。</p><p>也可能出现这种情况，就是 <code>func</code> 的执行所花费的时间比我们预期的时间更长，并且超出了 100 毫秒。</p><p>在这种情况下，JavaScript 引擎会等待 <code>func</code> 执行完成，然后检查调度程序，如果时间到了，则 <strong>立即</strong> 再次执行它。</p><p>极端情况下，如果函数每次执行时间都超过 <code>delay</code> 设置的时间，那么每次调用之间将完全没有停顿。</p><p>这是嵌套的 <code>setTimeout</code> 的示意图：</p><p><img src="Javascript%20e9513/Untitled%207.png" alt="Untitled"></p><p><strong>嵌套的 <code>setTimeout</code> 就能确保延时的固定（这里是 100 毫秒）。</strong></p><p>这是因为下一次调用是在前一次调用完成时再调度的。</p><p><strong>注：对于调度程序内的函数的垃圾回收而言，调度程序内部会为函数创建一个内部引用，因此只要调度程序没有被取消(setInterval)，该函数就会一直存在，不会被GC回收，而若函数为闭包，则若没有取消调度，外部变量也会一直存在，因此当我们不再需要调度函数时，因及时取消它</strong></p><h2 id="简单的计时输出案例">简单的计时输出案例</h2><p>编写一个函数 <code>printNumbers(from, to)</code>，使其每秒输出一个数字，数字从 <code>from</code> 开始，到 <code>to</code> 结束。</p><p>使用以下两种方法来实现。</p><ol><li>使用 <code>setInterval</code>。</li><li>使用嵌套的 <code>setTimeout</code>。</li></ol><p>使用嵌套的 <code>setTimeout</code>：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printNumbers</span>(<span class="params"><span class="keyword">from</span>, to</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> current = <span class="keyword">from</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(current);</span><br><span class="line">    <span class="keyword">if</span> (current &lt; to) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(go, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    current++;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用例：</span></span><br><span class="line">printNumbers(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>使用 <code>setInterval</code>：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printNumbers</span>(<span class="params"><span class="keyword">from</span>, to</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> current = <span class="keyword">from</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> timerId = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(current);</span><br><span class="line">    <span class="keyword">if</span> (current == to) &#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(timerId);</span><br><span class="line">    &#125;</span><br><span class="line">    current++;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用例：</span></span><br><span class="line">printNumbers(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>注意，以上代码第一次弹窗都是过了1秒后才执行的。</p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git基本操作指令整理</title>
      <link href="/2022/04/07/git/"/>
      <url>/2022/04/07/git/</url>
      
        <content type="html"><![CDATA[<h1>Git 基本操作指令整理</h1><p>整理来源</p><p><a href="https://learngitbranching.js.org/">https://learngitbranching.js.org/</a></p><p>一个很好的网站，通过闯关循序渐进的理解git操作</p><h1>基本操作</h1><h2 id="git-commit"><code>git commit</code></h2><p>Git 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样.</p><p>使用该指令即可将本地的修改提交到远程，且创建一个新的节点指向原来的父节点（上一次提交）</p><h2 id="git-branch"><code>git branch</code></h2><p>git创建分支其实是简单地指向某个提交记录。使用分支其实就相当于在说：“我想基于这个提交以及它所有的父提交进行新的工作。”</p><p><img src="Git%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%2021f5f/Untitled.png" alt="Untitled"></p><h3 id="git-branch-name"><code>git branch &lt;name</code>&gt;</h3><p>创建一个名为name的新分支，</p><h3 id="git-checkout-name-position"><code>git checkout &lt;name&gt; position</code></h3><p>将分支切换对应的分支，以在对应的分支上作修改</p><p><em>注意：在 Git 2.23 版本中，引入了一个名为 <code>git switch</code> 的新命令，最终会取代 <code>git checkout</code>，因为 <code>checkout</code> 作为单个命令有点超载（它承载了很多独立的功能）。</em></p><p>position代表创建分支的节点位置，默认为当前HEAD</p><h3 id="git-checkout-branch-name"><code>git checkout -branch &lt;name&gt;</code></h3><p>前两个指令的简写版本：创建一个新的分支同时切换到新创建的分支</p><h2 id="git-merge"><code>git merge</code></h2><p>在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个父节点。翻译成自然语言相当于：“我要把这两个父节点本身及它们所有的祖先都包含进来。”</p><p>在A分支，要想将另一个分支合并进来，使用<code>git merge B</code> 则A包含了对B的所有修改</p><h2 id="git-rebase"><code>git rebase</code></h2><p>第二种合并分支的方法是 <code>git rebase</code>。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p><p>比如，若使用指令<code>git rebase main</code> 则会实现如下效果：</p><p><img src="Git%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%2021f5f/Untitled%201.png" alt="Untitled"></p><p><code>git rebase A B</code></p><p>实现将B的提交记录赋值并放到A分支的下面</p><h1>版本控制</h1><h2 id="HEAD">HEAD</h2><p>HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。</p><p>分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。本来HEAD是指向main的，当使用指令<code>git checkout c1</code> 时，HEAD指向了c1而不是main.</p><p><img src="Git%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%2021f5f/Untitled%202.png" alt="Untitled"></p><h2 id="相对引用">相对引用</h2><p><code>git log</code>来查查看提交记录的哈希值。通过哈希值指定提交记录很不方便，所以 Git 引入了相对引用。</p><p>相对引用非常给力，这里介绍两个简单的用法：</p><ul><li>使用 <code>^</code> 向上移动 1 个提交记录</li><li>使用 <code>~&lt;num&gt;</code> 向上移动多个提交记录，如 <code>~3</code></li></ul><p>所以 <code>main^</code> 相当于“<code>main</code> 的父节点”。</p><p><code>main^^</code> 是 <code>main</code> 的第二个父节点</p><p><img src="Git%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%2021f5f/Untitled%203.png" alt="Untitled"></p><p>使用相对引用最多的就是移动分支。可以直接使用 <code>-f</code> 选项让分支指向另一个提交。例如:</p><p><code>git branch -f main HEAD~3</code></p><p>上面的命令会将 main 分支强制指向 HEAD 的第 3 级父提交。</p><p><img src="Git%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%2021f5f/Untitled%204.png" alt="Untitled"></p><h2 id="撤销变更">撤销变更</h2><p>在 Git 里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。</p><p>主要有两种方法用来撤销变更 —— 一是 <code>git reset</code>，还有就是 <code>git revert</code>。</p><h3 id="git-reset-引用"><code>git reset &lt;引用&gt;</code></h3><p><code>git reset</code><br>通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。<code>git reset</code>向上移动分支，参数表示要撤销到的节点。原来指向的提交记录就跟从来没有提交过一样。但是<strong>被撤销的变更还在，但是处于未加入暂存区状态</strong>。</p><h3 id="git-revert"><code>git revert</code></h3><p>虽然在你的本地分支中使用 <code>git reset</code> 很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！</p><p>为了撤销更改并<strong>分享</strong>给别人，我们需要使用 <code>git revert</code>。</p><p><img src="Git%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%2021f5f/Untitled%205.png" alt="Untitled"></p><h2 id="整理提交记录">整理提交记录</h2><h3 id="git-cherry-pick-提交号"><code>git cherry-pick &lt;提交号&gt;</code></h3><p>如果你想将一些提交复制到当前所在的位置（<code>HEAD</code>）下面的话， Cherry-pick 是最直接的方式了。</p><p>这里有一个仓库, 我们想将 <code>side</code>分支上的工作复制到 <code>main</code>分支，你立刻想到了之前学过的 <code>rebase</code>了吧？但是咱们还是看看 <code>cherry-pick</code>有什么本领吧。</p><p><img src="Git%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%2021f5f/Untitled%206.png" alt="Untitled"></p><p>使用指令 <code>git cherry-pick c2 c4</code></p><p><img src="Git%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%2021f5f/Untitled%207.png" alt="Untitled"></p><p>我们只需要提交记录 <code>C2</code> 和 <code>C4</code>，所以 Git 就将被它们抓过来放到当前分支了。</p><h3 id="交互式的rebase-git-rebase-i-起始点">交互式的rebase <code>git rebase -i &lt;起始点&gt;</code></h3><p>当你知道你所需要的提交记录（还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了。但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase</p><p>交互式 rebase 指的是使用带参数 <code>--interactive</code>的 rebase 命令, 简写为 <code>-i</code></p><p>如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</p><p>当 rebase UI界面打开时, 你能做3件事:</p><ul><li>调整提交记录的顺序（通过鼠标拖放来完成）</li><li>删除你不想要的提交（通过切换 <code>pick</code> 的状态来完成，关闭就意味着你不想要这个提交记录）</li><li>合并提交。 它允许你把多个提交记录合并成一个</li></ul><h1>提交的技巧</h1><p>接下来这种情况也是很常见的：你之前在 <code>newImage</code> 分支上进行了一次提交，然后又基于它创建了 <code>caption</code> 分支，然后又提交了一次。</p><p>此时你想对某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 <code>newImage</code> 中图片的分辨率，尽管那个提交记录并不是最新的了。</p><p><img src="Git%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%2021f5f/Untitled%208.png" alt="Untitled"></p><p>将提交树变为：</p><p><img src="Git%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%2021f5f/Untitled%209.png" alt="Untitled"></p><p>除了使用git cherry-pick 以外，可以使用如下的指令完成：</p><p><code>git rebase -i HEAD~2</code></p><p>变为如下图所示，即先用 <code>git rebase -i</code> 将提交重新排序，然后把我们想要修改的提交记录挪到最前</p><p><img src="Git%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%2021f5f/Untitled%2010.png" alt="Untitled"></p><p>然后使用</p><p><code>git commit   - - amend</code></p><p><img src="Git%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%2021f5f/Untitled%2011.png" alt="Untitled"></p><p>• 接着再用 <code>git rebase -i</code> 来将他们调回原来的顺序</p><p>即 <code>git rebase -i HEAD~2</code></p><p><img src="Git%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%2021f5f/Untitled%2012.png" alt="Untitled"></p><p>最后合并分支，让main直接指向caption分支所在位置</p><p><code>git checkout main</code></p><p><code>git merge caption</code></p><h2 id="git-tags"><code>git tags</code></h2><p>Git 的 tag可以<em>永远</em>指向某个提交记录的标识，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p><p>使用<code>git tag v1 c1</code>将标签命名为v1并让它指向提交记录c1,如果不指定提交记录，Git 会用 <code>HEAD</code> 所指向的位置。</p><h3 id="git-describe"><code>git describe</code></h3><p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来<strong>描述</strong>离你最近的锚点（也就是标签），它就是 <code>git describe</code>.Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 <code>git bisect</code>（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时, 可能会用到这个命令。</p><p>语法：</p><p><code>git describe &lt;ref&gt;</code></p><p><code>&lt;ref&gt;</code>可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（<code>HEAD</code>）。</p><p>输出的结果是这样的：</p><p><code>&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</code></p><p><code>tag</code> 表示的是离 <code>ref</code> 最近的标签， <code>numCommits</code> 是表示这个 <code>ref</code> 与 <code>tag</code> 相差有多少个提交记录， <code>hash</code> 表示的是你所给定的 <code>ref</code> 所表示的提交记录哈希值的前几位。当 <code>ref</code> 提交记录上有某个标签时，则只输出标签名称</p><h1>远程仓库</h1><p>远程仓库有一系列强大的特性</p><ul><li>远程仓库是一个强大的备份。本地仓库也有恢复文件到指定版本的能力, 但所有的信息都是保存在本地的。有了远程仓库以后，即使丢失了本地所有数据, 你仍可以通过远程仓库拿回你丢失的数据。</li><li>远程让代码社交化了。 既然项目被托管到别的地方了, 你的朋友可以更容易地为你的项目做贡献(或者拉取最新的变更)</li></ul><h2 id="git-clone"><code>git clone</code></h2><p>在使用<code>git clone</code>指令后，你可能注意到的第一个事就是在我们的本地仓库多了一个名为 <code>o/main</code> 的分支, 这种类型的分支就叫<strong>远程</strong>分支。由于远程分支的特性导致其拥有一些特殊属性。</p><p>远程分支反映了远程仓库(在你上次和它通信时)的<strong>状态</strong>。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.</p><p>远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。</p><h2 id="git-fetch"><code>git fetch</code></h2><p>从远程仓库获取数据.当我们从远程仓库获取数据时, 远程分支也会更新以反映最新的远程仓库。</p><p><code>git fetch</code> 完成了仅有的但是很重要的两步:</p><ul><li>从远程仓库下载本地仓库中缺失的提交记录</li><li>更新远程分支指针(如 <code>o/main</code>)</li></ul><p><code>git fetch</code> 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。远程分支反映了远程仓库在<strong>最后一次与它通信时</strong>的状态，<code>git fetch</code> 就是你与远程仓库通信的方式了！<code>git fetch</code> 通常通过互联网（使用 <code>http://</code> 或 <code>git://</code> 协议) 与远程仓库通信。</p><p><code>git fetch</code>**并不会改变你本地仓库的状态。它不会更新你的 <code>main</code><br>分支，也不会修改你磁盘上的文件。**所以, 你可以将 <code>git fetch</code><br>的理解为单纯的下载操作。</p><h2 id="git-pull"><code>git pull</code></h2><p>获取远程数据后，如何将变化更新到我们的本地仓库呢？ 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:</p><ul><li><code>git cherry-pick o/main</code></li><li><code>git rebase o/main</code></li><li><code>git merge o/main</code></li><li>等等</li></ul><p>实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。它就是 <code>git pull</code>。</p><p>看看<code>git pull</code> 完成了什么工作。首先是原来的提交树</p><p><img src="Git%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%2021f5f/Untitled%2013.png" alt="Untitled"></p><p>使用<code>git pull</code>之后</p><p><img src="Git%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%2021f5f/Untitled%2014.png" alt="Untitled"></p><p><code>git pull</code>其实就是 git fetch 和 git merge 的缩写</p><h2 id="git-push"><code>git push</code></h2><p><code>git push</code>负责将<strong>你的</strong>变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 <code>git push</code>完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！</p><h2 id="git-pull-rebase解决偏离的历史提交"><code>git pull --rebase</code>解决偏离的历史提交</h2><p>想象如下场景：本地花了一周修改代码，准备提交时，却发现另外一位team member修改了代码并且提交，此时如何处理？</p><p>使用如上指令，等价于：</p><p><code>git fetch</code></p><p><code>git rebase origin/main</code></p><p><img src="Git%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%2021f5f/Untitled%2015.png" alt="Untitled"></p><p><img src="Git%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%2021f5f/Untitled%2016.png" alt="Untitled"></p><p>以上就是使用如上指令后push后的效果。</p><h2 id="Remote-Rejected">Remote Rejected</h2><p>如果你是在一个大的合作团队中工作, 很可能是main被锁定了, 需要一些Pull Request流程来合并修改。如果你直接提交(commit)到本地main, 然后试图推送(push)修改, 你将会收到这样类似的信息:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">! [远程服务器拒绝] main -&gt; main (TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.)</span><br></pre></td></tr></table></figure><p>远程服务器拒绝直接推送(push)提交到main, 因为策略配置要求 pull requests 来提交更新.你应该按照流程,新建一个分支, 推送(push)这个分支并申请pull request,但是你忘记并直接提交给了main.现在你卡住并且无法推送你的更新.</p>]]></content>
      
      
      <categories>
          
          <category> 技术博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记--哈希表</title>
      <link href="/2022/04/07/hashmap/"/>
      <url>/2022/04/07/hashmap/</url>
      
        <content type="html"><![CDATA[<h1>Leetcode—哈希表</h1><p>**一般哈希表都是用来快速判断一个元素是否出现集合里。要枚举的话时间复杂度是$O(n)$，但如果使用哈希表的话， 只需要$O(1)$就可以做到。**哈希表属于是牺牲空间换取时间</p><h2 id="438-找到字符串中所有字母异位词-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词 - 力扣（LeetCode） (leetcode-cn.com)</a></h2><p>本题用js实现时，考虑遍历字符串，取出每个子串与目标串分别排序作对比，但是排序涉及的时间开销过大，时间复杂度达到了$O(n^2logn)$，超时。</p><p>实际现在再次考虑，在比对两个哈希表是否相等是很麻烦的，对于js而言，map内的键值对有序，无法直接比较，而题目要求只有字母，因此可以直接用26的数组来存储词频，数组的相等比较很容易</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), m = p.length();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; m) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span>[] pCnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] sCnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            pCnt[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            sCnt[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Arrays.equals(sCnt, pCnt))&#123;</span><br><span class="line">            res.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &lt; n; i++)&#123;</span><br><span class="line">            sCnt[s.charAt(i - m) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            sCnt[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span>(Arrays.equals(sCnt, pCnt))&#123;</span><br><span class="line">                res.add(i - m + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="349-两个数组的交集-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">349. 两个数组的交集 - 力扣（LeetCode） (leetcode-cn.com)</a></h2><p>本题难度不大，用js写没什么问题，用java写使用集合Set进行处理，可以使用set的intersection方法进行集合的交运算，注意最后要的结果是数组，需要进行常规的转化处理。</p><h3 id="350-两个数组的交集-II-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">350. 两个数组的交集 II - 力扣（LeetCode） (leetcode-cn.com)</a></h3><p>这道题使用了排序+双指针的方法完成，看了答案后发现仍然可以用哈希表来做，思路很妙，可以看下官方给出的题解。</p><p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/">两个数组的交集 II - 两个数组的交集 II - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> intersect = <span class="function"><span class="keyword">function</span>(<span class="params">nums1, nums2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//使用哈希表法</span></span><br><span class="line">    <span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    nums1.forEach(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">        map.set(item,map.get(item)?map.get(item)+<span class="number">1</span>:<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">var</span> result = []</span><br><span class="line">    nums2.forEach(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.get(item) &amp;&amp; map.get(item) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            result.push(item)</span><br><span class="line">            map.set(item,map.get(item)-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="454-四数相加-II-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/4sum-ii/">454. 四数相加 II - 力扣（LeetCode） (leetcode-cn.com)</a></h2><p>和leetcode第一题的思路很像，由于只需要返回个数不需要返回具体的index,直接将前两个数组堪称一个整体，结果存入一个哈希表中，再遍历后面两个数组，查找哈希表中的值就行</p><p><strong>复杂度分析</strong></p><p>时间复杂度：$O(n^2)$。我们使用了两次二重循环，时间复杂度均为 $O(n^2)$。在循环中对哈希映射进行的修改以及查询操作的期望时间复杂度均为 O(1)</p><p>空间复杂度：$O(n^2）$,即为哈希映射需要使用的空间。在最坏的情况下，$A[i]+B[j]A[i]+B[j]$ 的值均不相同，因此值的个数为 $n^2$</p><h2 id="15-三数之和-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和 - 力扣（LeetCode） (leetcode-cn.com)</a></h2><p>没做出来。。但是感觉和两数之和很像，看来得复盘一下两数之和了。其实当时做的时候知道<strong>使用哈希法是太不行的</strong>，因为题目要求结果不能有重复，倘若将前两个数字的组合存入哈希表中，再搜索一遍作比较，结果是会有重复的。因此本题使用双指针法更加合适。</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif" alt="https://code-thinking.cdn.bcebos.com/gifs/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif"></p><p>拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。</p><p>依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i] b = nums[left] c = nums[right]。</p><p>接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] &gt; 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。</p><p>如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。对于i来说，需要从0开始遍历。</p><p>时间复杂度：$O(n^2)$。</p><p>对于代码实现而言，也出现了问题。首先是javascript。自己在对数组去重的处理上有点不知所措，答案给出了两种解决办法。首先是在遍历双指针的时候<strong>不考虑去重</strong>，最后统一去重：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环内不考虑去重 </span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">3</span>) <span class="keyword">return</span> [];</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">const</span> resSet = <span class="keyword">new</span> <span class="built_in">Set</span>();<span class="comment">//用集合存储数组拼接而成的字符串</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">let</span> l = i + <span class="number">1</span>, r = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">const</span> sum = nums[i] + nums[l] + nums[r];</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) &#123; l++; <span class="keyword">continue</span> &#125;;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; <span class="number">0</span>) &#123; r--; <span class="keyword">continue</span> &#125;;</span><br><span class="line">            resSet.add(<span class="string">`<span class="subst">$&#123;nums[i]&#125;</span>,<span class="subst">$&#123;nums[l]&#125;</span>,<span class="subst">$&#123;nums[r]&#125;</span>`</span>);</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(resSet).map(<span class="function"><span class="params">i</span> =&gt;</span> i.split(<span class="string">&quot;,&quot;</span>));<span class="comment">//然后构造新的数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另一种是使用去重优化：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">3</span>) <span class="keyword">return</span> [];</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// a去重</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">let</span> l = i + <span class="number">1</span>, r = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">const</span> sum = nums[i] + nums[l] + nums[r];</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) &#123; l++; <span class="keyword">continue</span> &#125;;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; <span class="number">0</span>) &#123; r--; <span class="keyword">continue</span> &#125;;</span><br><span class="line">            res.push([nums[i], nums[l], nums[r]])</span><br><span class="line">            <span class="comment">// b c 去重</span></span><br><span class="line">            <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[l] === nums[++l]);</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[r] === nums[--r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后第二天又用java代码写了以下，发现还是非常多的坑，这道题代码实现的时候也有很多地方需要注意的，在注释里表明了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">3</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(nums);<span class="comment">//首先需要复习数组排序的函数用法</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length-<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> resultList;<span class="comment">//这个是一个优化的措施，最小的大于0就不需要迭代了</span></span><br><span class="line">            left = i+<span class="number">1</span>;</span><br><span class="line">            right = nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>])<span class="comment">//这一步非常容易遗忘和写错，仔细斟酌</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[left] + nums[right] == <span class="number">0</span>)&#123;</span><br><span class="line">                    List&lt;Integer&gt; list = Arrays.asList(nums[i],nums[left],nums[right]);</span><br><span class="line">                    resultList.add(list);</span><br><span class="line">                    <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[left] == nums[left+<span class="number">1</span>])</span><br><span class="line">                        left++;</span><br><span class="line">                    <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[right] == nums[right-<span class="number">1</span>])</span><br><span class="line">                        right--;</span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[left] + nums[right]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>    </span><br><span class="line">                    right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-四数之和-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/4sum/">18. 四数之和 - 力扣（LeetCode） (leetcode-cn.com)</a></h2><p>和三数之和一样，只不过是外层的i变成了外层的i和j，内层一样的逻辑，java实现，最后结果如下，感觉还有更好的办法？$O(n^3)$的时间复杂度肯定不是最好的办法</p><p><img src="Leetcode%E2%80%94%E5%93%88%2041783/Untitled.png" alt="Untitled"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记--字符串</title>
      <link href="/2022/04/07/leetcode-string/"/>
      <url>/2022/04/07/leetcode-string/</url>
      
        <content type="html"><![CDATA[<h1>leetcode—字符串</h1><h2 id="541-反转字符串-II-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/reverse-string-ii/">541. 反转字符串 II - 力扣（LeetCode） (leetcode-cn.com)</a></h2><p>普通反转字符串的进阶版，思路一样，写一个反转字符串指定位置的字符，注意js中字符串无法进行改变，java中也是，最好使用数组处理完毕再转化完字符串！</p><p><img src="leetcode%E2%80%94%E5%AD%97%20699d8/Untitled.png" alt="Untitled"></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseStr = <span class="function"><span class="keyword">function</span>(<span class="params">s, k</span>) </span>&#123;</span><br><span class="line">    s = [...s]</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(index &lt; s.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(index + <span class="number">2</span>*k-<span class="number">1</span> &lt; s.length)&#123;</span><br><span class="line">            reverse(s,index,index+k-<span class="number">1</span>)</span><br><span class="line">            index += <span class="number">2</span>*k</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.length - index &gt;=k &amp;&amp; s.length - index&lt;<span class="number">2</span>*k)&#123;</span><br><span class="line">            reverse(s,index,index+k-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            reverse(s,index,s.length-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reverse = <span class="function"><span class="keyword">function</span>(<span class="params">s,start,end</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =start;i&lt;=start+(end-start)/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        swap(s,i,end-(i-start))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> swap = <span class="function"><span class="keyword">function</span>(<span class="params">s,i,j</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = s[i]</span><br><span class="line">    s[i] = s[j]</span><br><span class="line">    s[j] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看看答案的写法：</p><p>首先是数组间交换元素，js可以直接用<strong>es6的解构赋值</strong>进行元素交换</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseStr = <span class="function"><span class="keyword">function</span>(<span class="params">s, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = s.length;</span><br><span class="line">    <span class="keyword">let</span> resArr = s.split(<span class="string">&quot;&quot;</span>); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">2</span> * k) &#123;</span><br><span class="line">        <span class="keyword">let</span> l = i - <span class="number">1</span>, r = i + k &gt; len ? len : i + k;</span><br><span class="line">        <span class="keyword">while</span>(++l &lt; --r) [resArr[l], resArr[r]] = [resArr[r], resArr[l]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resArr.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>写法十分简洁…</p><p><img src="leetcode%E2%80%94%E5%AD%97%20699d8/Untitled%201.png" alt="Untitled"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解法二（似乎更容易理解点）</span></span><br><span class="line"><span class="comment">//题目的意思其实概括为 每隔2k个反转前k个，尾数不够k个时候全部反转</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseStr</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ch.length; i += <span class="number">2</span> * k)&#123;</span><br><span class="line">            <span class="keyword">int</span> start = i;</span><br><span class="line">            <span class="comment">//这里是判断尾数够不够k个来取决end指针的位置</span></span><br><span class="line">            <span class="keyword">int</span> end = Math.min(ch.length - <span class="number">1</span>, start + k - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//用异或运算反转 </span></span><br><span class="line">            <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">                ch[start] ^= ch[end];</span><br><span class="line">                ch[end] ^= ch[start];</span><br><span class="line">                ch[start] ^= ch[end];</span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-05-替换空格-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格 - 力扣（LeetCode） (leetcode-cn.com)</a></h2><p>java实现，常规思路，遍历字符串，<code>StringBuffer</code>存结果。</p><p>答案给出的做法是使用双指针法，先扩充数组，然后从最后一位开始进行字符的移位</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扩充空间，空格数量2倍</span></span><br><span class="line">    StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            str.append(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若是没有空格直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(str.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有空格情况 定义两个指针</span></span><br><span class="line">    <span class="keyword">int</span> left = s.length() - <span class="number">1</span>;<span class="comment">//左指针：指向原始字符串最后一个位置</span></span><br><span class="line">    s += str.toString();</span><br><span class="line">    <span class="keyword">int</span> right = s.length()-<span class="number">1</span>;<span class="comment">//右指针：指向扩展字符串的最后一个位置</span></span><br><span class="line">    <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="keyword">while</span>(left&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(chars[left] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            chars[right--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            chars[right--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            chars[right] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            chars[right] = chars[left];</span><br><span class="line">        &#125;</span><br><span class="line">        left--;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="151-颠倒字符串中的单词-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">151. 颠倒字符串中的单词 - 力扣（LeetCode） (leetcode-cn.com)</a></h2><blockquote><p>给你一个字符串 s ，颠倒字符串中 单词 的顺序。<br>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。<br>返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。<br><strong>注意</strong>：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p></blockquote><p>这道题挺烦的地方在于含有前导空格和多余的空格，我用java的split函数有问题，最后的答案总是多包含了空格，所以最后没有做出来。最后用js硬是憋出来了这么个效率低下的答案：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = function(s) &#123;</span><br><span class="line">    <span class="keyword">var</span> arr = s.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    arr.reverse()</span><br><span class="line">    <span class="keyword">while</span>(arr.indexOf(<span class="string">&#x27;&#x27;</span>)!=-<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arr.splice(arr.indexOf(<span class="string">&#x27;&#x27;</span>),<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.join(<span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>低下的原因是每次都要使用<code>indexOf</code>来查找元素</p><p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/solution/fan-zhuan-zi-fu-chuan-li-de-dan-ci-by-leetcode-sol/">翻转字符串里的单词 - 颠倒字符串中的单词 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h3 id="使用语言特性解题">使用语言特性解题</h3><ol><li>使用 <code>split</code> 将字符串按空格分割成字符串数组；</li><li>使用 <code>reverse</code> 将字符串数组进行反转；</li><li>使用 <code>join</code> 方法将字符串数组拼成一个字符串</li></ol><p><img src="leetcode%E2%80%94%E5%AD%97%20699d8/Untitled%202.png" alt="Untitled"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 除去开头和末尾的空白字符</span></span><br><span class="line">s = s.trim();</span><br><span class="line"><span class="comment">// 正则匹配连续的空白字符作为分隔符分割</span></span><br><span class="line">List&lt;String&gt; wordList = Arrays.asList(s.split(<span class="string">&quot;\\s+&quot;</span>));</span><br><span class="line">Collections.reverse(wordList);</span><br><span class="line"><span class="keyword">return</span> String.join(<span class="string">&quot; &quot;</span>, wordList);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)<em>O</em>(<em>n</em>)，其中 $n$ 为输入字符串的长度。</li><li>空间复杂度：O(n)<em>O</em>(<em>n</em>)，用来存储字符串分割之后的结果。</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> s.trim().split(<span class="regexp">/\s+/</span>).reverse().join(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>javascript</code>更是直接用一行代码就可以解决</p><h3 id="自行编写对应的函数">自行编写对应的函数</h3><p><img src="leetcode%E2%80%94%E5%AD%97%20699d8/Untitled%203.png" alt="Untitled"></p><p>复杂度分析</p><ul><li>时间复杂度：$O(n)$，其中 $n$ 为输入字符串的长度。</li><li>空间复杂度：Java 和 Python 的方法需要 $O(n)$的空间来存储字符串，而 C++ 方法只需要 $O(1)$的额外空间来存放若干变量。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = trimSpaces(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 翻转字符串</span></span><br><span class="line">        reverse(sb, <span class="number">0</span>, sb.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 翻转每个单词</span></span><br><span class="line">        reverseEachWord(sb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">trimSpaces</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 去掉字符串开头的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(left) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串末尾的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(right) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字符串间多余的空白字符去除</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(left);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sb.charAt(sb.length() - <span class="number">1</span>) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(StringBuilder sb, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = sb.charAt(left);</span><br><span class="line">            sb.setCharAt(left++, sb.charAt(right));</span><br><span class="line">            sb.setCharAt(right--, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseEachWord</span><span class="params">(StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = sb.length();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 循环至单词的末尾</span></span><br><span class="line">            <span class="keyword">while</span> (end &lt; n &amp;&amp; sb.charAt(end) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                ++end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 翻转单词</span></span><br><span class="line">            reverse(sb, start, end - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 更新start，去找下一个单词</span></span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">            ++end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-58-II-左旋转字符串-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串 - 力扣（LeetCode） (leetcode-cn.com)</a></h2><p>js一行代码完成，时间空间效率也不错，均为$O(n)$,KMP 暂时放一放了，考到了我认栽</p><h2 id="459-重复的子字符串-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/">459. 重复的子字符串 - 力扣（LeetCode） (leetcode-cn.com)</a></h2><p><strong>经典题</strong></p><p>这道题我使用了indexOf()的方法，js实现，时间不错，空间有点低</p><p><img src="leetcode%E2%80%94%E5%AD%97%20699d8/Untitled%204.png" alt="Untitled"></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> repeatedSubstringPattern = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;=<span class="built_in">Math</span>.floor(s.length/<span class="number">2</span>);i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> temp= s</span><br><span class="line">        <span class="keyword">if</span>(s.length % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(temp.indexOf(s.substring(<span class="number">0</span>,i)) == <span class="number">0</span>)&#123;</span><br><span class="line">                temp = temp.slice(i)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>即从零开始设置子串，子串长度最大为母串长度的一半，对于每次判断，依次在母串中去除子串，若可以去到空字符串，则返回真。</p><p>标准答案：</p><p><strong>方法一： 字符串匹配</strong></p><p>我们可以把字符串 $s$ 写成$s’s’ \cdots s’s’$的形式，总计 $\frac{n}{n’}$个 $s’$。但我们如何在不枚举 $n’$<br>′的情况下，判断 $s$ 是否能写成上述的形式呢？如果我们移除字符串 $s$的前 $n’$<br>个字符（即一个完整的 $s’$），再将这些字符保持顺序添加到剩余字符串的末尾，那么得到的字符串仍然是 $s$。由于 1 $\leq n’ &lt; n$，那么如果将两个 $s$ 连在一起，并移除第一个和最后一个字符，那么 $s$一定是它的一个子串。</p><p>因此我们可以考虑这种方法：我们将两个 $s$连在一起，并移除第一个和最后一个字符。如果 $s$是该字符串的子串，那么 $s$ 就满足题目要求。</p><p>下面证明其必要性：<strong>如果 $s$ 有这样的性质，那么 $s$ 满足题目要求</strong></p><p>一方面，如果长度为 $n$ 的字符串 $s$ 是字符串  $t=s+s$  的子串，并且 $s$ 在 $t$ 中的起始位置不为 $0$ 或 $n$，那么 $s$ 就满足题目的要求。证明过程如下：</p><p>我们设 $s$  在 $t$ 中的起始位置为 $i$，$i \in (0, n)$。也就是说，$t$ 中从位置 $i$ 开始的 $n$ 个连续的字符，恰好就是字符串 $s$ 。那么我们有：</p><p>$s[0:n-1] = t[i:n+i-1]$</p><p>由于 $t$ 是由两个 $s$  拼接而成的，我们可以将 $t[i:n+i-1]$ 分成位置 $n-1$左侧和右侧两部分：</p><p>$\left { \begin{aligned} s[0:n-i-1] &amp;= t[i:n-1] \ s[n-i:n-1] &amp;= t[n:n+i-1] = t[0:i-1] \end{aligned} \right.$</p><p>每一部分都可以对应回 $s$：</p><p>$\left { \begin{aligned} s[0:n-i-1] &amp;= s[i:n-1] \ s[n-i:n-1] &amp;= s[0:i-1] \end{aligned} \right.$</p><p>这说明，**s 是一个「可旋转」的字符串：将 $s$ 的前 $i$ 个字符保持顺序，移动到 $s$ 的末尾，得到的新字符串与 $s$ 相同。**也就是说，在模 $n$ 的意义下，</p><p>$s[j] = s[j+i]$</p><p>对于任意的 $j$  恒成立。</p><p>**「在模 $n$ 的意义下」**可以理解为，所有的加法运算的结果都需要对 $n$ 取模，使得结果保持在 $[0, n)$中，这样加法就自带了「旋转」的效果。</p><p>如果我们不断地连写这个等式：</p><p>$s[j] = s[j+i] = s[j+2i] = s[j+3i] = \cdots$</p><p>那么所有满足 $j_0 = j + k \cdot i$的位置 $j_0$都有 $s[j] = s[j_0]$，$j$和 $j_0$在模 $i$ 的意义下等价。由于我们已经在模 $n$ 的意义下讨论这个问题，因此 $j$和 $j_0$在模 $\mathrm{gcd}(n, i)$的意义下等价，其中 $\mathrm{gcd}$表示最大公约数。也就是说，字符串 $s$ 中的两个位置如果在模 $\mathrm{gcd}(n, i)$的意义下等价，那么它们对应的字符必然是相同的。</p><p>由于 $\mathrm{gcd}(n, i)$ 一定是 $n$ 的约数，那么字符串 $s$ 一定可以由其长度为 $\mathrm{gcd}(n, i)$的前缀重复 $\frac{n}{\mathrm{gcd}(n, i)}$次构成。</p><p>另一方面，如果 $s$满足题目的要求，那么 $s$ 包含若干个「部分」，$t=s+s$包含两倍数量的「部分」，因此 $s$ 显然是 $t$的子串，并且起始位置可以不为 0 或 $n$：我们只需要选择 $t$ 中第一个「部分」的起始位置即可。</p><p>还有一个更好理解的版本：</p><p>解题思路<br>如果您的字符串 S 包含一个重复的子字符串，那么这意味着您可以多次 “移位和换行”`您的字符串，并使其与原始字符串匹配。</p><p>例如：abcabc</p><p>移位一次：cabcab<br>移位两次：bcabca<br>移位三次：abcabc</p><p>现在字符串和原字符串匹配了，所以可以得出结论存在重复的子串。</p><p>基于这个思想，可以每次移动k个字符，直到匹配移动 length - 1 次。但是这样对于重复字符串很长的字符串，效率会非常低。在 LeetCode 中执行时间超时了。</p><p>为了避免这种无用的环绕，可以创建一个新的字符串 str，它等于原来的字符串 S 再加上 S 自身，这样其实就包含了所有移动的字符串。</p><p>比如字符串：S = acd，那么 str = S + S = acdacd</p><p>acd 移动的可能：dac、cda。其实都包含在了 str 中了。就像一个滑动窗口</p><p>一开始 acd (acd) ，移动一次 ac(dac)d，移动两次 a(cda)cd。循环结束</p><p>所以可以直接判断 str 中去除首尾元素之后，是否包含自身元素。如果包含。则表明存在重复子串。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (s + s).indexOf(s, <span class="number">1</span>) != s.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript基础知识回顾</title>
      <link href="/2022/03/26/javascript/"/>
      <url>/2022/03/26/javascript/</url>
      
        <content type="html"><![CDATA[<h1>javascript学习之旅</h1><p>首先上学习参考网站</p><p><a href="https://zh.javascript.info/">现代 JavaScript 教程</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">JavaScript | MDN (mozilla.org)</a></p><p><a href="https://es6.ruanyifeng.com/">ES6 入门教程 - ECMAScript 6入门 (ruanyifeng.com)</a></p><p><a href="https://www.notion.so/ES6-4e8ce196ee664105876c7520079ce353">ES6 总结</a></p><h2 id="和"><code>==</code> 和 <code>===</code></h2><p><code>==</code>运算符称作“相等运算符”</p><p><code>===</code>运算符称作“严格相等运算符”或者“恒等运算符”</p><p>严格相等运算符首先计算其操作数的值，然后比较这两个值，比较过程中，<strong>没有任何类型转换</strong>：</p><ol><li>如果两个值类型不相等，则他们不想等。</li><li>如果其中一个值是NaN，或者两个值都是NaN，则他们不相等。<strong>NaN和其他任何值都是不相等的，包括本身</strong>。通过NaN!==NaN来判断NaN，只有在x为NaN的时候，这个表达式的值才是true.</li><li>如果两个值为字符串，且所含的对应位上的16位（注1）完全相等，则他们相等。也可以通过String.localeCompare()来比较字符串</li><li><ol start="4"><li>如果两个值指向同一个对象则他们是相等的。</li></ol></li></ol><p>相等运算符和严格相等运算符相似，但相等运算符的比较不严格。会进行一些类型转换</p><ol><li>如果两个操作数类型相等，则和严格相等操作比较规则一样</li><li>如果一个是null,另一个是undefined则他们相等</li><li>如果一个值是数字，另一个是字符串，先将字符串转化为数字，然后使用转换后的值进行比较</li><li>如果其中一个是true,则将其转换为1再进行比较。如果其中一个是false,则将其转换为0再进行比较。</li><li>如果一个值是对象，另一个是数字或字符串，则先将对象转换为原始值,然后进行比较。对象通过toString()方法或者valueOf()方法转换为原始值，js语言核心的内置类首先尝试使用valueOf(),再尝试使用toString(),除了日期类，日期类只是使用toString()转换。那些不是js语言核心的对象通过各自实现中定义的方法转换为原始值。</li></ol><h2 id="Map"><code>Map</code></h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map">Map - JavaScript | MDN (mozilla.org)</a></p><h3 id="Map的迭代">Map的迭代</h3><p><code>for..of</code>方法</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> myMap) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> myMap.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> myMap.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>forEach()</code>方法</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">myMap.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Call"><code>Call()</code></h2><p>call能重新设定上下文（this的指向），可以编写能够在不同对象上使用的方法。</p><p>接受参数为this指向的对象和调用的函数参数列表</p><h2 id="apply"><code>apply()</code></h2><p>apply()和call非常相似，不同之处是call()方法分别接受参数，但是apply()方法接受数组形式的参数</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">fullName</span>: <span class="function"><span class="keyword">function</span>(<span class="params">city, country</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName + <span class="string">&quot;,&quot;</span> + city + <span class="string">&quot;,&quot;</span> + country;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">firstName</span>:<span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&quot;Doe&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">person.fullName.apply(person1, [<span class="string">&quot;Oslo&quot;</span>, <span class="string">&quot;Norway&quot;</span>]);</span><br></pre></td></tr></table></figure><h3 id="Array-apply"><code>Array.apply()</code></h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">func.apply(thisArg, [argsArray])</span><br></pre></td></tr></table></figure><p>起因是在Vue文档中使用render重复渲染多个相同的组件的示例代码：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createElement(<span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    <span class="built_in">Array</span>.apply(<span class="literal">null</span>, &#123; <span class="attr">length</span>: <span class="number">20</span> &#125;).map(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> createElement(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>apply方法的第二个参数可以是类数组对象，对象<code>&#123;length: 2&#125;</code>就是一个类数组对象，因此其等价于：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 熟悉一点: &#123;length: 2&#125;作为Array.apply第二个参数等同于[undefined, undefined]作为Array.apply第二个参数</span></span><br><span class="line"><span class="built_in">Array</span>.apply(<span class="literal">null</span>, [<span class="literal">undefined</span>, <span class="literal">undefined</span>]);</span><br><span class="line"><span class="comment">// 2 再熟悉一点：apply方法的执行结果</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="literal">undefined</span>, <span class="literal">undefined</span>);</span><br><span class="line"><span class="comment">// 3 再再熟悉一点：Array方法直接调用和new方式调用等价</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="literal">undefined</span>, <span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure><p>那为何要写这么复杂呢？</p><p>map函数并不会遍历数组中没有初始化或者被delete的元素（有相同限制还有forEach, reduce方法）。OK，疑问到此终于真相大白了：写这么“复杂”就是为了实现：<strong>创建一个长度为20，且每个元素都被初始化的数组</strong><br>。这样map方法就可以循环20次了。</p><h2 id="数组常用方法">数组常用方法</h2><p><a href="https://zh.javascript.info/array-methods">数组方法 (javascript.info)</a></p><h3 id="用splice-精准删除元素">用<code>splice()</code>精准删除元素</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">arr.splice(start[, deleteCount, elem1, ..., elemN])</span><br></pre></td></tr></table></figure><p>从start开始删除deleteCount个元素，后面为替代的值</p><h3 id="slice-删除对应索引段元素"><code>slice()</code>删除对应索引段元素</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">arr.slice([start], [end])</span><br></pre></td></tr></table></figure><h3 id="concat"><code>concat()</code></h3><p>创建一个新数组，其中包含来自于其他数组和其他项的值。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">arr.concat(arg1, arg2...)</span><br></pre></td></tr></table></figure><p>它接受任意数量的参数 —— 数组或值都可以。</p><h3 id="forEach"><code>forEach()</code></h3><p>允许为数组的每个元素都运行一个函数。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... do something with item</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="indexOf-lastIndexOf-includes搜索数组"><code>indexOf</code>/<code>lastIndexOf</code>/<code>includes</code>搜索数组</h3><ul><li><code>arr.indexOf(item, from)</code> 从索引 <code>from</code> 开始搜索 <code>item</code>，如果找到则返回索引，否则返回 <code>1</code>。</li><li><code>arr.lastIndexOf(item, from)</code> —— 和上面相同，只是从右向左搜索。</li><li><code>arr.includes(item, from)</code> —— 从索引 <code>from</code> 开始搜索 <code>item</code>，如果找到则返回 <code>true</code>（译注：如果没找到，则返回 <code>false</code>）。</li></ul><p>请注意，这些方法使用的是严格相等 <code>===</code> 比较。所以如果我们搜索 <code>false</code>，会精确到的确是 <code>false</code> 而不是数字 <code>0</code>。</p><p>如果我们想检查是否包含某个元素，并且不想知道确切的索引，那么 <code>arr.includes</code> 是首选。</p><p>此外，<code>includes</code> 的一个非常小的差别是它能正确处理<code>NaN</code>，而不像 <code>indexOf/lastIndexOf</code>：</p><h3 id="find和findIndex-搜索对象数组中具有特定条件的对象"><code>find</code>和<code>findIndex</code> 搜索对象数组中具有特定条件的对象</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = arr.find(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果返回 true，则返回 item 并停止迭代</span></span><br><span class="line">  <span class="comment">// 对于假值（falsy）的情况，则返回 undefined</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex">arr.findIndex</a>方法（与 <code>arr.find</code>方法）基本上是一样的，但它返回找到元素的索引，而不是元素本身。并且在未找到任何内容时返回 <code>-1</code>。</p><h3 id="filter方法匹配对应条件的元素">filter方法匹配对应条件的元素</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> results = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果 true item 被 push 到 results，迭代继续</span></span><br><span class="line">  <span class="comment">// 如果什么都没找到，则返回空数组</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意filter不会对原数组产生修改，而是返回新的结果！</p><h3 id="修改数组（数组转换和数组排序">修改数组（数组转换和数组排序)</h3><p><strong><code>map</code></strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回新值而不是当前元素</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意map返回一个新的数组，而非直接在原数组上修改</p><p><strong><code>sort(fn)</code></strong></p><p>对数组进行 **原位（in-place）**排序，更改元素的顺序。**默认情况下被按字符串进行排序。**所以需要提供一个函数作为参数</p><p>实际上，比较函数只需要返回一个正数表示“大于”，一个负数表示“小于”。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">15</span> ];</span><br><span class="line"></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a - b; &#125;);</span><br><span class="line"></span><br><span class="line">alert(arr);  <span class="comment">// 1, 2, 15</span></span><br></pre></td></tr></table></figure><p>对于许多字母，最好使用 <code>str.localeCompare</code> 方法正确地对字母进行排序，例如 <code>Ö</code>。</p><p>例如，让我们用德语对几个国家/地区进行排序：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> countries = [<span class="string">&#x27;Österreich&#x27;</span>, <span class="string">&#x27;Andorra&#x27;</span>, <span class="string">&#x27;Vietnam&#x27;</span>];</span><br><span class="line"></span><br><span class="line">alert( countries.sort( <span class="function">(<span class="params">a, b</span>) =&gt;</span> a &gt; b ? <span class="number">1</span> : -<span class="number">1</span>) ); <span class="comment">// Andorra, Vietnam, Österreich（错的）</span></span><br><span class="line"></span><br><span class="line">alert( countries.sort( <span class="function">(<span class="params">a, b</span>) =&gt;</span> a.localeCompare(b) ) ); <span class="comment">// Andorra,Österreich,Vietnam（对的！）</span></span><br></pre></td></tr></table></figure><p><strong><code>reverse()</code> 颠倒元素顺序</strong></p><p><strong><code>split(delim)</code> 将字符串分割成数组</strong></p><p><strong><code>join(glue)</code> 数组粘合成字符串</strong></p><p><strong><code>reduce/reduceRight</code> 根据数组计算单个值（类似于累加器）</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, item, index, array</span>) </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;, [initial]);</span><br></pre></td></tr></table></figure><p>例子：</p><p>通过一行代码得到一个数组的总和：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = arr.reduce(<span class="function">(<span class="params">sum, current</span>) =&gt;</span> sum + current, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">alert(result); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><h3 id="Array-isArray">Array.isArray</h3><p>数组是基于对象的，不构成单独的语言类型。</p><p>所以 <code>typeof</code> 不能帮助从数组中区分出普通对象：</p><p>数组经常被使用，因此有一种特殊的方法用于判断：<a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray">Array.isArray(value)</a>。如果 <code>value</code>是一个数组，则返回 <code>true</code>；否则返回 <code>false</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode刷题笔记--排序算法</title>
      <link href="/2022/03/24/leetcode-3/"/>
      <url>/2022/03/24/leetcode-3/</url>
      
        <content type="html"><![CDATA[<h1>Leetcode—排序算法</h1><img src="Leetcode%E2%80%94%E6%8E%92%2072257/Untitled.png" alt="Untitled" style="zoom:67%;" /><img src="Leetcode%E2%80%94%E6%8E%92%2072257/Untitled%201.png" alt="Untitled" style="zoom:67%;" /><h2 id="shell排序">shell排序</h2><p><a href="https://www.runoob.com/data-structures/shell-sort.html">希尔排序 | 菜鸟教程 (runoob.com)</a></p><h2 id="快速排序">快速排序</h2><h2 id="堆排序">堆排序</h2><p><a href="https://www.cnblogs.com/chengxiao/p/6129630.html">图解排序算法(三)之堆排序 - dreamcatcher-cx - 博客园 (cnblogs.com)</a></p><p>再简单总结下堆排序的基本思路：</p><p><strong>a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong></p><p><strong>b.将堆顶元素与末尾元素交换，将最大元素&quot;沉&quot;到数组末端;</strong></p><p><strong>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []arr = &#123;<span class="number">7</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前：&quot;</span>+Arrays.toString(arr));</span><br><span class="line">        sort(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前：&quot;</span>+Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.构建大顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//从第一个非叶子结点从下至上，从右至左调整结构</span></span><br><span class="line">            adjustHeap(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=arr.length-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            swap(arr,<span class="number">0</span>,j);<span class="comment">//将堆顶元素与末尾元素进行交换</span></span><br><span class="line">            adjustHeap(arr,<span class="number">0</span>,j);<span class="comment">//重新对堆进行调整</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];<span class="comment">//先取出当前元素i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=i*<span class="number">2</span>+<span class="number">1</span>;k&lt;length;k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;<span class="comment">//从i结点的左子结点开始，也就是2i+1处开始</span></span><br><span class="line">            <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; arr[k]&lt;arr[k+<span class="number">1</span>])&#123;<span class="comment">//如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[k] &gt;temp)&#123;<span class="comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span></span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                i = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;<span class="comment">//将temp值放到最终的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="215-数组中的第K个最大元素-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素 - 力扣（LeetCode） (leetcode-cn.com)</a></h3><p>本题我采用的是堆排序，堆排序代码不熟悉，所以写了很多遍才写对。</p><p>本题是面试的高频考题，以下几种方法必须掌握</p><p>题解给出了以下几种方法：</p><p><strong>方法一</strong> <strong>基于随机快速排序的方法</strong></p><p>其实如果直接使用java的<code>Arrays.sort</code>，java默认使用快速排序，时间复杂度：O(N \log N)O(NlogN)，这里 NN 是数组的长度，算法的性能消耗主要在排序，JDK 默认使用快速排序，因此时间复杂度为 O(N \log N)O(NlogN)；</p><p>我们在学习「快速排序」的时候，会学到 partition（切分），通过 partition 操作使得：对于某个下标 j，nums[j] 已经排定，即 nums[j] 经过 partition（切分）操作以后会放置在它「最终应该放置的地方」。而且：</p><p>nums[left] 到 nums[j - 1] 中的所有元素都不大于 nums[j]；<br>nums[j + 1] 到 nums[right] 中的所有元素都不小于 nums[j]。</p><p><strong>注意：本题必须随机初始化 pivot 元素，否则通过时间会很慢，因为测试用例中有极端测试用例。为了应对极端测试用例，使得递归树加深，可以在循环一开始的时候，随机交换第 11 个元素与它后面的任意 11 个元素的位置；</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> target = len - k;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = partition(nums, left, right);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; target) &#123;</span><br><span class="line">                left = index + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; target) &#123;</span><br><span class="line">                right = index - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在区间 nums[left..right] 区间执行 partition 操作</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在区间随机选择一个元素作为标定点</span></span><br><span class="line">        <span class="keyword">if</span> (right &gt; left) &#123;<span class="comment">//特别注意这一步大小判断一定要做，不然当数组长度为1时就报错了</span></span><br><span class="line">            <span class="keyword">int</span> randomIndex = left + <span class="number">1</span> + random.nextInt(right - left);</span><br><span class="line">            swap(nums, left, randomIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line">        <span class="keyword">int</span> j = left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                swap(nums, j, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, left, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>方法二：基于堆排序的选择方法</strong></p><p>我们也可以使用堆排序来解决这个问题——建立一个大根堆，做 k - 1k−1 次删除操作后堆顶元素就是我们要找的答案。在很多语言中，都有优先队列或者堆的的容器可以直接使用，但是在面试中，面试官更倾向于让更面试者自己实现一个堆。所以建议读者掌握这里大根堆的实现方法，在这道题中尤其要搞懂「建堆」、「调整」和「删除」的过程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> heapSize = nums.length;</span><br><span class="line">        buildMaxHeap(nums, heapSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= nums.length - k + <span class="number">1</span>; --i) &#123;</span><br><span class="line">            swap(nums, <span class="number">0</span>, i);</span><br><span class="line">            --heapSize;</span><br><span class="line">            maxHeapify(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = heapSize / <span class="number">2</span>-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxHeapify(a, i, heapSize);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = i * <span class="number">2</span> + <span class="number">1</span>, r = i * <span class="number">2</span> + <span class="number">2</span>, largest = i;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; heapSize &amp;&amp; a[l] &gt; a[largest]) &#123;</span><br><span class="line">            largest = l;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; a[r] &gt; a[largest]) &#123;</span><br><span class="line">            largest = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(a, i, largest);</span><br><span class="line">            maxHeapify(a, largest, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="桶排序">桶排序</h2><p>快速排序是将集合拆分为两个值域，这里称为两个桶，再分别对两个桶进行排序，最终完成排序。桶排序则是将集合拆分为多个桶，对每个桶进行排序，则完成排序过程。两者不同之处在于，快排是在集合本身上进行排序，属于原地排序方式，且对每个桶的排序方式也是快排。</p><p>桶排序则是提供了额外的操作空间，在额外空间上对桶进行排序，避免了构成桶过程的元素比较和交换操作，同时可以自主选择恰当的排序算法对桶进行排序。当然桶排序更是对计数排序的改进，计数排序申请的额外空间跨度从最小元素值到最大元素值，若待排序集合中元素不是依次递增的，则必然有空间浪费情况。桶排序则是弱化了这种浪费情况，将最小值到最大值之间的每一个位置申请空间，更新为最小值到最大值之间每一个固定区域申请空间，尽量减少了元素值大小不连续情况下的空间浪费情况。</p><h3 id="算法过程"><strong>算法过程</strong></h3><ol><li>根据待排序集合中最大元素和最小元素的差值范围和映射规则，确定申请的桶个数；</li><li>遍历待排序集合，将每一个元素移动到对应的桶中；</li><li>对每一个桶中元素进行排序，并移动到已排序集合中。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketSort</span> <span class="keyword">implements</span> <span class="title">IArraySort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InsertSort insertSort = <span class="keyword">new</span> InsertSort();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bucketSort(arr, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] bucketSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> bucketSize) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minValue = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; minValue) &#123;</span><br><span class="line">                minValue = value;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; maxValue) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> bucketCount = (<span class="keyword">int</span>) Math.floor((maxValue - minValue) / bucketSize) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[bucketCount][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用映射函数将数据分配到各个桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = (<span class="keyword">int</span>) Math.floor((arr[i] - minValue) / bucketSize);</span><br><span class="line">            buckets[index] = arrAppend(buckets[index], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> arrIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对每个桶进行排序，这里使用了插入排序</span></span><br><span class="line">            bucket = insertSort.sort(bucket);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> value : bucket) &#123;</span><br><span class="line">                arr[arrIndex++] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动扩容，并保存数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arrAppend(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bucketSort</span>(<span class="params">arr, bucketSize</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i;</span><br><span class="line">    <span class="keyword">var</span> minValue = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; minValue) &#123;</span><br><span class="line">          minValue = arr[i];                <span class="comment">// 输入数据的最小值</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; maxValue) &#123;</span><br><span class="line">          maxValue = arr[i];                <span class="comment">// 输入数据的最大值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//桶的初始化</span></span><br><span class="line">    <span class="keyword">var</span> DEFAULT_BUCKET_SIZE = <span class="number">5</span>;            <span class="comment">// 设置桶的默认数量为5</span></span><br><span class="line">    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;</span><br><span class="line">    <span class="keyword">var</span> bucketCount = <span class="built_in">Math</span>.floor((maxValue - minValue) / bucketSize) + <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">var</span> buckets = <span class="keyword">new</span> <span class="built_in">Array</span>(bucketCount);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        buckets[i] = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用映射函数将数据分配到各个桶中</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        buckets[<span class="built_in">Math</span>.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr.length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        insertionSort(buckets[i]);                      <span class="comment">// 对每个桶进行排序，这里使用了插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; buckets[i].length; j++) &#123;</span><br><span class="line">            arr.push(buckets[i][j]);                      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="347-前-K-个高频元素-前-K-个高频元素-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/solution/leetcode-di-347-hao-wen-ti-qian-k-ge-gao-pin-yuan-/">347. 前 K 个高频元素 - 前 K 个高频元素 - 力扣（LeetCode） (leetcode-cn.com)</a></h3><p>当时用的是暴力法，没有解决。</p><p><strong>方法一： 使用堆排序</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; fregMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            fregMap.put(num,fregMap.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//完成哈希表的创建</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a,Integer b)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> fregMap.get(a) - fregMap.get(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: fregMap.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(pq.size()&lt;k)&#123;</span><br><span class="line">                pq.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(fregMap.get(num) &gt; fregMap.get(pq.peek()))&#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">                pq.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">int</span> count = k-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            result[count--] = pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="451-根据字符出现频率排序-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">451. 根据字符出现频率排序 - 力扣（LeetCode） (leetcode-cn.com)</a></h3><p>这道题最开始做的时候参照了k频元素题的堆排序做法，将哈希表存入堆中，直接返回堆中的元素即可。但是结果下来速度好像很慢</p><p><strong>注意语法还不熟练！</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,Integer&gt; freqMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            String aStr = <span class="keyword">new</span> String(String.valueOf(s.charAt(i)));</span><br><span class="line">            freqMap.put(aStr,freqMap.getOrDefault(aStr,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;String&gt; fq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a,String b)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> freqMap.get(b) - freqMap.get(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(String a: freqMap.keySet())&#123;</span><br><span class="line">            fq.add(a);</span><br><span class="line">        &#125;</span><br><span class="line">        String result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(!fq.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; freqMap.get(fq.peek());i++)&#123;</span><br><span class="line">                result += fq.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            fq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标答同样使用了桶排序的思想，首先将字母出现的频率存入到Map中，然后使用桶，桶的数组下标为元素的出现频率，对应值为出现该频率的字符，然后逆序分别组合字符串输出，注意的是凡是需要对字符串修改的，应该使用StringBuffer而非String</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; freqMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> maxCount= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> count = freqMap.getOrDefault(ch,<span class="number">0</span>);</span><br><span class="line">            freqMap.put(ch,++count);</span><br><span class="line">            maxCount = Math.max(maxCount, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//完成哈希表的构建,获得最大频率maxCount</span></span><br><span class="line">        <span class="comment">//构建桶</span></span><br><span class="line">        StringBuilder[] bucket = <span class="keyword">new</span> StringBuilder[maxCount + <span class="number">1</span>]; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;bucket.length; i++)&#123;</span><br><span class="line">            bucket[i] = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Character,Integer&gt; entry : freqMap.entrySet())&#123;</span><br><span class="line">            <span class="keyword">int</span> index = entry.getValue();</span><br><span class="line">            <span class="keyword">char</span> ch = entry.getKey();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;index; i++)&#123;</span><br><span class="line">                bucket[index].append(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//完成桶的构建</span></span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = bucket.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bucket[i].length() != <span class="number">0</span>)</span><br><span class="line">                result.append(bucket[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="荷兰国旗问题">荷兰国旗问题</h2><h3 id="75-颜色分类-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/sort-colors/description/">75. 颜色分类 - 力扣（LeetCode） (leetcode-cn.com)</a></h3><p>我当时想的方法很nt，就是一趟扫描统计三个数字的字数，一趟直接修改对应的数字，然后居然100%了</p><p>然后我又想到将1作为基准数字的快速排序，代码如下，代码写了很久，可见对快速排序的代码不够熟悉</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        quickSort(nums, <span class="number">0</span> ,nums.length -<span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left , <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = partition(nums,left , right);</span><br><span class="line">        quickSort(nums,left,index - <span class="number">1</span>);</span><br><span class="line">        quickSort(nums,index + <span class="number">1</span>,right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] =temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在区间随机选择一个元素作为标定点</span></span><br><span class="line">    <span class="keyword">int</span> index = left;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)</span><br><span class="line">            index = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line">    <span class="keyword">int</span> j = left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">            j++;</span><br><span class="line">            swap(nums, j, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, left, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/sort-colors/solution/yan-se-fen-lei-by-leetcode-solution/">颜色分类 - 颜色分类 - 力扣（LeetCode） (leetcode-cn.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue2.x学习总结</title>
      <link href="/2022/03/21/vue2-x/"/>
      <url>/2022/03/21/vue2-x/</url>
      
        <content type="html"><![CDATA[<h1>Vue2.x笔记总结</h1><p>以下笔记来从《Vue.js实战》一书整理总结</p><h1>一 数据绑定</h1><p>el用于指定一个页面中已经存在的DOM元素来挂载Vue示例，可以是HTMLElement也可以是CSS选择器。</p><h3 id="插值表达式">插值表达式</h3><ol><li><p>想输出html而非纯文本，使用v-html(有可能导致XSS攻击)</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;link&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>想显示<code>&#123;&#123;&#125;&#125;</code>标签，可以使用<code>v-pre</code></p></li><li><p>支持单个javascript表达式计算</p></li></ol><h3 id="过滤器filters">过滤器filters</h3><p>在插值表达式尾部加 | 表示对数据进行过滤，但是如果要实现更为复杂的数据变换，则应该使用计算属性</p><h3 id="指令与事件">指令与事件</h3><ol><li><code>v-bind</code> 动态更新Html元素上的属性，如id,class等 <code>&lt;img v-bind:src=””imgUrl&gt;</code></li><li><code>v-on</code>  绑定事件监听器 ，如<code>v-on:click</code> 表达式可以是函数或内联语句</li></ol><h1>二 计算属性</h1><h3 id="computed"><code>computed</code></h3><p>某些计算起来较为麻烦的属性以函数的形式写在Vue实例内的computed选项内，最终返回计算后的结果。<strong>重点是最后一定要返回一个结果。</strong></p><p>如一个标签显示购物车总价格，该值需要其他很多地方的值相加，这里需要用到计算属性：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123; prices &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript"><span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript"><span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="javascript">...</span></span><br><span class="line"><span class="javascript">&#125;,</span></span><br><span class="line"><span class="javascript"><span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="javascript"><span class="attr">prices</span>: &#123;</span></span><br><span class="line"><span class="javascript"><span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">return</span> ...</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">...</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>什么时候执行setter?比如当调用<code>app.prices = 100</code></p><h3 id="computed的作用：">computed的作用：</h3><ol><li>文本插值</li><li>动态设置元素的样式名称class和内联样式style</li><li>动态传递props</li></ol><h3 id="使用methods也可以达到相同的目的，为什么还会有computed">使用methods也可以达到相同的目的，为什么还会有computed?</h3><p>因为computed的计算属性是<strong>依赖于它的缓存</strong>的，就是说只有当依赖的数据发生变化时，才会重新取值，而若放在methods里则是只要页面重新渲染，函数就会被调用。</p><h1>三 <code>v-bind</code>及class与style绑定</h1><h2 id="绑定class的几种方法">绑定class的几种方法</h2><h3 id="对象语法">对象语法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;&#x27;active&#x27;: isActive&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过data:isActive来决定是否拥有类名active</p><p>可以与普通的clas共存</p><p>同时若属性过长就可以绑定一个计算属性，属性内返回一个对象，对象内的元素做相应的计算</p><h3 id="数组语法">数组语法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[isActive? activeCls : &#x27;&#x27;, errorCls]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">el = <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line"><span class="attr">isActive</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">activeCls</span>: <span class="string">&#x27;active&#x27;</span>,</span><br><span class="line"><span class="attr">errorCls</span>: <span class="string">&#x27;error&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>和对象语法一样，也可以配合<strong>data,computed,methods</strong>三种方法，比如如下的代码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">:class</span> = <span class="string">&quot;classes&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">size</span>: <span class="string">&#x27;large&#x27;</span>,</span><br><span class="line">        <span class="attr">disabled</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">computed</span>: &#123;</span><br><span class="line">        <span class="attr">classes</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> [</span><br><span class="line">                <span class="string">&#x27;btn&#x27;</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                    [<span class="string">&#x27;btn-&#x27;</span> + <span class="built_in">this</span>.size]: <span class="built_in">this</span>.size != <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                    [<span class="string">&#x27;btn-disabled&#x27;</span>]: <span class="built_in">this</span>.disabled</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="绑定内联样式">绑定内联样式</h2><p>可以使用<code>:style=”&#123;...&#125;”</code>类似的语法绑定内联样式，同时也支持对象语法和数组语法。</p><h1>四 内置指令</h1><h3 id="v-once"><code>v-once</code></h3><p>不需要表达式的指令，作用是定义它的元素或组件只渲染依次，包括元素或组件的所有子节点，被视为静态内容。</p><h2 id="条件渲染指令">条件渲染指令</h2><h3 id="v-if-v-else-if-v-else"><code>v-if</code>,<code>v-else-if</code>,<code>v-else</code></h3><p>三个指令紧跟，和js语法类似，当表达式为真时，当前元素、组件及子节点被渲染</p><p>vue在渲染元素时，出于效率考虑会尽可能复用已有的元素而非重新渲染，否则可以加入<code>key=”唯一的值”</code>到不想被复用的元素中</p><h3 id="v-show"><code>v-show</code></h3><p>只是改变css属性display</p><h3 id="v-if和v-show如何选择"><code>v-if</code>和<code>v-show</code>如何选择</h3><p><code>v-if</code>适合条件不经常改变的场景，因为切换开销相对较大，而<code>v-show</code>适合频繁切换条件。</p><h2 id="列表渲染指令v-for">列表渲染指令<code>v-for</code></h2><h3 id="常见语法">常见语法</h3><p><code>v-for=”(item,index) in items”</code></p><p><code>v-for=”(value,key,index) in user”</code></p><p>对对象的遍历，其中value是对象的值，key是对象的键，index是索引</p><h3 id="数组更新">数组更新</h3><p>配合js <code>filter(),concat(),slice()</code>实现更高级的用法，如数组内的搜索结果筛选匹配。</p><p>注意如果直接用索引更改重置项，Vue无法检测到，如</p><p><code>app.books[3]=...</code></p><p>应该使用Vue内置的set语法：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">Vue.set(app.books,<span class="number">3</span>,&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;1&#x27;</span>,</span><br><span class="line"><span class="attr">author</span>:<span class="string">&#x27;www&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>若使用webpack,应使用<code>this.$set</code></p><h3 id="过滤与排序">过滤与排序</h3><p>**比如在某一json文件中的搜索和结果展示，**不想改变原数组，想通过一个数组的副本来做过滤或排序是，可以使用计算属性来返回过滤或排序后的数组。</p><h2 id="方法与事件">方法与事件</h2><h3 id="v-on-click-click"><code>v-on:click</code> / <code>@click</code></h3><p>可以使用<code>$event</code> 用于原生访问DOM事件，如</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;handleClick(&#x27;禁止打开&#x27;,$event)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">handleClick: <span class="function"><span class="keyword">function</span>(<span class="params">message, event</span>)</span>&#123;</span><br><span class="line">event.preventDefault()</span><br><span class="line"><span class="built_in">window</span>.alert(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修饰符-2">修饰符</h3><ul><li>.stop</li><li>.prevent</li><li>.capture</li><li>.self</li><li>.once</li></ul><h1>五 表单与<code>v-model</code></h1><h2 id="基本用法">基本用法</h2><p>v-model 是vue双向数据绑定的体现，被用于表单上的双向绑定数据</p><p><strong>用v-model实现互斥选择</strong></p><p>只要v-model内的值与value值一致时，就会选中该项</p><p><strong>复选框的组合使用（多选框）</strong></p><p>v-model和value值同时使用，v-model内存储被选中的value数组，当选中状态改变时，数组也会动态改变</p><p><strong>除此以外，还可以实现选择菜单的单选和复选</strong></p><h2 id="修饰符-3">修饰符</h2><h3 id="v-model-lazy"><code>v-model.lazy</code></h3><p>数据不是实时改变，而是按回车或失焦时才更新</p><h3 id="v-model-number"><code>v-model.number</code></h3><p>将输入转化为Number类型</p><h3 id="v-model-trim"><code>v-model.trim</code></h3><p>自动过滤输入的首尾空格</p><h1>六 组件</h1><h2 id="组件注册">组件注册</h2><p>组件有全局注册和局部注册两种方式：</p><h3 id="全局注册">全局注册</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-component&#x27;</span>,&#123;</span><br><span class="line"><span class="comment">//选项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(<span class="string">&#x27;my-component&#x27;</span>,&#123;</span><br><span class="line">        <span class="attr">template</span>:<span class="string">&#x27;&lt;div&gt;组件内容&lt;/div&gt;&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>要在父示例中引用这个组件，必须要在定义示例之前注册</p><h3 id="局部注册">局部注册</h3><p>使用<code>vue.components</code>实现局部的注册，在脚手架开发中常用</p><p>但是vue的组件在某些情况下会收到HTML的限制，如<code>&lt;table&gt;</code>内规定只能是<code>&lt;tr&gt;</code> <code>&lt;td&gt;</code> <code>&lt;th&gt;</code>这些元素，因此使用如下语法is:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;div is=<span class="string">&quot;my-component&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>注意:在组件中定义的data必须要写成函数的形式，且数据作为返回值！为什么？</strong></p><p>因为若将data做为对象，则由于javascript的引用关系，对象共享，任何一个引用的地方修改都会同步。</p><h3 id="props传递数据">props传递数据</h3><p>父组件向子组件传递数据使用props,在子组件使用props声明要从父组件接收的数据</p><p><strong>单向数据流： Vue2.x和Vue1.x一个比较大的改变就是，Vue2.x通过props传递数据是单向的了，也就是父组件数据变化时会传递给子组件，但是反过来不行</strong></p><p>官方文档如是说：</p><blockquote><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。</p></blockquote><blockquote><p>额外的，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p></blockquote><p>这里有两种常见的试图变更一个 prop 的情形：</p><ol><li><p>**这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。**在这种情况下，最好定义一个本地的 data property 并将这个 prop 用作其初始值：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">&#x27;initialCounter&#x27;</span>],</span><br><span class="line"><span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">counter</span>: <span class="built_in">this</span>.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>**这个 prop 以一种原始的值传入且需要进行转换。**在这种情况下，最好使用这个 prop 的值来定义一个计算属性：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">&#x27;size&#x27;</span>],</span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="attr">normalizedSize</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Props数据验证">Props数据验证</h3><p>当props数据需要验证时使用对象写法，语法如下：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">            <span class="attr">propA</span>:&#123;</span><br><span class="line">                <span class="attr">type</span>:[<span class="built_in">String</span>, <span class="built_in">Number</span>, <span class="built_in">Object</span>, <span class="built_in">Function</span>, <span class="built_in">Boolean</span>, <span class="built_in">Array</span>],<span class="comment">//支持这些类型</span></span><br><span class="line">                <span class="attr">default</span>: <span class="string">&quot;true&quot;</span>,<span class="comment">//默认值</span></span><br><span class="line">                <span class="attr">required</span>: <span class="literal">true</span>,<span class="comment">//是否必须（必传）</span></span><br><span class="line">                <span class="attr">validater</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;<span class="comment">//自定义验证函数</span></span><br><span class="line">                    <span class="keyword">return</span> value &gt; <span class="number">10</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="★组件通信">★组件通信</h2><p>父子组件通信，兄弟组件通信，跨级组件通信</p><h3 id="自定义事件">自定义事件</h3><p>子组件向父组件传递数据时，使用<code>$emit</code>传递，类似于javascript中<code>addEventListener</code>中的<strong>观察者模式</strong>，父组件在子组件中自定义标签v-on来监听子组件触发的自定义事件</p><p>示例：实现一个双向数据绑定的v-model组件，需要满足以下要求：</p><ol><li>接收一个value属性</li><li>在有新的value时触发input事件</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;total&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-model</span>=<span class="string">&quot;total&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;handleReduce&quot;</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">&#x27;my-component&#x27;</span>,&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>:<span class="string">&#x27;&lt;input :value=&quot;value&quot; @input=&quot;updateValue&quot;&gt;&lt;/input&gt;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">props</span>: [<span class="string">&#x27;value&#x27;</span>],</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">updateValue</span>: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.$emit(<span class="string">&#x27;input&#x27;</span>,event.target.value)</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">total</span>:<span class="number">0</span></span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">handleReduce</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.total--;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="非父子组件之间通信">非父子组件之间通信</h3><p>Vue2.x废弃了Vue1.x中的<code>$dispatch</code>和<code>$broadcast</code>方法，而使用一个空的Vue示例作为中央事件总线<strong>EventBus</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> bus = <span class="keyword">new</span> Vue()</span></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">&#x27;my-component&#x27;</span>,&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>:<span class="string">&#x27;&lt;button @click=&quot;handleEvent&quot;&gt;&lt;/button&gt;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">handleEvent</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                bus.$emit(<span class="string">&#x27;on-message&#x27;</span>, <span class="string">&#x27;来自子组件的内容&#x27;</span>)</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">message</span>: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">mounted</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> _this = <span class="built_in">this</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//示例初始化时，监听来自bus的事件</span></span></span><br><span class="line"><span class="javascript">            bus.$on(<span class="string">&#x27;on-message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                _this.message = msg</span></span><br><span class="line"><span class="javascript">            &#125;)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>步骤</p><ol><li>创建名为bus的空Vue实例</li><li>在app初始化时，也就是在生命周期mounted钩子函数里监听了来自bus的事件on-message，而在子组件中，按钮通过bus把事件发布出去</li></ol><h3 id="eventBus的应用">eventBus的应用</h3><p>可以在空实例中定义data,method，computed,共享一些通用的信息，比如昵称，性别和邮箱等等，还有用户授权的token等</p><h3 id="父链">父链</h3><p>通过<code>this.$parent</code>和<code>this.$children</code>可以直接访问或修改父组件或子组件的数据，并且可以递归，但是不建议这样做，还是使用<code>props</code>和<code>$emit</code>较好</p><h3 id="子组件索引ref">子组件索引<code>ref</code></h3><p>递归调用不方便时，可以使用子组件索引</p><p>用法：</p><p>调用的子组件声明内加入 <code>ref=”comA”</code></p><p>父组件调用时使用<code>this.$ref.comA</code></p><p>缺点：<strong>非响应式的</strong></p><h2 id="使用slot分发内容">使用<code>slot</code>分发内容</h2><p>子组件加入<code>&lt;slot&gt;&lt;/slot&gt;</code>即可开启一个插槽</p><h3 id="具名slot">具名<code>slot</code></h3><p>在父组件中的子组件中加入<code>&lt;div slot=”name”&gt;&lt;/div&gt;</code>即可使用具名slot</p><h3 id="作用域slot">作用域<code>slot</code></h3><p>使用一个可复用的模板来替换已渲染元素</p><p>可以实现slot内容不一致，内容由使用组件的人决定</p><p>记住Vue官网给出的一句话：</p><blockquote><p><strong>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</strong></p></blockquote><p><a href="https://cn.vuejs.org/v2/guide/components-slots.html">插槽 — Vue.js (vuejs.org)</a></p><h2 id="组件高级用法">组件高级用法</h2><h3 id="递归组件">递归组件</h3><p>常用于开发级联选择器和树形控件</p><h3 id="动态组件">动态组件</h3><h3 id="异步组件">异步组件</h3><p>当工程足够大时，一开始将所有的组件都加载是一个没有必要的开销。Vue.js组件允许将组件定义为一个工厂函数，动态解析组件</p><h3 id="nextTick-异步更新队列"><code>$nextTick</code> 异步更新队列</h3><p>一个场景，一个<code>div</code>默认<code>v-if</code>隐藏，按钮点击属性变为true,此时想要获取div的内容时获取不到的，因为此时Dom还没有更新，这是因为Vue一个优化性能的机制：<strong>异步更新队列</strong></p><p><strong>Vue观察数据变化时并不是直接更新DOM，而是开启一个队列，并缓冲在同一事件循环中的所有数据改变。在缓冲时会去除重复数据，从而避免计算不必要的DOM操作。在下一个事件循环Tick中，Vue刷新队列并执行实际的工作（已经去重的）因此使用$nextTick就是用来知道Dom时是什么时候更新完成的</strong></p><p>比如按钮按下<code>v-if</code>属性翻转后想要获取该部分<code>div</code>的内容，应该这么写：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">getText: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.showDiv = <span class="literal">true</span></span><br><span class="line"><span class="built_in">this</span>.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> text = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div&#x27;</span>).innerHTML</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实战——标签页组件（slot插槽的应用）">实战——标签页组件（<code>slot</code>插槽的应用）</h2><p><img src="Vue2%20x%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93%20854c6/Untitled.png" alt="Untitled"></p><p><strong>重点关注：</strong></p><ol><li>为什么这里每个tab的类没用用计算属性而是用method,因为这里用到了<code>item</code>参数，而计算属性无法用参数，所以才用到methods</li></ol><p>代码：</p><ol><li><code>index.html</code></li><li><code>style.css</code></li><li><code>tabs.css</code></li><li><code>pane.css</code></li></ol><p><code>index.html</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>标签页组件<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;Stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span> <span class="attr">v-cloak</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tabs</span> <span class="attr">v-model</span> = <span class="string">&quot;activeKey&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pane</span> <span class="attr">label</span>=<span class="string">&quot;标签一&quot;</span> <span class="attr">name</span> = <span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">                标签一的内容</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pane</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pane</span> <span class="attr">label</span>=<span class="string">&quot;标签二&quot;</span> <span class="attr">name</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">                标签二的内容</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pane</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pane</span> <span class="attr">label</span>=<span class="string">&quot;标签三&quot;</span> <span class="attr">name</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">                标签三</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pane</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tabs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;pane.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;tabs.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">activeKey</span>: <span class="string">&#x27;1&#x27;</span></span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;)</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>tab.js</code></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;tabs&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;\</span></span><br><span class="line"><span class="string">    &lt;div class = &quot;tabs&quot;&gt;\</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;tab-bar&quot;&gt;\</span></span><br><span class="line"><span class="string">            &lt;!--标签页标题，这里用v-for--&gt;\</span></span><br><span class="line"><span class="string">            &lt;div\</span></span><br><span class="line"><span class="string">                :class=&quot;tabCls(item)&quot;\</span></span><br><span class="line"><span class="string">                v-for=&quot;(item,index) in navList&quot;\</span></span><br><span class="line"><span class="string">                @click = &quot;handleChange(index)&quot;&gt;\</span></span><br><span class="line"><span class="string">                &#123;&#123; item.label &#125;&#125;\</span></span><br><span class="line"><span class="string">            &lt;/div&gt;\</span></span><br><span class="line"><span class="string">        &lt;/div&gt;\</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;tabs-content&quot;&gt;\</span></span><br><span class="line"><span class="string">            &lt;!--嵌套的pane--&gt;\</span></span><br><span class="line"><span class="string">            &lt;slot&gt;&lt;/slot&gt;\</span></span><br><span class="line"><span class="string">        &lt;/div&gt;\</span></span><br><span class="line"><span class="string">    &lt;/div&gt;&#x27;</span>,</span><br><span class="line">    <span class="attr">props</span>:&#123;</span><br><span class="line">        <span class="comment">//这里使用value是为了可以使用v-model</span></span><br><span class="line">        <span class="attr">value</span>:&#123;</span><br><span class="line">            <span class="attr">type</span>: [<span class="built_in">String</span>, <span class="built_in">Number</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="comment">//用于渲染tabs的标题</span></span><br><span class="line">            <span class="attr">navList</span>: [],</span><br><span class="line">            <span class="attr">currentValue</span>: <span class="built_in">this</span>.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="attr">tabCls</span>: <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span>[</span><br><span class="line">                <span class="string">&#x27;tabs-tab&#x27;</span>,&#123;</span><br><span class="line">                    <span class="comment">//给当前选中的tab加一个class</span></span><br><span class="line">                    <span class="string">&#x27;tabs-tab-active&#x27;</span>: item.name === <span class="built_in">this</span>.currentValue</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//点击tab标题时触发</span></span><br><span class="line">        <span class="attr">handleChange</span>: <span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> nav = <span class="built_in">this</span>.navList[index]</span><br><span class="line">            <span class="keyword">var</span> name = nav.name<span class="comment">//改变当前选中的tab，并触发下面的watch</span></span><br><span class="line">            <span class="built_in">this</span>.currentValue = name</span><br><span class="line">            <span class="comment">//更新value</span></span><br><span class="line">            <span class="built_in">this</span>.$emit(<span class="string">&#x27;input&#x27;</span>, name)</span><br><span class="line">            <span class="comment">//触发一个自定义事件，供父级使用</span></span><br><span class="line">            <span class="built_in">this</span>.$emit(<span class="string">&#x27;on-click&#x27;</span>, name)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">getTabs</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//遍历子组件，得到所有的panes组件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.$children.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> item.$options.name === <span class="string">&#x27;pane&#x27;</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">updateNav</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.navList = []</span><br><span class="line">            <span class="comment">//在function回调里，this指向的不是vue实例</span></span><br><span class="line">            <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">            <span class="built_in">this</span>.getTabs().forEach(<span class="function"><span class="keyword">function</span>(<span class="params">pane,index</span>)</span>&#123;</span><br><span class="line">                _this.navList.push(&#123;</span><br><span class="line">                    <span class="attr">label</span>: pane.label,</span><br><span class="line">                    <span class="attr">name</span>: pane.name || index</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="keyword">if</span>(!pane.name)</span><br><span class="line">                    pane.name = index</span><br><span class="line">                <span class="keyword">if</span>(index === <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!_this.currentValue)&#123;</span><br><span class="line">                        _this.currentValue = pane.name || index</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="built_in">this</span>.updateStatus()</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">updateStatus</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> tabs = <span class="built_in">this</span>.getTabs();</span><br><span class="line">            <span class="keyword">var</span> _this = <span class="built_in">this</span>;</span><br><span class="line">            <span class="comment">//显示当前选中的tab对应的pane组件，隐藏没有选中的</span></span><br><span class="line">            tabs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">tab</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> tab.show = tab.name === _this.currentValue</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">watch</span>:&#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.currentValue = val;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">currentValue</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//在当前选中的tab发生变化时，更新pane的显示状态</span></span><br><span class="line">            <span class="built_in">this</span>.updateStatus();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>pane.js</code></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;pane&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;pane&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;\</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;pane&quot; v-show=&quot;show&quot;&gt;\</span></span><br><span class="line"><span class="string">            &lt;slot&gt;&lt;/slot&gt;\</span></span><br><span class="line"><span class="string">        &lt;/div&gt;&#x27;</span>,</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">show</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">props</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>:&#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="built_in">String</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">label</span>:&#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="built_in">String</span>,</span><br><span class="line">            <span class="attr">default</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * label用户是可以动态调整的，所以在pane初始化及label更新时，</span></span><br><span class="line"><span class="comment">        * 都要通知父组件也更新</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="title">updateNav</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.$parent.updateNav();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">watch</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">label</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.updateNav();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.updateNav();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>style.css</code></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[v-cloak]</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.tabs</span>&#123;</span><br><span class="line">    <span class="attribute">font</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#657180</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.tab-bar</span>:after&#123;</span><br><span class="line">    content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#d7dde4</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">1px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tabs-tab</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">4px</span> <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#d7dde4</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tabs-tab-active</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#3399ff</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tabs-tab-active</span>:before&#123;</span><br><span class="line">    content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#3399ff</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tabs-content</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">8px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有关此组件的css需要关注的就是伪元素拿来绘制标签页的分割线的妙用，这里需要着重关注，具体内容在面经部分作了记录</p><h1>七. 自定义指令</h1><h2 id="基本语法">基本语法</h2><p>指令注册和组件类似，只是方法名由component改为了directive,自定义指令的选项包含以下几个钩子函数：</p><ul><li><code>bind</code> 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作</li><li><code>inserted</code>: 被绑定元素插入节点时就被调用（比如输入框在网页打开时即获得焦点）</li><li><code>update</code> ：被绑定的元素所在的模板更新时使用，而不论绑定值是否变化</li><li><code>componentUpdated</code> ：被绑定元素所在模板完成一次更新周期时调用</li><li><code>unbind</code> ：只调用一次，指令与元素解绑时调用</li></ul><p><strong>参数</strong></p><ul><li><code>el</code> 指令所绑定的元素，可以直接操作DOM</li><li>binding： 一个对象，包含以下属性<ul><li>name</li><li>value</li><li>oldValue</li><li>expression</li><li>arg</li><li>modifiers</li></ul></li><li>vnode: Vue编译生成的虚拟节点</li><li>oldValue: 上一个虚拟节点尽在update和componentUpdated钩子中可用</li></ul><h2 id="使用场景示例">使用场景示例</h2><h3 id="下拉菜单实现">下拉菜单实现</h3><h3 id="开发实时时间转换指令v-time">开发实时时间转换指令v-time</h3><p>Date常用api</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Javascript/Reference/Global_Objects/Date">Date - JavaScript | MDN (mozilla.org)</a></p><h1>八 Render函数</h1><p><strong>Vue2.x和Vue1.x最大的区别就是2.x使用了虚拟DOM来更新DOM节点，提升了性能</strong></p><h2 id="Virtual-DOM">Virtual DOM</h2><p><img src="Vue2%20x%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93%20854c6/Untitled%201.png" alt="Untitled"></p><p>Virtual DOM 在Vue中是用js接口实现的，包含<code>VNode</code>和<code>VNodeData</code>两个就接口，其中<code>VNodeData</code>是VNode中的一个属性</p><h2 id="Render函数">Render函数</h2><p>render函数通过createElement参数来创建虚拟DOM，结构更为精简</p><h3 id="createElement用法">createElement用法</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">render:<span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> createElement(</span><br><span class="line">                    <span class="comment">//&#123;String | Object | Function&#125;,必选</span></span><br><span class="line">                    <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">                    <span class="comment">//一个对应属性的数据对象,可选</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//和v-bind:class一样</span></span><br><span class="line">                        <span class="string">&#x27;class&#x27;</span>:&#123;</span><br><span class="line">                            <span class="attr">foo</span>: <span class="literal">true</span>,</span><br><span class="line">                            <span class="attr">bar</span>: <span class="literal">false</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="comment">//和v-bind:style一样</span></span><br><span class="line">                        <span class="attr">style</span>:&#123;</span><br><span class="line">                            <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">                            <span class="attr">fontSize</span>: <span class="string">&#x27;14px&#x27;</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="comment">//正常的HTML属性</span></span><br><span class="line">                        <span class="attr">attrs</span>:&#123;</span><br><span class="line">                            <span class="attr">id</span>: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="comment">//组件props</span></span><br><span class="line">                        <span class="attr">props</span>:&#123;</span><br><span class="line">                            <span class="attr">myProp</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="comment">//DOM属性</span></span><br><span class="line">                        <span class="attr">domProps</span>: &#123;</span><br><span class="line">                            <span class="attr">innerHTML</span>: <span class="string">&#x27;baz&#x27;</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="comment">//自定义事件监听器on</span></span><br><span class="line">                        <span class="attr">on</span>: &#123;</span><br><span class="line">                            <span class="attr">click</span>: <span class="built_in">this</span>.clickHandler</span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="comment">//自定义指令</span></span><br><span class="line">                        <span class="attr">directives</span>:[</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">name</span>: <span class="string">&#x27;my-custom-directive&#x27;</span>,</span><br><span class="line">                                <span class="attr">value</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">                                <span class="attr">expression</span>: <span class="string">&#x27;1+1&#x27;</span>,</span><br><span class="line">                                <span class="attr">arg</span>: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">                                <span class="attr">modifiers</span>: &#123;</span><br><span class="line">                                    <span class="attr">bar</span>: <span class="literal">true</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        ],</span><br><span class="line">                        <span class="comment">//作用域slots</span></span><br><span class="line">                        <span class="attr">scopedSlots</span>: &#123;</span><br><span class="line">                            <span class="attr">default</span>: <span class="function"><span class="params">props</span> =&gt;</span> h(<span class="string">&#x27;span&#x27;</span>,props.text)</span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">slot</span>: <span class="string">&#x27;name-of-slot&#x27;</span>,</span><br><span class="line">                        <span class="comment">//其他特殊的顶层属性</span></span><br><span class="line">                        <span class="attr">key</span>: <span class="string">&#x27;myKey&#x27;</span>,</span><br><span class="line">                        <span class="attr">ref</span>: <span class="string">&#x27;myRef&#x27;</span></span><br><span class="line"></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="comment">//&#123;String | Array&#125;子节点，可选</span></span><br><span class="line">                    [</span><br><span class="line">                        createElement(<span class="string">&#x27;h1&#x27;</span>,<span class="string">&#x27;helloWorld&#x27;</span>),</span><br><span class="line">                        createElement(MyComponent,&#123;</span><br><span class="line">                            <span class="attr">props</span>:&#123;</span><br><span class="line">                                <span class="attr">someProp</span>: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;),</span><br><span class="line">                        <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">                    ]</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p><strong>可以使用循环和工厂函数渲染多个重复的子组件</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createElement(<span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    <span class="built_in">Array</span>.apply(<span class="literal">null</span>, &#123; <span class="attr">length</span>: <span class="number">20</span> &#125;).map(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> createElement(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-正则表达式学习总结</title>
      <link href="/2022/03/21/javascript-zhengze/"/>
      <url>/2022/03/21/javascript-zhengze/</url>
      
        <content type="html"><![CDATA[<h1>javascript 正则表达式总结</h1><p>因为前端包括登录在内的各种用户输入都会涉及到正则表达式，感觉是早晚都要学的。这里是本人学习正则表达式的总结，欢迎各位查阅！</p><p>参考来源：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式 - JavaScript | MDN (mozilla.org)</a></p><p><a href="https://www.runoob.com/js/js-regexp.html">JavaScript 正则表达式 | 菜鸟教程 (runoob.com)</a></p><p><a href="http://c.biancheng.net/view/5632.html">JS正则表达式语法大全（非常详细） (biancheng.net)</a></p><p><a href="https://www.bilibili.com/video/BV12J41147fC?p=2">第十四章 吃通js正则表达式，javascript前端工程师必会技能_哔哩哔哩_bilibili</a></p><h1>基础知识</h1><h2 id="创建正则表达式">创建正则表达式</h2><ol><li><p>使用一个正则表达式<strong>字面量</strong>，其由包含在斜杠之间的模式组成，如下所示：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/ab+c/</span>;</span><br></pre></td></tr></table></figure><p>当正则表达式保持不变时，使用此方法可获得更好的性能。</p></li><li><p>或者调用<code>[RegExp](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp)</code>对象的构造函数</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;ab+c&quot;</span>);</span><br></pre></td></tr></table></figure><p>下面是一个有趣的例子，<strong>用户输入要匹配的字符，网页上将匹配的字符高亮</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Joe is so handome, we all love him.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> con = prompt(<span class="string">&quot;请输入要检测的内容，支持正则表达式&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(con,<span class="string">&quot;g&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">div.innerHTML = div.innerHTML.replace(reg,<span class="function"><span class="params">search</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">`&lt;span style=&quot;color:red&quot;&gt; <span class="subst">$&#123;search&#125;</span> &lt;/span&gt;`</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="语法">语法</h3><p><code>/正则表达式主体/修饰符(可选)</code></p><h2 id="正则表达式模式">正则表达式模式</h2><h3 id="简单模式">简单模式</h3><p><code>/abc/</code> 表示匹配”abc“按照顺序同时出现的情况</p><h3 id="原子表与原子组">原子表与原子组</h3><p><code>[]</code>表示匹配内部任何一个字符即可</p><p><code>()</code>表示匹配内部的所有字符，内部的字符是一个整体</p><p><img src="javascript%2045f62/Untitled.png" alt="Untitled"></p><h3 id="转义">转义</h3><p>有些字符有多重含义，需要加转义符进行转义，即加\</p><p>如以下正则表达式：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> con = <span class="regexp">/\d+\.\d+/</span></span><br></pre></td></tr></table></figure><p>表示匹配至少一位的数字和一个点和至少一位以上数字的字符串</p><p>但是如果使用对象声明，则应该写成：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;\\d+\\.\\d+&quot;</span>);</span><br></pre></td></tr></table></figure><p>示例：</p><p><img src="javascript%2045f62/Untitled%201.png" alt="Untitled"></p><h3 id="边界约束">边界约束</h3><p>在进行正常的正则匹配时，常常时字符串含有某个字符即为真，这不是我们想要的，因为开始和结尾没有限定。</p><ol><li>限定起始边界: <code>^</code> 即^后跟字符表示以该字符为起始</li><li>限定结束边界：<code>$</code>放在某一字符之后表示以该字符结尾</li></ol><p><strong>一个有趣的例子</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&quot;[name = &#x27;user&#x27;]&quot;</span>)</span><br><span class="line">    .addEventListener(<span class="string">&quot;keyup&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.value.match(<span class="regexp">/^[a-z]&#123;3,6&#125;$/</span>))</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>匹配以小写字母开头且整个长度为3-6位的字符串，如果不限定起始边界和终止边界，只要长度大于3都能被匹配，因为没有限定边界。</p><h3 id="修饰符">修饰符</h3><table><thead><tr><th>i</th><th>执行对大小写不敏感的匹配</th></tr></thead><tbody><tr><td>g</td><td>执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）</td></tr><tr><td>m</td><td>执行多行匹配</td></tr></tbody></table><h3 id="方括号">方括号</h3><p>用于查找某个范围内的字符</p><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>[abc]</td><td>查找方括号之间的任何字符</td></tr><tr><td>[0-9]</td><td>查找任何0-9的数字</td></tr><tr><td>（x</td><td>y）</td></tr><tr><td>[^abc]</td><td>查找不在方括号内的字符</td></tr></tbody></table><h3 id="元字符">元字符</h3><p>表达式的最小单位，表示一类字符当中的一个</p><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td>\d</td><td>查找数字</td></tr><tr><td>\s</td><td>查找空白字符（空格，制表符，换行都算）</td></tr><tr><td>\b</td><td>匹配单词边界</td></tr><tr><td>\uxxxx</td><td>查找以十六进制数xxxx规定的Unicode字符</td></tr><tr><td>\B</td><td>匹配非单词边界</td></tr><tr><td>\w</td><td>查找单词字符(字母，数字，下划线)</td></tr><tr><td>\D</td><td>查找不是数字的字符</td></tr><tr><td>\W</td><td>除了单词（字母数字下划线）的字符</td></tr></tbody></table><p><code>\d</code> 和 <code>\s</code></p><p>例子：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hd = <span class="string">`张三：010-9999999,李四: 020-88888888`</span></span><br><span class="line"><span class="built_in">console</span>.log(hd.match(<span class="regexp">/\d&#123;3&#125;-\d&#123;7,8&#125;/g</span><span class="regexp">/))</span></span><br><span class="line"><span class="regexp">console.log(hd.match([^-\d:,\s]+/g</span>))</span><br></pre></td></tr></table></figure><ol><li>表示匹配<strong>所有</strong>三位数字连接-连接7-8位数字的字符串，结果以数组的形式保存 ,结果是含有两个电话号码的数组</li><li>表示匹配<strong>所有</strong>不是- 数字 ： ， 和空白的字符，结果是【”张三“,”李四”】</li></ol><p><code>\w</code></p><p><strong>最简单的邮箱字符串匹配</strong>(记得限定边界)</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> email = <span class="string">&quot;19921305202@163.com&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(email.match(<span class="regexp">/^\w+@\w+\.\W+/</span>$))</span><br></pre></td></tr></table></figure><h3 id="量词">量词</h3><table><thead><tr><th>量词</th><th>描述</th></tr></thead><tbody><tr><td>n+</td><td>匹配任何包含至少一个n的字符串</td></tr><tr><td>n*</td><td>匹配任何包含零个或多个n的字符串</td></tr><tr><td>n?</td><td>匹配任何包含零个或一个n的字符串</td></tr></tbody></table><h2 id="使用正则表达式的方法">使用正则表达式的方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>exec</td><td>一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回 null）。</td></tr><tr><td>test</td><td>一个在字符串中测试是否匹配的RegExp方法，它返回 true 或 false。</td></tr><tr><td>match</td><td>一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。</td></tr><tr><td>matchAll</td><td>一个在字符串中执行查找所有匹配的String方法，它返回一个迭代器（iterator）。</td></tr><tr><td>search</td><td>一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。</td></tr><tr><td>replace</td><td>一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。</td></tr><tr><td>split</td><td>一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组的 String方法。</td></tr></tbody></table><h1>实际运用实例</h1><h2 id="数字转标准三位逗号形式">数字转标准三位逗号形式</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> total.toString().replace(<span class="regexp">/\B(?=(\d&#123;3&#125;)+$)/g</span>,<span class="string">&#x27;,&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试知识手册--html/css篇</title>
      <link href="/2022/03/19/frontendpreparation1-html/"/>
      <url>/2022/03/19/frontendpreparation1-html/</url>
      
        <content type="html"><![CDATA[<p>转载自一位大牛的总结仓库，搬运过来方便自己查阅~<br><a href="https://github.com/okaychen/FE-Interview-Brochure">原仓库地址</a></p><p>HTML&amp;CSS篇（第一个版本该篇预计总结常见问题20个左右），HTML&amp;CSS不少问题都能体现应届生对于前端基础的掌握程度，是应届生求职时不可忽视的重要一环</p><h1>HTML/CSS</h1><h2 id="浏览器解析渲染页面过程">浏览器解析渲染页面过程</h2><p>大致过程：</p><p>HTML解析构建DOM-&gt;CSS解析构建CSSOM树-&gt;根据DOM树和CSSOM树构建render树-&gt;根据render树进行布局渲染render layer-&gt;根据计算的布局信息进行绘制</p><p>不同浏览器的内核不同，所以渲染过程其中有部分细节有不一样，以webkit主流程为例：</p><p><img src="https://cdn.jsdelivr.net/gh/okaychen/CDN@2.0/brochure/image/browser.jpg" alt=""></p><p>一篇很棒的文章(需科学上网)：<a href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/">How Browser Work</a></p><blockquote><p>编者有话说：浏览器解析渲染页面过程是一个复杂的过程，其中有不少的细节和规则，如果把上面分享的文章翻译成译文，至少有3～5页PDF左右，所以这里只能总结大致过程（作为面试回答【很可能让回答的尽可能详细】了解来说已经足够，更深入的了解可以好好读下上面那篇文章）</p></blockquote><p>较详细过程：</p><p>HTML解析构建DOM树：其中HTML Parser就起到了将HTML标记解析成DOM Tree的作用，HTML Parser将文本的HTML文档，提炼出关键信息，嵌套层级的树形结构，便于计算拓展；这其中也有很多的规则和操作，比如容错机制，识别特殊标签<code>&lt;br&gt;&lt;/br&gt;</code>等</p><p>CSS解析构建CSSOM树：CSS Parser将很多个CSS文件中的样式合并解析出具有树形结构Style Rules，也叫做CSSOM。</p><blockquote><p>※其中还有一个细节是浏览器解析文档：当遇到<code>&lt;script&gt;</code>标签的时候会停止解析文档，立即解析脚本，将脚本中改变DOM和CSS的地方分别解析出来，追加到DOM Tree和CSSOM上</p></blockquote><p>根据DOM树和CSSOM树构建Render树：Render Tree的构建其实就是DOM Tree和CSSOM Attach的过程，在webkit中，解析样式和创建呈现器的过程称为&quot;附加&quot;，每个DOM节点都有一个&quot;attach&quot;方法，Render Tree其实就相当于一个计算好样式，与HTML对应的Tree</p><p>根据Render树进行布局渲染render layer：创建渲染树后，Layout根据根据渲染树中渲染对象的信息，计算好每一个渲染对象的位置和尺寸，将其放在浏览器窗口的正确位置，某些时候会在文档布局完成之后进行DOM修改，重新布局的过程就称为回流</p><blockquote><p>※其中计算（样式计算）一个复杂的过程，因为DOM中的一个元素可以对应样式表中的多个元素，Firefox采用了规则树和样式上下文树来简化样式计算，规则树包含了所有已知规则的匹配路径，样式上下文包含端值，webkit也有样式对象，但它们不保存在类似上下文树这样的结构中，只是由DOM节点指向此类对象的相关样式</p></blockquote><p>根据计算的布局信息进行绘制：绘制阶段则会遍历呈现树，并调用呈现器的paint方法，将呈现器的内容显示在屏幕上，绘制的顺序其实就是元素进入堆栈样式上下文的顺序，例如，块呈现器的堆栈顺序如下：1.背景颜色，2.背景图片，3.边框，4.子代，5.轮廓</p><h2 id="回流和重绘区别-减少回流重绘次数的方法">回流和重绘区别&amp;减少回流重绘次数的方法</h2><p>区别：</p><ul><li>回流指当前窗口发生改变，发生滚动操作，或者元素的位置大小相关属性被更新时会触发布局过程，发生在render树，比如元素的几何尺寸变化，就需要重新验证并计算Render Tree</li><li>重绘指当前视觉样式属性被更新时触发的绘制过程，发生在渲染层render layer</li><li>所以相比之下，回流的成本要比重绘高得多</li></ul><p>减少回流重绘次数的方法：</p><ul><li>1）避免一条一条的修改DOM样式，而是修改className或者style.classText</li><li>2）对元素进行一个复杂的操作，可以先隐藏它，操作完成后在显示</li><li>3）在需要经常获取那些引起浏览器回流的属性值时，要缓存到变量中</li><li>4）不使用table布局，一个小的改动可能就会引起整个table重新布局</li><li>5）在内存中多次操作节点，完成后在添加到文档中</li></ul><h2 id="关于transform开启GPU加速渲染，相比top-left，优势在哪里">关于transform开启GPU加速渲染，相比top&amp;left，优势在哪里</h2><blockquote><p>页面性能优化有一条，用transform代替top，left来实现动画。那么transform的优势在哪里？如何开启GPU加速渲染？开启GPU硬件加速可能会触发的问题，如何解决？</p></blockquote><p>首先相比定位的top&amp;left来说，transform不会引起整个页面的回流和重绘。其次我们可以通过transform开启GPU硬件加速，提高渲染速度，但相应的transform也会占用更多的内存。</p><h2 id="transform如何开启GPU硬件加速">transform如何开启GPU硬件加速</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">translateZ</span>(<span class="number">0</span>);</span><br><span class="line">    //或者</span><br><span class="line">    transfor:<span class="built_in">translate3d</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开启GPU硬件加速可能会触发哪些问题，如何处理">开启GPU硬件加速可能会触发哪些问题，如何处理</h2><p>可能会导致浏览器频繁闪烁或者抖动，解决方案：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">backface-visibility</span>: hidden;</span><br><span class="line">    <span class="attribute">perspective</span>: <span class="number">1000</span>;</span><br><span class="line">    -webkit-<span class="attribute">backface-visibility</span>: hidden;</span><br><span class="line">    -webkit-<span class="attribute">perspective</span>: <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="移动端点透现象有遇到过嘛">移动端点透现象有遇到过嘛</h2><p>首先需要了解的是，移动端在touch上一共有4个事件，</p><p>执行顺序为<code>touchstart -&gt; touchmove -&gt; touchend -&gt; touchcancel</code></p><p>当用户点击屏幕时，会触发touch和click事件，touch事件会优先处理，touch事件经过捕获，目标，冒泡一系列流程处理完成之后，才会触发click，所有我们经常会谈到移动端点击事件300ms延迟的问题</p><p>移动端点击事件300ms问题，常见的解决方案：</p><ul><li>阻止用户双击缩放，并限制视口大小</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; <span class="attribute">content</span>=&quot;<span class="attribute">width</span>=device-<span class="attribute">width</span>,<span class="attribute">initial</span>-scale=<span class="number">1</span>,minimum-scale=<span class="number">1</span>,maximum-scale=<span class="number">1</span>,user-scalable=no&quot;/&gt;</span><br></pre></td></tr></table></figure><ul><li>设置css<code>touch-action</code>用于指定某个给定的区域是否允许用户操作，以及如何相应用户操作</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  touch-action: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>fastclick.js来解决，其原理是在检测到touchend事件的时候，会通过自定义事件立即触发模拟一个click事件，并在300ms之后把真正的click事件阻止掉</li></ul><p>点透现象：</p><p>发生条件：①按钮A和按钮B不是后代继承关系，②A发生touch，A touch后立即消失，B绑定click，③A z-index大于B，即 A 显示在 B 浮层之上</p><p>发生原因：当点击屏幕时，系统生成touch和click两个事件，touch先执行，touch执行完之后A消失，然后要执行click的时候，就会发现用户点击的是B，所以就执行了B的click</p><p>解决方法：①阻止默认事件，在touch的某个时间段执行event.preventDefault，去取消系统生成的click事件，一半在 touchend 中执行。②要消失的元素延迟300ms后在消失</p><h2 id="Doctype是什么，三种模式的区别在什么地方">Doctype是什么，三种模式的区别在什么地方</h2><p>Doctype是一种DTD文档定义类型，必须声明在HTML文档的第一行，用来规范文档使用哪种方式解析HTML，三种模式分别是怪异模式，标准模式，近乎模式(IE8的一种近乎于前两者之间的一种模式)；标准模式按照HTML和CSS定义渲染，怪异模式会模拟更旧的浏览器行为</p><h2 id="说说对两种盒模型的理解">说说对两种盒模型的理解</h2><p>标准盒模型和IE怪异盒模型，标准盒模型下：盒子总宽度/高度=width/height+padding+border+margin</p><p><img src="https://cdn.jsdelivr.net/gh/okaychen/CDN@2.0/brochure/image/box_model01.png" alt=""></p><p>怪异盒模型，IE5.X 和 6 在怪异模式中使用自己的非标准模型，盒子的总宽度和高度是包含内边距padding和边框border宽度在内的：盒子总宽度/高度=width/height + margin = width/height + margin;</p><p><img src="https://cdn.jsdelivr.net/gh/okaychen/CDN@2.0/brochure/image/box_model02.png" alt=""></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">box-sizing</span> : content-box || border-box || inherit;</span><br></pre></td></tr></table></figure><p>boxsizing属性content-box使用标准盒模型的计算方式，border-box则使用怪异盒模型的计算方式</p><h2 id="margin塌陷和合并问题">margin塌陷和合并问题</h2><p>首先，margin塌陷是相对于父子级关系的两个元素，而margin合并是相对两个兄弟级关系的两个元素</p><p>两个兄弟级关系的元素，垂直方向上的margin，其外边距会发生重叠现象，两者两个的外边距取的是两个所设置margin的最大值，就是所说的margin合并问题</p><p>两个父子级关系的元素，垂直方向上的margin会粘合在一起，外层和模型的margin-top取两个元素中margin-top的最大值，发生margin塌陷的内层元素相对于整个文档移动</p><p>解决方案：两者都可以通过触发BFC来解决</p><h2 id="关于IFC和BFC，哪些元素会触发BFC">关于IFC和BFC，哪些元素会触发BFC</h2><p>首先需要知道文档流分为定位流，浮动流和普通流三种，而普通流则是BFC中的FC（格式化上下文），它是页面的一块渲染区域，有一套渲染规则，决定了子元素如何布局，以及和其他元素之间的关系和作用，常见的FC有BFC，IFC，还有GFC和FFC</p><p>BFC块级格式化上下文，IFC行级格式化上下文，</p><p>哪些元素会触发BFC：</p><ul><li>根元素</li><li>float的属性不为none</li><li>position属性为absolute或fixed</li><li>display为inline-block，table-cell，table-caption，flex</li><li>overflow不为visible</li></ul><h2 id="CSS定位的方式有哪些分别相对于谁">CSS定位的方式有哪些分别相对于谁</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">static(默认值)</span><br><span class="line">absolute(绝对定位，相对于最近已定位的父元素，如果没有则相对于&lt;<span class="selector-tag">html</span>&gt;)</span><br><span class="line">fixed(固定定位，相对于窗口)</span><br><span class="line">relative(相对定位，相对于自身)</span><br><span class="line">sticky(<span class="number">2017</span>年浏览器开始支持，粘性定位)</span><br></pre></td></tr></table></figure><p>absolute会使元素位置与文档流无关，不占据空间，absolute 定位的元素和其他元素重叠</p><p>relative相对定位时，无论元素是否移动，仍然占据原来的空间</p><p>sticky是2017年浏览器才开始支持，会产生动态效果，类似relative和fixed的结合，一个实例是&quot;<a href="http://www.ruanyifeng.com/blog/2019/11/css-position.html">动态固定</a>&quot;，生效前提是必须搭配<code>top,left,bottom,right</code>一起使用，不能省略，否则等同于<code>relative</code>定位，不产生&quot;动态固定&quot;的效果</p><h2 id="移动端布局的解决方案，平时怎么做的处理">移动端布局的解决方案，平时怎么做的处理</h2><ul><li>使用Flexbox</li><li>百分比布局结合媒体查询</li><li>使用rem</li></ul><p>rem转换像素大小（根元素的大小乘以rem值），取决与页面根元素的字体大小，即HTML元素的字体大小</p><p>em转换像素大小（em值乘以使用em单位的元素的字体大小），比如一个div的字体大小为16px，那么10em就是180px（或者接近它）</p><p>rem平时怎么做的转换：为了方便计算，时常将html的字体大小设置为62.5%，那么12px就会是1.2rem</p><h2 id="垂直水平居中的多种解决方案">垂直水平居中的多种解决方案</h2><h3 id="未知宽高元素实现垂直水平居中">未知宽高元素实现垂直水平居中</h3><p>① flex实现水平垂直居中</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>② 进行垂直水平居中（利用transform中translate偏移的百分比值是相对于自身大小的特性）</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">      <span class="attribute">position</span>: relative;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">      <span class="attribute">margin</span>: auto;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">1px</span> solid yellow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">      <span class="attribute">position</span>: absolute;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.method3</span> &#123;</span><br><span class="line">      <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">      <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="已知宽高元素的垂直水平居中">已知宽高元素的垂直水平居中</h3><p>① 绝对定位+<code>margin:auto</code></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>② 使用绝对定位与负边距</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: -<span class="number">50px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="经典的三栏布局的实现方式">经典的三栏布局的实现方式</h2><p>三栏布局：两侧定宽中间自适应，在开发中很常见的布局方式，主要有下面六种实现方式：</p><ul><li>最简单的方式就是通过float实现</li><li>利用绝对定位</li><li>利用BFC规则</li><li>圣杯布局（通过margin负值调整）</li><li>双飞翼布局（和双飞翼布局类似，只是处理中间栏被遮挡的方式不同：双飞翼布局在中间栏内部加一个div，设置其margin来避开遮挡）</li><li>利用flex布局 👇 <em>Q14</em></li></ul><h2 id="对flex布局的了解，flex如何实现经典的三栏布局">对flex布局的了解，flex如何实现经典的三栏布局</h2><p>flex意为弹性布局，有两大概念，一是容器(container)，二是项目(item)，两者都有各自的六个常用属性</p><p>用在容器上的六个属性：</p><ul><li><code>flex-direction</code>主轴的方向，</li><li><code>flex-wrap</code>一条轴线装满，如何换行，</li><li><code>flex-flow</code>是前两者的简写，</li><li><code>justify-content</code>项目在主轴上的对齐方式</li><li><code>align-items</code>在交叉轴上如何对齐</li><li><code>align-content</code>多跟轴线的对齐方式</li></ul><p>用在项目上的六个属性:</p><ul><li><code>order</code>排序顺序，默认为0，越小越靠前</li><li><code>flex-grow</code>项目的放大比例，默认为0，不放大</li><li><code>flex-shrink</code>项目的缩小比例，默认为1，空间不足该项目会缩小</li><li><code>flex-basis</code>项目占据主轴空间大小</li><li><code>flex</code>是上面放大，缩小，大小三者的简写，默认为0 1 auto</li><li><code>align-self</code>允许单个项目有不同于其他的对齐方式</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--flex实现经典的三栏布局--&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.flex-container&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.middle &#123;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: yellowgreen;</span><br><span class="line">    flex-grow: 1;</span><br><span class="line">&#125;</span><br><span class="line">.left,.right &#123;</span><br><span class="line">    height: 200px;</span><br><span class="line">    flex: 0 1 200px;</span><br><span class="line">    background-color: green;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;flex-container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;左侧内容&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;middle&quot;&gt;中间内容&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;右侧内容&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/okaychen/CDN@2.0/brochure/image/layout01.png" alt=""></p><h2 id="说说你知道的清除浮动的方法，知道其中的原理嘛">说说你知道的清除浮动的方法，知道其中的原理嘛</h2><p>清除浮动主要是为了解决父元素因为子元素浮动内部高度为0的问题</p><ul><li>额外标签，即在最后一个浮动标签后加一个空div，给其设置<code>clear:both</code>，缺点是增加无意义标签，语义化差</li><li>给父级元素添加<code>overflow:不为visible</code>通过触发BFC的方式清除浮动</li><li>使用after伪元素，缺点是IE6-7不支持伪元素，zoom:1触发hasLayout</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>:after&#123;</span><br><span class="line">    content:<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">    <span class="attribute">visibility</span>:hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">    *zoom:<span class="number">1</span>; <span class="comment">/*ie6清除浮动的方式 *只有IE6-IE7执行*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用before和after双伪元素清除浮动</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>:after,.clearfix:before&#123;</span><br><span class="line">    content:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>:table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>:after&#123;</span><br><span class="line">    clear:both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clear</span>&#123;</span><br><span class="line">    *zoom:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对css-sprits的理解，好处是什么">对css sprits的理解，好处是什么</h2><p>css sprits又名雪碧图，也叫css精灵，开发人员会将很多小图标合并在一起之后的图片成为雪碧图，使用时通过background-image、background-position和background-size属性，将对应的小图标添加元素中</p><p>优点是：</p><ul><li>减少加载多张图片的HTTP请求数</li><li>可以提前加载资源</li></ul><p>缺点是：</p><ul><li>维护成本较高，需要改动这张合并的图片</li><li>加载优势在http2之后不复存在，http2采用多路复用，多张图片也可以重复使用一个连接</li></ul><h2 id="说一下前端的几种存储方式">说一下前端的几种存储方式</h2><p>cookie，localstorage，sessionstorage，IndexedDB</p><p>（追问）这些方式的区别是什么，分别介绍一下：</p><ul><li>cookie：HTML5标准前本地存储主要方式，请求头带着数据，缺点是大小只有4k左右，并且自动请求头加入cookie浪费流量，每个domain限制20个cookie，使用起来也麻烦需要自行封装</li><li>localstorage：HTML5标准后加入，以键值对（key-value）方式存储，永久存储，永不失效，除非手动删除，IE8+支持，每个域名限制5M</li><li>sessionstorage：和localstorage操作方法一样，区别在于sessionstorage在关闭页面后即被清空，刷新不会清空，但是不能在所有同源窗口中共享，是会话级别的存储方式</li><li>IndexedDB：被纳入HTML5标准的数据库存储方案，它是一个NoSql数据库，用键值对进行存储，可以快速读取操作，适合web场景和JavaScript操作</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode刷题笔记-链表</title>
      <link href="/2022/03/18/leetcode-2/"/>
      <url>/2022/03/18/leetcode-2/</url>
      
        <content type="html"><![CDATA[<h1>Leetcode—链表专题</h1><h2 id="1-链表基础知识">1. 链表基础知识</h2><p>单链表在C++中的定义方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    <span class="keyword">int</span> val;  <span class="comment">// 节点上存储的元素</span></span><br><span class="line">    ListNode *next;  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(NULL) &#123;&#125;  <span class="comment">// 节点的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在java中的定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结点的值</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="comment">// 下一个结点</span></span><br><span class="line">    ListNode next;</span><br><span class="line">    <span class="comment">// 节点的构造函数(无参)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 节点的构造函数(有一个参数)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 节点的构造函数(有两个参数)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val, ListNode next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-移除链表元素203">2.移除链表元素203</h2><p><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">203. 移除链表元素 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>对此可以设置虚拟头节点，以便对头节点和非头节点作统一处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode virtualHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, head);</span><br><span class="line">        ListNode pre = virtualHead;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val == val)&#123;</span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> virtualHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-707-设计链表707">3. 707 设计链表707</h2><p><a href="https://leetcode-cn.com/problems/design-linked-list/submissions/">707. 设计链表 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>这道题做了几乎是两个多小时，错了很多遍才得到满分，可以说对链表还很不熟练。</p><p>和答案相比，有以下不同：</p><ol><li>首先是答案使用了虚拟头节点，在初始化的时候就实例化了一个头节点，并将值设为默认值0.</li><li>设置了一个属性size，能快速判断index是否超过范围</li></ol><p><strong>get方法：</strong></p><p>me:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        LinkNode cur = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt; index; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="keyword">null</span>)</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> cur.val;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>没有考虑到index&lt;0的情况</p><p>使用size后不用每次都判断cur是否为空了</p><p>key:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取第index个节点的数值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果index非法，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode currentNode = head;</span><br><span class="line">        <span class="comment">//包含一个虚拟头节点，所以查找第 index+1 个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentNode.val;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>addAtHead()方法</strong></p><p>me：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkNode node = <span class="keyword">new</span> LinkNode(val);</span><br><span class="line">        node.next = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">this</span>.head = node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>key：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在链表最前面插入一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>addAtTail()方法</strong></p><p>me:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkNode cur = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkNode(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = <span class="keyword">new</span> LinkNode(val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>key:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在链表的最后插入一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        addAtIndex(size, val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再次体现出size的好处，直接调用addAtIndex方法</p><p><strong>addAtIndex方法</strong></p><p>me:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkNode(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index == <span class="number">1</span>)&#123;</span><br><span class="line">                head.next = <span class="keyword">new</span> LinkNode(val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">                LinkNode node = <span class="keyword">new</span> LinkNode(val);</span><br><span class="line">                node.next = <span class="keyword">this</span>.head;</span><br><span class="line">                <span class="keyword">this</span>.head = node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        LinkNode pre = <span class="keyword">this</span>.head;</span><br><span class="line">        LinkNode cur = <span class="keyword">this</span>.head.next;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">            LinkNode node = <span class="keyword">new</span> LinkNode(val);</span><br><span class="line">            node.next = <span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">this</span>.head = node;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num == index)&#123;</span><br><span class="line">                LinkNode node = <span class="keyword">new</span> LinkNode(val);</span><br><span class="line">                pre.next = node;</span><br><span class="line">                node.next = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num == index)</span><br><span class="line">            pre.next = <span class="keyword">new</span> LinkNode(val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>key:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span></span><br><span class="line">    <span class="comment">// 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span></span><br><span class="line">    <span class="comment">// 如果 index 大于链表的长度，则返回空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">//找到要插入节点的前驱</span></span><br><span class="line">        ListNode pred = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode toAdd = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        toAdd.next = pred.next;</span><br><span class="line">        pred.next = toAdd;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>deleteAtIndex方法</strong></p><p>me:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        LinkNode pre = <span class="keyword">this</span>.head;</span><br><span class="line">        LinkNode cur = pre.next;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">if</span>(num == index)</span><br><span class="line">            &#123;</span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>key:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除第index个节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    size--;</span><br><span class="line">    ListNode pred = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        pred = pred.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pred.next = pred.next.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还可以使用双链表的方法，节点设置前驱和后置两个属性，然后链表设置头节点和尾节点。同时也设置虚拟头节点，尾节点的next属性指向头节点。</p><h2 id="4-206反转链表">4. 206反转链表</h2><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></p><blockquote><p>给你单链表的头节点 <code>head</code>，请你反转链表，并返回反转后的链表。</p></blockquote><p>第一次真的没有做出来…感觉基础很不扎实，所以这里记录下思路吧。大致可以分为迭代和递归两种方法。首先是迭代，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">ListNode cur = head;</span><br><span class="line"><span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">ListNode next = cur.next;</span><br><span class="line">cur.next = pre;</span><br><span class="line">pre = cur;</span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在遍历链表时，将当前节点的 \textit{next}next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)<em>O</em>(<em>n</em>)，其中 n<em>n</em> 是链表的长度。需要遍历链表一次。</li><li>空间复杂度：O(1)<em>O</em>(1)。</li></ul><p>其次是递归方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">ListNode newHead =  reverseList(head.next);</span><br><span class="line">head.next.next = head;</span><br><span class="line">head.next = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如对于链表：1→2→3→4→5,当递归到最底层时，head为5，此时相当于让null指向head;第二轮返出栈后head=4,head→next为5，让5指向4，除此之外还要让4不指向5，因此head→next = null；直到全部出栈完成。</p><h2 id="24-两两交换链表中的节点">24. 两两交换链表中的节点</h2><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点 - 力扣（LeetCode） (leetcode-cn.com)</a></p><blockquote><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p></blockquote><p><img src="Leetcode%E2%80%94%E9%93%BE%203f9d1/Untitled.png" alt="Untitled"></p><p>最开始也是卡了很久，感觉还是不太熟练，链表指针的赋值思路很乱，花了很久才写出来下面的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        newHead.next = head;</span><br><span class="line">        ListNode pre = newHead;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            pre.next = next;</span><br><span class="line">            ListNode nextNode = next.next;</span><br><span class="line">            next.next = cur;</span><br><span class="line">            cur.next = nextNode;</span><br><span class="line">            <span class="keyword">if</span>(nextNode != <span class="keyword">null</span> &amp;&amp; nextNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = nextNode;</span><br><span class="line">                next = nextNode.next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准答案的迭代方法明显更加简洁：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 虚拟头结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ListNode dummyNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line">    ListNode prev = dummyNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (prev.next != <span class="keyword">null</span> &amp;&amp; prev.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ListNode temp = head.next.next; <span class="comment">// 缓存 next</span></span><br><span class="line">      prev.next = head.next;          <span class="comment">// 将 prev 的 next 改为 head 的 next</span></span><br><span class="line">      head.next.next = head;          <span class="comment">// 将 head.next(prev.next) 的next，指向 head</span></span><br><span class="line">      head.next = temp;               <span class="comment">// 将head 的 next 接上缓存的temp</span></span><br><span class="line">      prev = head;                    <span class="comment">// 步进1位</span></span><br><span class="line">      head = head.next;               <span class="comment">// 步进1位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，力扣还提供了递归的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = head.next;</span><br><span class="line">        head.next = swapPairs(newHead.next);</span><br><span class="line">        newHead.next = head;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>递归的终止条件是链表中没有节点，或者链表中只有一个节点，此时无法进行交换。</p><p>如果链表中至少有两个节点，则在两两交换链表中的节点之后，原始链表的头节点变成新的链表的第二个节点，原始链表的第二个节点变成新的链表的头节点。链表中的其余节点的两两交换可以递归地实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换。</p><p>用 head 表示原始链表的头节点，新的链表的第二个节点，用 newHead 表示新的链表的头节点，原始链表的第二个节点，则原始链表中的其余节点的头节点是 newHead.next。令 head.next = swapPairs(newHead.next)，表示将其余节点进行两两交换，交换后的新的头节点为 head 的下一个节点。然后令 newHead.next = head，即完成了所有节点的交换。最后返回新的链表的头节点 newHead。</p><h2 id="19-删除链表的倒数第N个节点">19 删除链表的倒数第N个节点</h2><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/submissions/">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>在提示下做出来了，双指针法，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更推荐虚拟头节点的写法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        ListNode slow = dummy;</span><br><span class="line">        ListNode fast = dummy;</span><br><span class="line">        <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记住 待删除节点slow 的上一节点</span></span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            prev = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上一节点的next指针绕过 待删除节点slow 直接指向slow的下一节点</span></span><br><span class="line">        prev.next = slow.next;</span><br><span class="line">        <span class="comment">// 释放 待删除节点slow 的next指针, 这句删掉也能AC</span></span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-链表相交">7 链表相交</h2><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/submissions/">面试题 02.07. 链表相交 - 力扣（LeetCode） (leetcode-cn.com)</a></p><blockquote><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p></blockquote><p><img src="Leetcode%E2%80%94%E9%93%BE%203f9d1/Untitled%201.png" alt="Untitled"></p><p>因为题目定义的相交是第一个相等的节点后面的所有节点都相等，可知重合的部分长度都是相等的，因此只需将链表对齐即可。</p><p>思路是先分别得出两个链表的长度，然后求出差值，对其链表，然后依次向后移动，直到第一个相等的节点出现，就是首次重叠的节点。</p><h2 id="142-环形链表II">142 环形链表II</h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>考研书上的一道题，第一次做没什么思路，代码随想录的答案总结就写的挺好的，如下：</p><p><a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p><p>看了题解后写的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fastNode = head;<span class="comment">//fast iterator</span></span><br><span class="line">        ListNode slowNode = head;<span class="comment">//slow iterator</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slowNode == <span class="keyword">null</span> || fastNode == <span class="keyword">null</span> || fastNode.next == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            fastNode = fastNode.next.next;</span><br><span class="line">            slowNode = slowNode.next;</span><br><span class="line">            <span class="keyword">if</span>(fastNode != slowNode)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时必有环</span></span><br><span class="line">        ListNode newNode = head;</span><br><span class="line">        <span class="keyword">while</span>(newNode != slowNode)&#123;</span><br><span class="line">            newNode = newNode.next;</span><br><span class="line">            slowNode = slowNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要问题是一开始while(条件)内的条件不知道如何写合适，因为如果写while(slowNode ≠ fastNode)这样最开始就无法进入循环，所以只好写while(true)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;<span class="comment">// 有环</span></span><br><span class="line">                ListNode index1 = fast;</span><br><span class="line">                ListNode index2 = head;</span><br><span class="line">                <span class="comment">// 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口</span></span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了标答觉得slowNode ≠ null没有必要写</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用ildasm工具分析C# 闭包外部变量实现原理</title>
      <link href="/2022/03/17/ildasm/"/>
      <url>/2022/03/17/ildasm/</url>
      
        <content type="html"><![CDATA[<p>在使用工具分析之前，我们需要先明白什么是闭包。闭包不是针对于C#提出的，在许多语言尤其是函数式编程的语言中都有广泛使用，比如javascript。但是不同语言对于闭包的实现方式不同，本文档着手通过反编译工具来探究C# 闭包外部变量的实现原理。</p><h3 id="闭包定义"><strong>闭包定义</strong></h3><p>我们把在Lambda表达式(或匿名方法)中所引用的外部变量称为<strong>捕获变量</strong>。而捕获变量的表达式就称为<strong>闭包</strong>。</p><p>而在《javascript高级程序设计》中，对闭包有更加准确的解释：</p><p><strong>闭包是指有权访问另一个函数作用域中的变量的函数。</strong></p><p>捕获的变量会在真正<strong>调用委托</strong>时“赋值”，而不是在捕获时“赋值”，即总是使用捕获变量的<strong>最新的值</strong>。</p><p>比如如下所示的代码：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> age = <span class="number">28</span>;</span><br><span class="line"><span class="comment">//定义委托，通用委托，返回string,有一个参数int</span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; consoleAge = i =&gt; <span class="string">$&quot;洋小豆今年<span class="subst">&#123;i&#125;</span>岁了&quot;</span>;</span><br><span class="line">age = <span class="number">30</span>;</span><br><span class="line"><span class="comment">//调用委托</span></span><br><span class="line"><span class="built_in">string</span> outputMsg = consoleAge(age);</span><br><span class="line">outputMsg.Dump();</span><br></pre></td></tr></table></figure><h3 id="捕获迭代变量">捕获迭代变量</h3><p>当捕获的外部变量为for循环的迭代变量时，C#认为变量i是定义在循环体外的。所以，当添加委托集合的for循环执行完时，i的值已经变为3了；因此，我们在foreach中循环调用委托时，i的值为3。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">List&lt;Action&gt; levyActions =<span class="keyword">new</span> List&lt;Action&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">   levyActions.Add(()=&gt; i.Dump());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span> (Action actionin levyActions)</span><br><span class="line">&#123;</span><br><span class="line">   action();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的值均为3.</p><p>从C#5.0开始，foreach认为循环变量都是新的变量，所以每次循环中创建委托时捕获的变量都不是同一个变量，比如如下的代码：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] names =newstring[] &#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">List&lt;Action&gt; levyActions =<span class="keyword">new</span> List&lt;Action&gt;();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> namein names)</span><br><span class="line">&#123;</span><br><span class="line">   levyActions.Add(()=&gt; name.Dump());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出值为”1，2，3”</p><h3 id="闭包原理">闭包原理</h3><p>分析IL代码我们可以得知，编译器在背后生成了一个私有的密封类c__DisplayClass4_0，它将外部变量包装成类的成员变量，而委托方法包装成类的方法。所以，上述捕获for迭代变量的示例代码就可以修改成如下：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> List&lt;Action&gt; levyActions =<span class="keyword">new</span> List&lt;Action&gt;();</span><br><span class="line"> c__DisplayClass4_0 local =<span class="keyword">new</span> c__DisplayClass4_0();</span><br><span class="line"><span class="keyword">for</span> (local.i = <span class="number">0</span>; local.i &lt; <span class="number">3</span>; local.i++)</span><br><span class="line"> &#123;</span><br><span class="line">    levyActions.Add(() =&gt; local.Main_b__0());</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">foreach</span> (Action actionin levyActions)</span><br><span class="line"> &#123;</span><br><span class="line">    action();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">c__DisplayClass4_0</span>&#123;</span><br><span class="line">publicint i;</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">Main_b__0</span>(<span class="params"></span>)<span class="comment">//使用interval关键字，限制只能在同一程序集内访问</span></span></span><br><span class="line"> &#123;</span><br><span class="line">    i.Dump();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用ildasm工具分析实例代码：">使用ildasm工具分析实例代码：</h3><p>在课上老师带我们分析了如下的实例代码：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//相当于 int fnAdd(int a, int b);</span></span><br><span class="line"><span class="comment">//public delegate TResult Func&lt;in T1, in T2, out TResult&gt;(T1 arg1, T2 arg2);</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; <span class="title">someFunc</span>(<span class="params"><span class="built_in">int</span> one</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> two = <span class="number">500</span>;</span><br><span class="line"><span class="comment">//返回函数(委托)使用lamda表达式</span></span><br><span class="line"><span class="keyword">return</span> (o1, o2) =&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//使用外部变量</span></span><br><span class="line">two += one;</span><br><span class="line"><span class="keyword">return</span> one + two + o1 + o2;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;返回函数,使用外部变量&quot;</span>);</span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; fnOne = someFunc(<span class="number">500</span>);</span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; fnTwo = someFunc(<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">int</span> r1 = fnOne(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">int</span> r2 = fnTwo(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;r1: <span class="subst">&#123;r1&#125;</span>  r2: <span class="subst">&#123;r2&#125;</span>&quot;</span>);</span><br><span class="line">r1 = fnOne(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">r2 = fnTwo(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;r1: <span class="subst">&#123;r1&#125;</span>  r2: <span class="subst">&#123;r2&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先分析<code>someFunc</code>，该函数返回一个通用委托，其函数签名为以两个<code>int</code>作为参数，返回一个<code>int</code>，因此该函数内使用了闭包，用匿名函数返回，匿名函数中使用了作用域外的<code>two</code>变量。</p><p>在Main()函数中，定义了两个通用委托<code>fnOne</code> <code>fnTwo</code>,因此分别有两个变量two，在不同的存储空间地址，我们暂时命名为<code>two1</code> <code>two2</code> .之后定义了两个<code>int</code>调用委托，委托内的表达式首次被执行，此时委托对外部变量进行相加操作，因此<code>two1</code> <code>two2</code>变为1000和1500，因此<code>r1</code>和<code>r2</code>分别为1503和2503.之后再次调用委托，因此<code>r1</code>和<code>r2</code>变为了2503和3503.</p><p>因此整个<code>Main()</code>的输出结果如下：</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720220317133315.png" alt=""></p><p>此时我们打开ildasm工具，代开项目空间内的<code>dll</code>文件，查看<code>test.cs</code>的IL代码，首先我们发现里面新定义了一个类，如下所示：</p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720220317133534.png" style="zoom:67%;" /><p>定义了一个私有类<code>c_DisplayClass0_0</code>将外部变量定义为内部的成员变量，查看SommFunc的代码，如下所示：</p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720220317133656.png" style="zoom:67%;" /><p>我们可以发现函数内调用的均为类中的成员变量<code>two</code>和<code>one</code></p><p>打开其运行时代码，如下所示：</p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720220317134023.png" style="zoom:67%;" /><p>可以看到在函数中创建了一个该类的实例，局部变量实际上是作为匿名类中的字段存在的。</p><h3 id="C-7-0对于不作为返回值的闭包的优化">C#7.0对于不作为返回值的闭包的优化</h3><p>如果在vs2017中编写匿名函数时会得到一个提示，询问是否把lambda表达式（匿名函数）托转为本地函数。本地函数是c#7提供的一个新语法。</p><p>此时若使用反编译工具分析，可以发现有如下两点变化：</p><ol><li>定义的类变为定义临时结构体</li><li>不再构建委托实例，直接调用值类型的实例方法</li></ol><p>上述这两点变化在一定程度上能够带来性能的提升，目前的理解是，<strong>用结构体代替类，结构体实例能够在方法跑完后就立即释放，不需要等待垃圾回收</strong>，所以在官方的推荐中，如果委托的使用不是必要的，更推荐使用本地函数而非匿名函数。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蔚来面试问题记录</title>
      <link href="/2022/03/11/weilai/"/>
      <url>/2022/03/11/weilai/</url>
      
        <content type="html"><![CDATA[<h1>蔚来前端实习生面试流程</h1><p>2022年3月11日，睡午觉到四点后，四点半迎来了自己人生中第一场实习面试。进飞书和老师打招呼后，老师直截了当地给我发了题目地址，进行1小时的javascript题目测试，14道做出来5道就行。（这个东西，dddd，《提前准备》）</p><p>半小时做完题目后，（没有自我介绍环节），面试官直接让我简单介绍一下自己的项目（其实是他提了下项目，我主动说要介绍的），我当时是只介绍了我做的部分，花了两三分钟介绍完后，面试官就开始问题轰炸了。连续轰炸了一小时…</p><p>凭我仅存的记忆，他大概问了这些问题：</p><ol><li><strong>阐述一下Vue的生命周期</strong>（答得不好，没怎么看过这块，就直说了created，mounted这些）</li><li><strong>谈谈js中this</strong></li><li><strong>如何通过SSO的机制实现网站通过搜索引擎可以直接搜索到</strong>（当时以为是网站收录，结果说了一堆面试官说不是想要的答案，就不知道了）</li><li><strong>如何实现组件化设计，比如首页的这些卡片，如何写能够使其他地方服用，即如何封装成一个组件</strong>（也没有答得很好，因为确实没有封装过组件，最后老师转而问组件之间的沟通方式）</li><li><strong>组件之间是如何沟通的</strong>（算是答出来了，v-bind,props这些）</li><li><strong>如何让图片以不进行任何压缩的形式展示到网页上，以个人主页上上传的图片预览如何不压缩为例</strong>（想了半天，最后憋出来fit属性居然就是老师想要的答案）</li><li><strong>对于页面某些关键信息，可以通过什么手段来防止非法访客窃取信息？</strong>（当时答了加密和反爬，感觉老师还想要答案）</li><li><strong>对于一组v-for的div，有哪些方法实现除了第一个div的margin-top为0以外其他的div均有margin-top</strong>（第一时间想到了grid布局，然后是js实现，最后老师提示了好久憋出来可以用css选择器）</li><li><strong>开始问什么是css选择器，什么是伪css元素</strong>（没学过，不知道）</li><li><strong>表单如何实现默认信息的填入</strong>（因为看我没有实现默认信息的填入）</li><li><strong>侧边栏的动画咋实现的</strong>（纯css）</li><li>**如何实现keep alive，大概就是如何实现点击到另外一个页面再回来的时候还能显示上次显示的信息，避免再次调api，尤其是手机端很常用（**扯了半天localstorage,最后说不知道）</li><li><strong>顶栏的选中状态，如点击到论坛，论坛显示被选中的样式，当跳转到不同的页面时，这个被选中的状态是如何被保存的</strong>（没答出来…）</li><li><strong>js如何快速获取一组数组内为偶数的元素</strong>(最开始说foreach,map，经过提示说了filter)</li><li><strong>阐述一下网页的整个登录如何实现的</strong>(token)</li><li><strong>你们的项目是如何存的登陆状态的</strong>（没答好）</li><li><strong>如何实现点击回到顶部，并且要求非线性动画</strong>（说了下自己作wiki的经历）</li><li><strong>首页鼠标移入头像旋转是如何实现的</strong></li><li><strong>如何实现某一动画的循环播放</strong></li><li><strong>什么是computed</strong>(没答好)</li><li><strong>什么是非同源，什么是同源，什么是跨域，什么是同站</strong>（乱答的）</li><li><strong>你还有啥想问的</strong>（问了下蔚来前端的主要业务范围）</li><li><strong>一周能来几天，来不了三天gun</strong></li></ol><p>希望能进</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说健身这件事</title>
      <link href="/2022/03/09/muscle/"/>
      <url>/2022/03/09/muscle/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 运动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 撸铁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些日常跑步记录</title>
      <link href="/2022/03/09/running-1/"/>
      <url>/2022/03/09/running-1/</url>
      
        <content type="html"><![CDATA[<p>从2022年3月9号开始，记录一下自己每天的日常跑步吧~<br>至于为什么要选择这一天作为记录的第一天，因为咱们的汪汪汪今天开始跑步了！！！建议把3.9号定一个纪念日</p><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2022</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-09</p></div></div><div class='timeline-item-content'><p>有氧轻松跑–绕着体育场跑了4.38公里，用时20：47，平均配速4：44，步频172步幅122，平均心率180；还是不习惯路跑，各种上下坡和拐弯消耗了很多体力，然后心率还是居高不下哇，是因为自己跑的太用力吗？</p><div class="fj-gallery"><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220309234903644.png" alt="image-20220309234903644"><br><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220309235034152.png" alt="image-20220309235034152"></p>          </div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-11</p></div></div><div class='timeline-item-content'><p>日常刷锻&amp;两公里训练，2.02公里，用时7分52，平均配速3：53，步频172步幅149和上次步频一样但是步幅提升很多，平均心率177；今天状态很不错，也是最近2000m跑的最快的一次了，跑完很有成就感！</p><div class="fj-gallery"><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220314201304004.png" alt="image-20220314201304004"></p>          </div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-12</p></div></div><div class='timeline-item-content'><p>日常刷锻&amp;两公里训练，2.0公里，用时8分21，平均配速4分10，步频163步幅147和上次步幅差不多但是步频慢了很多，平均心率170；为什么慢了这么多呢？因为今天穿的便装哈哈哈！长袖长裤老爹鞋，能跑快才怪了</p><div class="fj-gallery"><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220314201552814.png" alt="image-20220314201552814"></p>          </div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-13</p></div></div><div class='timeline-item-content'><p>第一次间歇跑！，2.0公里，用时6分26，平均配速3分17，五次400m的时间分别是1：15，1：16，1：16，1：19，1：20.前三次都还顶得住，但是到了第四次就很难受了，特别是第五次间歇的时候，甚至有种头晕的感觉，看来间歇跑一周不能练超过两次，不然真的顶不住，不过今天刚好是封操场的第一天，也练不了了哈哈哈</p><div class="fj-gallery"><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220314201948651.png" alt="image-20220314201948651"></p>          </div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-15</p></div></div><div class='timeline-item-content'><p>有氧跑，因为操场关了，所以很不情愿地去了体育馆hh，5.31km,用时14：14，配速4：33，差不多时配速递增这样子，步频168步幅130，心率178，最大心率187，步频没提起来步幅还下降了，不过是有氧跑，管他呢？</p><div class="fj-gallery"><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/IMG_9993.PNG" alt="IMG_9993"><br><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/IMG_9985.PNG" alt="IMG_9985"></p>          </div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-23</p></div></div><div class='timeline-item-content'><p>最近一周基本都在下雨，所以属于是偷懒一周了hhh。“风静了，雨停了，梁乔回来了！”笑死就不碰刘翔大哥的瓷了。今晚想看下自己一小时能跑多远，因为以前很少跑过真有氧，其实都是速耐。先上结果吧：14.29km,用时65:57，平均配速4:36,步频172（这次步频很满意！）步幅126cm，心率188（心率真的不行，最后冲刺干到202了，对身体不好）。说实话挺惊讶的，没想到自己的速度没有因为距离拉长慢多少，但是这个心率肯定是不正常的，说明我基本是靠硬撑跑完全程。这样对身体的伤害是很大的。所以后面会把注意力更多放在心率的控制吧。</p><div class="fj-gallery"><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220407092251169.png" alt="image-20220407092251169"><br><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220407092330719.png" alt="image-20220407092330719"><br><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220407092415928.png" alt="image-20220407092415928"></p>          </div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-30</p></div></div><div class='timeline-item-content'><p>说实话上次跑步小腿吃不消了。后面的一周小腿特别是后侧都很疼，每天都用筋膜枪恢复。今晚以为恢复了又去跑步了，没想到一跑腿又开始疼。哎，看来长距离不是那么好跑的啊。还是说下情况吧，3.77km,配速5:03，步频169，步幅1.16，心率164（稍微降下来了一点，这个倒是不错）</p><div class="fj-gallery"><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220407093119444.png" alt="image-20220407093119444"><br><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220407093146109.png" alt="image-20220407093146109"></p>          </div></div></div></div><p>哎，咱学校内有疫情了，现在直接被封在寝室。不过腿倒是恢复好了，静候解封！<br>听我说谢谢你因为有你温暖了四季谢谢你感谢有你世界更美丽🌏🌏🌏我要谢谢你因为有你爱常在心底谢谢你 感谢有你把幸福传递</p>]]></content>
      
      
      <categories>
          
          <category> 运动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中长跑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web端服务器部署基本步骤</title>
      <link href="/2022/03/07/screen/"/>
      <url>/2022/03/07/screen/</url>
      
        <content type="html"><![CDATA[<h1>服务器部署常用指令</h1><p>常常面临前后端（特别是后端）部署到服务器的需求，每次部署的时候都到处搜指令，效率十分低下，所以就在这个博客里面慢慢记录一些常用的指令吧。</p><p>参考：</p><p><a href="https://www.runoob.com/linux/linux-comm-screen.html">Linux screen命令 | 菜鸟教程 (runoob.com)</a></p><h2 id="后端（Spring-cloud）ubuntu服务器部署">后端（Spring cloud）ubuntu服务器部署</h2><p>首先在本地build相应的<code>jar</code>文件，然后在服务器的<code>\root</code>目录新建一个文件夹（用于放置你项目的所有文件）然后放入build的<code>jar</code>包。</p><h3 id="新建screen会话">新建screen会话</h3><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720220307185958.png" alt=""></p><p>使用</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctrl+a d键</span><br></pre></td></tr></table></figure><p>退出当前会话</p><p>运行每一个jar包在独立的screen，就完成部署了</p><h3 id="删除会话">删除会话</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">screen -X -S $tr_name quit</span><br></pre></td></tr></table></figure><h2 id="前端部署">前端部署</h2><p>本地运行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>然后会生成一个<code>dist</code>文件</p><p>放进服务器相应的文件里面</p><p>然后开启nginx服务，具体安装和配置方法参考网站。</p><p>大概是首先修改confi文件，然后干嘛…反正不难</p><p>更新中…</p>]]></content>
      
      
      <categories>
          
          <category> 技术博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html/css/js三件套复习--grid布局</title>
      <link href="/2022/03/05/grid/"/>
      <url>/2022/03/05/grid/</url>
      
        <content type="html"><![CDATA[<h1>CSS Grid 网格布局教程</h1><p>还有一个月就开始蓝桥杯了。为了血洗”如何看待蓝桥杯只拿三等奖“之耻，是时候复习下三件套啦！</p><blockquote><p>教程来源：CSS grid网格布局教程 --阮一峰的博客</p></blockquote><p>另外推荐一个学习grid布局的网站：scrima，这个网站本来是首收费（$108）但是唯独grid布局是免费的！</p><p><a href="https://scrimba.com/learn/cssgrid/intro-to-the-css-grid-course-cg9PpTb">Intro to the CSS Grid course - Scrimba.com</a></p><p>体验了一下，这个网站做的很牛逼，直接把可编辑的代码和视频教学结合在了一起，值得一试！</p><h2 id="1-Grid-与-Flex-的区别">1 Grid 与 Flex 的区别</h2><p>Flex 布局是轴线布局，只能指定&quot;项目&quot;针对轴线的位置，可以看作是<strong>一维布局</strong>。Grid 布局则是将容器划分成&quot;行&quot;和&quot;列&quot;，产生单元格，然后指定&quot;项目所在&quot;的单元格，可以看作是<strong>二维布局</strong>。Grid 布局远比 Flex 布局强大。</p><h2 id="2-基本概念">2 基本概念</h2><h3 id="2-1-容器和项目">2.1 容器和项目</h3><p>采用网格布局的区域，称为&quot;容器&quot;（container）。容器内部采用网格定位的子元素，称为&quot;项目&quot;（item）</p><p>项目只能是容器的顶层子元素，不包含项目的子元素，Grid 布局只对项目生效。</p><h3 id="2-2-行和列">2.2 行和列</h3><p><img src="https://www.wangbase.com/blogimg/asset/201903/1_bg2019032502.png" alt="img"></p><p>容器里面的水平区域称为&quot;行&quot;（row），垂直区域称为&quot;列&quot;（column）。</p><h3 id="2-3-单元格和网格线">2.3 单元格和网格线</h3><p>行和列的交叉区域，称为&quot;<strong>单元格</strong>&quot;（cell）。划分网格的线，称为&quot;<strong>网格线</strong>&quot;（grid line）。水平网格线划分出行，垂直网格线划分出列。</p><h2 id="3-容器属性">3 容器属性</h2><h3 id="3-1-display属性">3.1 display属性</h3><p><code>display: grid</code>指定一个容器采用网格布局。</p><p>默认情况下，容器元素都是块级元素，但也可以设成行内元素。</p><ul><li><p>容器是块级元素</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032504.png" alt="img"></p></li><li><p>容器是行内元素</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032505.png" alt="img"></p></li></ul><p>​</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，设为网格布局以后，容器子元素（项目）的<code>float</code>、<code>display: inline-block</code>、<code>display: table-cell</code>、<code>vertical-align</code>和<code>column-*</code>等设置都将失效。</p><h3 id="3-2-grid-template-columns-属性，-grid-template-rows-属性">3.2 grid-template-columns 属性， grid-template-rows 属性</h3><p>容器指定了网格布局以后，接着就要划分行和列。<code>grid-template-columns</code>属性定义每一列的列宽，<code>grid-template-rows</code>属性定义每一行的行高。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  grid-template-rows: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了使用绝对单位，也可以使用百分比。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">33.33%</span> <span class="number">33.33%</span> <span class="number">33.33%</span>;</span><br><span class="line">  grid-template-rows: <span class="number">33.33%</span> <span class="number">33.33%</span> <span class="number">33.33%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用<code>repeat()</code>函数简化写法：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">33.33%</span>);</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">2</span>, <span class="number">100px</span> <span class="number">20px</span> <span class="number">80px</span>);</span><br></pre></td></tr></table></figure><h4 id="auto-fill-关键字">auto-fill 关键字</h4><p>有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用<code>auto-fill</code>关键字表示自动填充。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(auto-fill, <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="grid中auto-fit和auto-fill的区别"><strong>grid中auto-fit和auto-fill的区别</strong></h4><pre><code>auto-fill:在轨道重复过程中，尽可能多的根据元素创建轨道，如果创建的轨道数量是小数比如6.5，那么0.5就被称为剩余空间，剩余的空间不够一个轨道了，就相当于每个轨道1fr进行分配这个0.5的剩余空间，没有元素填充的空轨道不会折叠依然保留（相当于留了空白）。auto-fit:在轨道重复过程中，尽可能多的根据元素创建轨道，并均分不到一个轨道的剩余空间。轨道分配完以后如果轨道中没有元素则将所有没有元素填充的空轨道折叠为0，即把没有元素填充的空轨道全被分配给有元素的轨道（相当于有元素填充的轨道全部为1fr）。最后没有空轨道剩余</code></pre><p><strong>scrima中给出的直观解释：</strong></p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305215542906.png" alt="image-20220305215542906"></p><h4 id="auto-fit关键字">auto-fit关键字</h4><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305210303497.png" alt="image-20220305210303497"></p><p>这个写法真的很棒！！！</p><p><a href="https://scrimba.com/learn/cssgrid/auto-fit-and-minmax-css-grid-tutorial-cg92LA6">Auto-fit and minmax - CSS Grid tutorial - Scrimba.com</a></p><p><code>minmax</code>的加入使得每个块可以根据屏幕大小变化宽度适应整个画面</p><h4 id="fr关键字">fr关键字</h4><p>为了方便表示比例关系，网格布局提供了<code>fr</code>关键字（fraction 的缩写，意为&quot;片段&quot;）。如果两列的宽度分别为<code>1fr</code>和<code>2fr</code>，就表示后者是前者的两倍。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">150px</span> <span class="number">1</span>fr <span class="number">2</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="minmax">minmax()</h4><p><code>minmax()</code>函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="built_in">minmax</span>(<span class="number">100px</span>, <span class="number">1</span>fr);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>minmax(100px, 1fr)</code>表示列宽不小于<code>100px</code>，不大于<code>1fr</code>。</p><h4 id="auto关键字">auto关键字</h4><p><code>auto</code>关键字表示由浏览器自己决定长度。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> auto <span class="number">100px</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了<code>min-width</code>，且这个值大于最大宽度。</p><h4 id="grid-template">grid-template</h4><p>是<code>grid-template-columns</code>和<code>grid-template-rows</code>的合体，比如下面的写法：</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305160832455.png" alt="image-20220305160832455"></p><p>可以想象使用”L“绘制网页：先规定rows也就是纵向，后规定columns也就是横向。</p><h4 id="网格线的名称">网格线的名称</h4><p><code>grid-template-columns</code>属性和<code>grid-template-rows</code>属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: [c1] <span class="number">100px</span> [c2] <span class="number">100px</span> [c3] auto [c4];</span><br><span class="line">  grid-template-rows: [r1] <span class="number">100px</span> [r2] <span class="number">100px</span> [r3] auto [r4];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。</p><p>网格布局允许同一根线有多个名字，比如<code>[fifth-line row-5]</code>。</p><h4 id="布局实例">布局实例</h4><p><code>grid-template-columns</code>属性对于网页布局非常有用。两栏式布局只需要一行代码。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">70%</span> <span class="number">30%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码将左边栏设为70%，右边栏设为30%。</p><p>传统的十二网格布局，写起来也很容易。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">12</span>, <span class="number">1</span>fr);</span><br></pre></td></tr></table></figure><h3 id="3-3-grid-row-gap属性-grid-colum-gap属性，grid-gap属性">3.3 grid-row-gap属性 grid-colum-gap属性，grid gap属性</h3><p><code>row-gap</code>属性设置行与行的间隔（行间距），<code>column-gap</code>属性设置列与列的间隔（列间距）。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    row-gap: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">column-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gap</code>属性为两个属性的合并简写形式：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  grid-gap: <span class="number">20px</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-grid-template-areas属性">3.4 grid-template-areas属性</h3><p>网格布局允许指定&quot;区域&quot;（area），一个区域由单个或多个单元格组成。<code>grid-template-areas</code>属性用于定义区域。</p><p>下面是一个布局实例。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-areas: <span class="string">&quot;header header header&quot;</span></span><br><span class="line">                     <span class="string">&quot;main main sidebar&quot;</span></span><br><span class="line">                     <span class="string">&quot;footer footer footer&quot;</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，顶部是页眉区域<code>header</code>，底部是页脚区域<code>footer</code>，中间部分则为<code>main</code>和<code>sidebar</code>。</p><p>如果某些区域不需要利用，则使用&quot;点&quot;（<code>.</code>）表示。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-areas: <span class="string">&#x27;a . c&#x27;</span></span><br><span class="line">                     <span class="string">&#x27;d . f&#x27;</span></span><br><span class="line">                     <span class="string">&#x27;g . i&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。</p><p>注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为<code>区域名-start</code>，终止网格线自动命名为<code>区域名-end</code>。</p><p>比如，区域名为<code>header</code>，则起始位置的水平网格线和垂直网格线叫做<code>header-start</code>，终止位置的水平网格线和垂直网格线叫做<code>header-end</code>。</p><h3 id="3-5-grid-auto-flow属性">3.5 grid-auto-flow属性</h3><p>grid-auto-flow决定了容器的子元素放入的顺序，默认为”先行后列“。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-<span class="attribute">auto</span>-flow: column;</span><br></pre></td></tr></table></figure><p>这样就变成先列后行</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032513.png" alt="img"></p><p>如上所示的效果</p><p>使用了如下的css:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#container</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  grid-template-rows: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  grid-<span class="attribute">auto</span>-flow: row;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ef342a</span>;</span><br><span class="line">  grid-column-start: <span class="number">1</span>;</span><br><span class="line">  grid-column-end: <span class="number">3</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item-2</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f68f26</span>;</span><br><span class="line">  grid-column-start: <span class="number">1</span>;</span><br><span class="line">  grid-column-end: <span class="number">3</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>grid-column-start</code>和<code>grid-column-end</code>让1和2 占据了两个单元格</p><p>现在修改设置，设为<code>row dense</code>，表示&quot;先行后列&quot;，并且尽可能紧密填满，尽量不出现空格。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-<span class="attribute">auto</span>-flow: row dense;</span><br></pre></td></tr></table></figure><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032514.png" alt="img"></p><p>上图会先填满第一行，再填满第二行，所以3号项目就会紧跟在1号项目的后面。8号项目和9号项目就会排到第四行。</p><h4 id="使用dense实现照片墙的例子">使用dense实现照片墙的例子</h4><p><a href="https://scrimba.com/learn/cssgrid/an-awesome-image-grid-css-grid-tutorial-cBq3PsP">An awesome image grid - CSS Grid tutorial - Scrimba.com</a></p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305213136445.png" alt="image-20220305213136445"></p><h3 id="3-6-justify-items，align-items-place-items属性">3.6 justify-items，align-items,place-items属性</h3><p><code>justify-items</code>属性设置单元格内容的水平位置（左中右），<code>align-items</code>属性设置单元格内容的垂直位置（上中下）。</p><p>这两个属性的写法完全相同，都可以取下面这些值。</p><ul><li>start：对齐单元格的起始边缘。</li><li>end：对齐单元格的结束边缘。</li><li>center：单元格内部居中。</li><li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  justify-items: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032516.png" alt="img"></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示，单元格的内容头部对齐，效果如下图。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032517.png" alt="img"></p><p><code>place-items</code>属性是<code>align-items</code>属性和<code>justify-items</code>属性的合并简写形式。如：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-items: start end;</span><br></pre></td></tr></table></figure><h3 id="3-7-justify-content-align-content-place-content属性">3.7 justify-content,align content,place-content属性</h3><p>先上一个有趣的教程示例：</p><p><a href="https://scrimba.com/learn/cssgrid/justify-content-and-align-content-css-grid-tutorial-cGpB8t7">justify-content and align-content - CSS Grid tutorial - Scrimba.com</a></p><p><code>justify-content</code>属性是整个内容区域在容器里面的水平位置（左中右），<code>align-content</code>属性是整个内容区域的垂直位置（上中下）。</p><p>这两个属性的写法完全相同，都可以取下面这些值。（下面的图都以<code>justify-content</code>属性为例，<code>align-content</code>属性的图完全一样，只是将水平方向改成垂直方向。）</p><blockquote><ul><li>start - 对齐容器的起始边框。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032519.png" alt="img"></p><blockquote><ul><li>end - 对齐容器的结束边框。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032518.png" alt="img"></p><blockquote><ul><li>center - 容器内部居中。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032520.png" alt="img"></p><blockquote><ul><li>stretch - 项目大小没有指定时，拉伸占据整个网格容器。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032521.png" alt="img"></p><blockquote><ul><li>space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032522.png" alt="img"></p><blockquote><ul><li>space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032523.png" alt="img"></p><blockquote><ul><li>space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032524.png" alt="img"></p><p><code>place-content</code>属性是<code>align-content</code>属性和<code>justify-content</code>属性的合并简写形式。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-<span class="attribute">content</span>: &lt;align-content&gt; &lt;justify-content&gt;</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-<span class="attribute">content</span>: space-around space-evenly;</span><br></pre></td></tr></table></figure><h3 id="3-8-grid-auto-columns，grid-auto-rows属性">3.8 grid-auto-columns，grid-auto-rows属性</h3><p>有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。</p><p><code>grid-auto-columns</code>属性和<code>grid-auto-rows</code>属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与<code>grid-template-columns</code>和<code>grid-template-rows</code>完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p><p>例子：</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305211409763.png" alt="image-20220305211409763"></p><h2 id="4-项目属性">4 项目属性</h2><p>下面这些属性定义在项目上面。</p><h3 id="4-1-grid-row-start，grid-row-end属性">4.1 grid-row-start，grid-row-end属性</h3><p>项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。</p><ul><li><code>grid-column-start</code>属性：左边框所在的垂直网格线</li><li><code>grid-column-end</code>属性：右边框所在的垂直网格线</li><li><code>grid-row-start</code>属性：上边框所在的水平网格线</li><li><code>grid-row-end</code>属性：下边框所在的水平网格线</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  grid-column-start: <span class="number">2</span>;</span><br><span class="line">  grid-column-end: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032526.png" alt="img"></p><p>比如上面的指定了左右边框所在的网格线。</p><p>除了1号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的<code>grid-auto-flow</code>属性决定，这个属性的默认值是<code>row</code>，因此会&quot;先行后列&quot;进行排列。读者可以把这个属性的值分别改成<code>column</code>、<code>row dense</code>和<code>column dense</code>，看看其他项目的位置发生了怎样的变化。</p><p><a href="https://jsbin.com/yukobuf/edit?css,output">JS Bin - Collaborative JavaScript Debugging</a></p><p>可点击如上的网址进行理解和练习。</p><p>这四个属性的值还可以使用<code>span</code>关键字，表示&quot;跨越&quot;，即左右边框（上下边框）之间跨越多少个网格。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  grid-column-start: span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这四个属性，如果产生了项目的重叠，则使用<code>z-index</code>属性指定项目的重叠顺序。</p><h3 id="4-2-grid-column属性，grid-row属性">4.2 grid-column属性，grid-row属性</h3><p><code>grid-column</code>属性是<code>grid-column-start</code>和<code>grid-column-end</code>的合并简写形式，<code>grid-row</code>属性是<code>grid-row-start</code>属性和<code>grid-row-end</code>的合并简写形式。</p><h3 id="4-3-grid-area属性">4.3 grid-area属性</h3><p><code>rid-area</code>属性还可用作<code>grid-row-start</code>、<code>grid-column-start</code>、<code>grid-row-end</code>、<code>grid-column-end</code>的合并简写形式，直接指定项目的位置。</p><blockquote><p>.item {<br>grid-area: <row-start> / <column-start> / <row-end> / <column-end>;<br>}</p></blockquote><p>下面是一个<a href="https://jsbin.com/duyafez/edit?css,output">例子</a>。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  grid-area: <span class="number">1</span> / <span class="number">1</span> / <span class="number">3</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，scimba网站还给出了grid-area的另一种用法：</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305203819913.png" alt="image-20220305203819913"></p><p><strong>另外一个有趣的用法</strong></p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305213953945.png" alt="image-20220305213953945"></p><h3 id="4-4-justify-self，align-self-place-self属性">4.4 justify-self，align-self,place-self属性</h3><p><code>justify-self</code>属性设置单元格内容的水平位置（左中右），跟<code>justify-items</code>属性的用法完全一致，但只作用于单个项目。</p><p><code>align-self</code>属性设置单元格内容的垂直位置（上中下），跟<code>align-items</code>属性的用法完全一致，也是只作用于单个项目。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  justify-self: start | end | center | stretch;</span><br><span class="line">  <span class="attribute">align-self</span>: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个属性都可以取下面四个值。</p><ul><li>start：对齐单元格的起始边缘。</li><li>end：对齐单元格的结束边缘。</li><li>center：单元格内部居中。</li><li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li></ul><p>下面是<code>justify-self: start</code>的例子。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span>  &#123;</span><br><span class="line">  justify-self: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032532.png" alt="img"></p><p><code>place-self</code>属性是<code>align-self</code>属性和<code>justify-self</code>属性的合并简写形式。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-self: &lt;align-self&gt; &lt;justify-self&gt;;</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-self: center center;</span><br></pre></td></tr></table></figure><p>如果省略第二个值，<code>place-self</code>属性会认为这两个值相等。</p><h2 id="5-scrima上面的示例">5 scrima上面的示例</h2><p><a href="https://scrimba.com/learn/cssgrid/positioning-items-css-grid-tutorial-cbVn4t4">Positioning items - CSS Grid tutorial - Scrimba.com</a></p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305161906343.png" alt="image-20220305161906343"></p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305162045130.png" alt="image-20220305162045130"></p><h2 id="6-flex-和-grid配合使用">6 flex 和 grid配合使用</h2><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/image-20220305220701719.png" alt="image-20220305220701719"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个梦---谈谈保留这首歌</title>
      <link href="/2022/03/02/emo202232/"/>
      <url>/2022/03/02/emo202232/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-rhbCDvRy" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="442869203" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#FF4081"    ></div><p>2022年3月2日23：59分。</p><p>刚才在寝室洗衣服时，耳机里放着网易云”我喜欢“的歌单，随机播放。因为我的歌单里有很多首歌，快1000首了，大抵都是听一遍觉得不错便扔进了歌单里，所以每次随机播放时，都能稍稍体会到好奇下一首是哪首歌的快感</p><p>突然脑海里播放了这首歌。<br>郭顶的《保留》。这首歌没有前奏，不给人任何心理准备，一来就是“看见，你在我眼前。”<br>听后遍有一种心里很沉重很难受的感觉。是的，因为这首歌以它的方式提醒我：我三年来一直秉持的信仰和坚持（虽然中途放弃过），破碎了。<br>我本以为我快要走出来了，可是一听到这首歌，立马发现自己还在原地踏步，并且还时不时地回头看。<br>三年前，我和她走在大学路的街道上，突然听见远方唱歌的声音。一位弹着吉他的流浪歌手，唱着《保留》，声音低沉悠扬。我们当时不知道这首歌，但都被歌词和旋律深深吸引。一首歌，几句歌词，让两个人的世界第一次相交，碰撞，重叠，燃烧。<br>这首歌一听就是三年，两个人。在四平路，在嘉定。在呼伦贝尔，在成都的夜晚。在中国。在法国。<br>最终歌曲放完了。对我而言很像是一场梦，有时候会觉得是噩梦想要抽离，可真的快抽离时却发现自己十分迷恋，想一直做下去。<br>正当自己认为这场梦可以一直做，做到毕业，做到工作，做到自己有自己的一片乐土时，它碎了。<br>可能自己心里真的未放下吧，所以写的十分的抽象。或许有一天自己真正放下向前看的时候，这个梦会变得越来越清晰，清晰到我能够真正真切地去面对，能真正的觉得它是一段美好的回忆。</p><p>好了，抽象emo结束。有一说一，这首歌我还是很喜欢的。郭顶是我很喜欢的歌手，而这首歌也是他的歌里面我最喜欢的。下面是他的完整歌词，因为个人经历会觉得歌词承载的太多，不敢去过度理解，不过不影响这真的是一首好作品。</p><p>不emo了，明早还有游泳课，有的爽了。</p><p>看见 你在我眼前</p><p>不去猜想我们隔多远</p><p>当我 夜幕中准备</p><p>只想让沉默的能开解</p><p>在不同的遭遇里我发现你的瞬间</p><p>有种不可言说的温柔直觉</p><p>在有限的深夜消失之前触摸你的脸</p><p>我情愿这是幻觉 也不愿是种告别</p><p>已经忘了 你的名字</p><p>就在这座 寂静星石</p><p>怎么还有 你的样子</p><p>被保留</p><p>给我 一整个拥抱</p><p>好让我不至于 太潦倒</p><p>时间 过一分一秒</p><p>还是觉得相遇 太美好</p><p>在不同的遭遇里我发现你的瞬间</p><p>有种不可言说的温柔直觉</p><p>当不远的蓝色渐渐显现这无边境界</p><p>我始终等待再见 只不愿再也不见</p><p>已经忘了 你的名字</p><p>就在这座 寂静星石</p><p>怎么还有 你的样子</p><p>想形容你的句子 关于你所有心事</p><p>一眼能及的钻石 哪一个是你地址</p><p>忘了 你的名字</p><p>就在这座 寂静星石</p><p>怎么还有 你的样子</p><p>我始终等待再见 只不愿再也不见</p><p>真的忘了 你的名字</p><p>是在哪座 寂静星石</p><p>一直还有 你的样子</p><p>被保留</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> emo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>被讨厌的勇气--读书心得</title>
      <link href="/2022/03/02/book1/"/>
      <url>/2022/03/02/book1/</url>
      
        <content type="html"><![CDATA[<p>最近受某位同学的推荐阅读了这本书，通篇大部分为一个年轻人和哲人的对话，初读感觉里面讲的人生哲学非常的唯心主义，他否定了过去经历和所处环境对人性格形成的影响，而将我们后来对自己”人设“的认知和性格的形成归结为我们自己的选择。说实话，这种观点目前我是无法苟同的，不过现在还没读完这本书，等读完了在这里记录一下看法和感受吧！</p><p>虽然不会承认，但我敢保证每个人都有过这样一个心理。“某个非常要好的朋友获得了比我更加厉害的成功，但是心里总是无法真心祝福过的幸福的他人”。说真的，我自己常常为这样的心理困惑，为什么自己总是不能真正地由内而外地为我好兄弟的成功感到由衷的祝福呢？可能自己潜意识把他当成了自己的竞争者，自己如果没有他成功，就代表自己失败了，所以别人成功的时候自己常常会有挫败感吧。不过本书最让我感到震惊的价值观还是哲人所说的目的论。</p><p>在看这本书之前，我是十分信奉原因论的。包括我骨子里的性格，都与我小时候的经历有关。我很相信原生家庭对一个人带来的不可忽视的影响。但书中的哲人用目的论解释了这一切。书里说，我们赋予过去的经历什么样的价值，比我们经历什么更为重要。经历是过去的客观存在，但无法真正决定我们未来的生活方式，也即性格。赋予过去的事情什么样的价值才是现在的我们面临的课题。</p><p>有句有关“爱的课题”的话我觉得说的很好。“当人能够感觉到‘与这个人在一起可以无拘无束的‘时候，才能够体会到爱。既没有自卑感也不必炫耀优越性，能够保持一种平静而自然的状态。真正的爱是这样的。”这让我会想起上一段没有结果的感情。现在想来，彼此好像都束缚的太多，我因为她，很多时候想和兄弟出去玩而不得。自己会尽自己最大的努力抽出时间陪她。扪心自问，自己是真的因为爱她而发自内心的想和她呆在一起而不是怕她生气吗？是的，我怕她生气。很多时候她陪我也是怕我会不高兴吧。两个人在一起的原因竟然成了一种负担，一种对对方不高兴的恐惧，这样相处真的很累。最近看的那部漫画，也是说一对情侣，男生和女生就快要结婚了，但是女生不想生孩子但男生想。男生知道女生不想生孩子的想法后很伤心，但是因为爱她，只好妥协。但是男生很不喜欢女生演戏，一方面是绝对这个职业太忙太累，另一方面是因为女生演戏会和其他男生交流，自己会吃醋。但演戏确实女生的梦想，自己的追求。男生很希望自己的未婚妻能为自己妥协，但是女生不答应。最后男生思考了很久，最后和女生分手了。可能认为这段感情就像是把彼此囚禁在了彼此设置的牢笼里吧，维护爱情付出的代价是不断妥协，甚至是妥协自己最珍惜的东西，那这段感情是否还需要继续下去呢？会想起自己过去的那段感情，无法无拘无束，总是担心自己会因为某些事情失去，患得患失。根本不是一种平静而自然的状态，或许分开是更好的选择吧。况且，她总说她在我面前很自卑，怕自己因为变胖我不喜欢她，怕自己不运动我会不喜欢她。过去她是喜欢运动的，但是现在我却赋予了运动沉重的意义，这样的压力压的她喘不过气。或许在外人看来这些话看起来很可笑，但就是这样的状态。这段感情的维护本身就需要彼此不断妥协，而不是一种自然而平静的状态，所以分开对彼此是最好的选择。</p>]]></content>
      
      
      <categories>
          
          <category> 读书心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说跑步这件事</title>
      <link href="/2022/03/01/running/"/>
      <url>/2022/03/01/running/</url>
      
        <content type="html"><![CDATA[<h2 id="说说为啥喜欢长跑">说说为啥喜欢长跑</h2><p>长跑这项运动算是高中的时候就喜欢上了吧。其实初中的时候挺讨厌长跑的，因为不及格，老师让我跳蛙跳。不服气呗，所以后来1000米就死命跑，心里想的就是拼了命也要超过别人。最后中考马马虎虎，刚好过线。</p><p>​高中的时候流行夜跑嘛，晚上下了课喜欢几个人约着一起到操场夜跑+散步。后来高三压力大了，我因为个人原因整个高三就蛮抑郁的，突然想起来初中跑1000米那种拼劲，和考试相比，这可能是唯一一个付出100%努力，就能跑的比别人快的事情了。同时跑步的时候可以什么都不想，当作白天学习后释放压力放空自己的活动很合适（并且我很喜欢那种跑步超过别人的感觉？）于是那时就开始每天夜跑，不多不少5公里。</p><p>​再后来到了高三上期中的时候，开始想在这方面出一点成绩，于是就拿起个小本本开始做计划（那个小本子其实是我的日记本，现在还在我宿舍的书架上）开始设定目标，设定每个阶段应该达成的进步（记得当时的目标是参加1500米校运会，跑到5：15秒以内，也就是每1000米3：30以内完成），然后还专门留了一页纸，画了一个坐标系，横轴是时间，纵轴是1500米所用分钟数，然后画了一个基准线就是5：15的时间，基准线还画在中间的位置，因为觉得自己可以练到更快。哈哈哈，当时设想的美好画面当然是一条单调递减的曲线，晚自习的时候瞎画在那里咯咯咯的笑。同桌看了笑出声：”别人写学习计划，你tmd写跑步计划，宁这是高三？“不过yysy，我高三就是压力太大了，其实超努力的qaq.</p><p>​理想很丰满，现实很艹蛋。我现在还记得那时第一次训练，1500米跑了6：18.整整比目标慢了一分钟。起点低没事，咱慢慢练嘛。结果呢，那个坐标系里压根就是条正弦曲线，一会跑到5：50，以后又回到6：20去了，就尼玛离谱，每次跑的时候还贼累。</p><p>​现在看来当时那根本就不叫训练，完全就是瞎练，不知道啥是间歇跑，不知道啥是力量训练。不过也算是死磕了吧（日记本好像忘家里了hehe，不过记得很清楚当时至少标注了三十个点），虽然没有一次到达过目标。</p><p>​然后就去报校运会了。笑死，本来1500米就是一个大家不愿意报的运动项目，又正值高三，大家都觉得主动报的要么是行为艺术要么就是想逃习题课。一般如果没人报的话就得抓壮丁了。我记得当时举手之后，大家像看救世主一样看我。这个班级又少了一次磨难。</p><p>​说句实话，当时心里很期待那种自己在赛场上拼（zhuang）搏(bi)，台下同学加油呐喊的感觉，懂得都懂，不懂的都不懂。不过很可惜，高三学业繁重，没有运动项目的同学就在教室自习不去操场了。当时心里还是挺失落的。（怎么说呢，可能是骨子里自卑，喜欢通过这件事获得别人的认可，我承认哈哈哈）不过班主任很人道主义，规定每个项目必须有至少两名同学陪同加油助威。带着这份感恩，我就穿上丝袜去操场参赛了。</p><p>​具体比赛细节就不说了哈，其实当时还有很多同学偷偷跑下来给我加油了，当时真的很热血，或许他们是我这份爱好养成的突出贡献者哈哈哈，最后5：18，第三名（高三大家的身体素质是真的普遍退步了）虽然没达到自己定的目标，不过真的很满意了。</p><p>​这件很不起眼的小事，为啥要这么罗嗦呢？说真的它真的算是我高三抑郁生活的一大精神支柱了。很多时候心态快崩的时候都靠跑步顶住了。</p><p>​大学算是轻松了，也就开始随便跑跑，偶尔参加参加学校的校园活动，偶尔看看训练技巧，大一校运会1500米马马虎虎5：03，第九名（刚好没奖状，哈哈），摸爬滚打到了现在。</p><p>所以说现在到底为啥喜欢长跑呢？<br><strong>喜欢到每次跑步必须把仪式感拉满，必须穿背心、短裤、紧身长袖长袜<br>喜欢到上学期直接跑到腿瘸（被xian哥多次警告别再练了hhh）<br>喜欢到像现在这样作为自己值得骄傲的一件事<br>它带给我的挺简单的，我在跑步的时候感受到自己尚存的自律和拼劲<br>找回自己其实并不经常存在的自信的状态<br>跑步的时候真的可以什么都不想 或者想明白一些平时想不明白的事情<br>唯一一点不喜欢的是<br>和健身增肌是冲突的！！！跑完能感觉到自己刚练的肌肉又掉了…</strong></p><h2 id="知乎的一篇回答">知乎的一篇回答</h2><p>​上学期（大三上）又是喜欢长跑到近乎狂热的一学期。为啥呢？因为我长胖了！！！长胖了！！！长胖了！！！能想象？一个千年玉米杆子因为一学期+一个暑假没咋运动直接有小肚子，135斤。想想以前经常长跑，还参加校运会，都快不认识这么肥宅的自己了。</p><p>​于是又是以增肌减脂为起因（这个时候也办了1年健身再健身的健身卡）开始慢慢恢复。刚开始跑步的时候那叫一个酸爽，跟双腿安了假肢一样，第一次跑了2公里，配速直接飞到6：30，那绝望是真的绝望。然后就继续死磕吧，每次都几乎用到90%的力气，死磕5公里，慢慢配速降到了4：30，算是可以接受的地步。</p><p>​也是在这个时候开始在知乎小破站学习训练速耐的技巧（暂时不敢接触半马这种长距离，怕腿受伤w），练习间歇跑。给自己定下的flag很简单：1000米体测3：10内。最后跑了3：06，说实话，真的超有成就感。在经历了长胖危机后，刷新了1000米速耐pb.</p><p>​之后带着这种自负和狂妄在知乎上发了篇回答：</p><p><a href="https://www.zhihu.com/question/325715679/answer/2088568177">(44 封私信 / 80 条消息) 大学生体测1000米满分（3分16秒）有多难? - 知乎 (zhihu.com)</a><br>上原回答：<br>2021.11.7号更新</p><p>今天下午去体测啦 听说上海今天要降温十多度 立马赶着降温前去测试了 当时下着小雨。</p><p>然后结果出来了<br><img src="https://pic1.zhimg.com/80/v2-ec606df9aec7585674236616f4e807e5_720w.jpg?source=1940ef5c" alt="img"></p><p>3:06 比上次的PB快了十秒…</p><p>算是了却了自己的心愿吧！！！</p><p>2021.11.3更新</p><p>间歇跑真香！！！</p><p>开学以来陆陆续续跑了两个月了。跑量大概150km左右，每月80。</p><p>最开始还是死磕五公里，配速不上不下，4:30左右，然后真就感觉越跑越累。</p><p>然后在知乎上问了各路大神后，听取了“练1000不要尝试接触3:30-5:00的配速的建议。</p><p>开始每周2-3次400米间歇。大概是400米间歇1:20跑完，中间休息2min，连续5组。最开始跑真的很吃力，第三组的时候已经没力气了，跑完也很难受…不过不得不说间歇跑对提高1000米速耐真的很有帮助。</p><p>陆陆续续练了有十次吧。现在基本一组400可以1:14内跑完，五组下来不是特别累。其他时间就是5km5分配慢跑，练练有氧顺便减脂。</p><p>然后有一天发现，4:55跑完五公里后，试了试冲刺一下800。结果看时间， 800用了2:35。最后6公里配速4:40，这可比以前累死累活4:30舒服多了。</p><p>所以这里给大家的建议是平时可以慢跑间歇交替进行。慢跑的话25min跑个5公里就好啦，间歇的话400跑不下来就从200开始，这样正好跑200走200，非常方便。相信我，间歇对于1000的进步太大了。</p><p>现在跑1000和以前的跑姿也有了变化。以前都是一个劲冲，姿势从头到尾都是变形的。现在3:00配冲哥800身体基本比较稳，跑姿不会有什么变化，核心力量也提升了。</p><p>马上就要体测啦，希望大家都可以跑到自己满意的成绩！！！</p><p>我也希望今年能进一次3:05….加油！</p><p>————————————————分割线———————————</p><p>先放个图吧。去年（2020）十一月大二体测跑的。</p><p>当时拿着手机用keep记录了一下。刚好满分。（老师测的3:16，keep有些许延迟）</p><p><img src="https://pic3.zhimg.com/80/v2-1e82d5845156be6e836d49bad727fe4f_720w.jpg?source=1940ef5c" alt="img"><br>再随便截一张平时跑步的图<br><img src="https://pic2.zhimg.com/80/v2-0968fb4d245b33ac75818b5c9c077618_720w.jpg?source=1940ef5c" alt="img"></p><p>大学生1000米满分对于正常人来说的确有点难。</p><p>我在初中的时候因为1000米不及格被老师叫着去操场跳蛙跳，间歇跑，练着练着成绩就上来了。记得初中体考的时候3:33（当时满分是3:48）</p><p>高中的时候因为压力大就把参加运动会1500米项目作为自己的目标之一，下了晚自习就跑，每天晚上五公里左右，速度不算快，4:30-5:00配速的样子，当作发泄吧。</p><p>然后我记得高三那次校运会1500米5:15秒，居然还拿了个第三 （可见高中大家的身体素质都比较一般）</p><p>到了大学的跑步频率明显减少了，加了个跑协混混，偶尔参加个校园跑，偶尔跑个五公里，大一校运会1500米前一个月突击训练了一下，然后跑了5:03，第九名 （第一名我记得是4:30好像）大学高手还是很多的。那个时候我记得体育体测1000米好像3:10秒的样子，跑满分还算轻松。</p><p>后来到了大二，因为各种原因运动减少了，很少跑步，然后就有了图一的成绩，3:16，非常吃力，跑完半条命没了。</p><p>然后到了这学期 ，基本一学期没运动过，体重直接重5kg，耐力明显下降了。（最近有开始恢复训练，但跑5公里五分配速都很吃力。）</p><p>可见，要想大学1000米拿满分并且保持这个成绩的话。除了体重要控制的较好以外，一定频率的训练还是必不可少的。我的建议是至少一周2-3次五公里跑或者间歇跑，用自己60-70%的力气，5公里的话一开始配速5:30就行，然后慢慢减。如果练到5公里21:00以内跑完的话，其实1000米跑满分也不算难了。跑进20:00的话，可以尝试一下1500校运会，说不定能拿名次。</p><h2 id="这学期的训练计划">这学期的训练计划</h2><p>截至2022年3月8号，开学的跑量大概也有40km的样子了，用了两周的时间完成了别人一次就能跑完的全马…每次2km-5km不等，配速大概在4：00-4：20不等<br><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/IMG_9868.PNG" alt="IMG_9868"><br>keep上大概记录了25km左右，还有一些在iwatch和搞笑体育上。下面说说近一个月的训练安排吧！！</p><p><strong>每周跑步的频率在3-5次，不宜太多，给自己充分的休息时间(充分的精力撸铁，由于增肌和有氧训练冲突，思考了很久还是决定以增肌为主了)。然后每周安排1-2次的间歇跑，其他时候为有氧跑，下面具体说说这两种吧！</strong></p><h3 id="间歇跑">间歇跑</h3><p>很肝也很爽的训练，不过得等到人稍微少的时候-_-<br>热身跑1圈，配速6：00-6：30左右，身子一定要跑热<br>然后开始400m间歇，每次完成的时间很重要<br>这学期我给自己的目标是1000m跑到3：00（感觉会很难qaq）<br>所以换算下来，400m要在1：12内完成。（等等，真的能做到？）<br>由于这个要求有点太高，那就给自己的休息时间长一点，休息2分钟左右<br>然后继续<br>这样持续下来，最好能跑完5组，也就是2km。<br>最开始可以从圈速1：14开始，慢慢减。（感觉每减1秒都会很难)<br>跑完后再慢跑一圈<br>然后拉伸</p><h3 id="有氧跑">有氧跑</h3><p>这个就很轻松了，就是越轻松越好，热身后跑5-10km吧<br>配速5：00左右就行，5：30也可，调整调整自己的心肺节奏</p><p>另外这学期还是不打算接触半马全马这种超长距离了，一跑感觉自己增肌的努力就白费了<br>加油！！！<br>另外暑期实习面试加油！！！</p>]]></content>
      
      
      <categories>
          
          <category> 运动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中长跑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode刷题笔记--数组</title>
      <link href="/2022/02/05/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84/"/>
      <url>/2022/02/05/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-kOGqQAjb" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="482655706" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#FF4081"    ></div><h1>LeetCode数组专题</h1><h2 id="1-数组的二分查找">1. 数组的二分查找</h2><p>该类型题的一个典型特点是时间复杂度为O(logn)型，且数组都是有序的序列，一般这个时候查找某些元素的位置就会想到二分查找算法。</p><h3 id="704-二分查找">704.二分查找</h3><p>二分查找条件：有序+无重复数组</p><p>注意边界条件和区间的写法</p><ol><li><p>左闭右闭[left≤right]，这时while循环的条件为while(left≤right)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span>(target &lt; nums[mid])&#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">                mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; nums[mid])&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">                mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>左闭右开区间[left,right)，此时的循环条件是while(left&lt;right)</p></li></ol><h3 id="35-搜索插入位置">35.搜索插入位置</h3><h3 id="34-在排序数组中查找元素的第一个和最后一个位置">34.<strong>在排序数组中查找元素的第一个和最后一个位置</strong></h3><p>使用两次二分查找依次寻找要查找的元素的左区间和右区间。做法是仅需对两个边界大小条件对应的操作做出一些修改。</p><p>（当时做的时候是直接使用了两个while循环从mid往两边查找，这样不符合时间复杂度O(log(n))的要求）</p><h3 id="69-求x的平方根">69. 求x的平方根</h3><p>本题使用暴力解法的时间复杂度为O（log(n)），使用二分查找的时间复杂度为O(log(n/2))，实际会更快，注意搜索的区间最开始为1-n/2，并且为了避免 **乘法溢出，**改用除法。</p><h2 id="2-数组的元素移除问题-27">2. 数组的元素移除问题-27</h2><h3 id="27-移除元素-力扣（LeetCode）-leetcode-cn-com">@<a href="https://leetcode-cn.com/problems/remove-element/submissions/">27. 移除元素 - 力扣（LeetCode） (leetcode-cn.com)</a></h3><p>若要在O(n)的复杂度，即一遍扫描完成元素移除，且原地解决，即空间复杂度为1，则需要用到 <strong>快慢指针的方法，慢指针代码要返回的长度，而快指针代表扫描指针。</strong></p><h3 id="26-删除有序数组中的重复项-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项 - 力扣（LeetCode） (leetcode-cn.com)</a></h3><p>只需注意快慢指针的更新</p><h3 id="283-移动零-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零 - 力扣（LeetCode） (leetcode-cn.com)</a></h3><blockquote><p>给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，请你判断二者是否相等。# 代表退格字符。</p></blockquote><blockquote><p>如果相等，返回 true ；否则，返回 false 。</p></blockquote><blockquote><p>注意：如果对空文本输入退格字符，文本继续为空。</p></blockquote><p>此 题我当时想的做法是偏暴力，直接分别对每个字符串求出其实际字符串，时间复杂度为O(N+M)，空间复杂度为O(N+M),因为都需初始化一个StringBuffer.</p><p><strong>最高效的做法：</strong></p><p>使用双指针，因为每个字符是否需要被退格取决于其之后相邻的#，而跟之前的退格无关，因此我们仅仅需要分别对每个字符串同时从最后一个开始递归，然后每次对不需要退格的字符进行比较。</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/%E6%AF%94%E7%89%B9%E6%88%AA%E5%9B%BE2022-01-25-17-15-11.png" alt="比特截图2022-01-25-17-15-11.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = s.length() -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = t.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> skipS = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> skipT = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>||j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                    skipS++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(skipS &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    skipS--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t.charAt(j) == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                    skipT++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(skipT &gt; <span class="number">0</span>)</span><br><span class="line">                    skipT--;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) != t.charAt(j))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="977-有序数组的平方">977. 有序数组的平方</h2><p><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">977. 有序数组的平方 - 力扣（LeetCode） (leetcode-cn.com)</a></p><blockquote><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p></blockquote><blockquote><p>示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p></blockquote><blockquote><p>示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]</p></blockquote><p>要求时间复杂度在O(n)内</p><p>这道题的暴力解法就是平方后再排序输出。但我们知道最快速的排序算法的时间复杂度也是O(nlogn)，不符合题目要求</p><p>这里我们依然用到**双指针法，**先找到临界位置，然后将两个指针的初始位置均设置为最大的负数和最小的正数，然后依次向两边扫描做归并排序，最慢需要n趟扫描。</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/1.png" alt="1.png"></p><h2 id="209-长度最小的子数组—滑动窗口（sliding-window）">209. 长度最小的子数组—滑动窗口（sliding-window）</h2><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209. 长度最小的子数组 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p><strong>本题要求时间复杂度为O(nlog(n))</strong></p><p>我当时的想法是滑动窗口大小从1一直到最大，每次需要循环移动滑动窗口，最后的时间复杂度为O(n*n)。力扣上的效率很低。</p><p>滑动窗口：不断调节子序列的起始位置和终止位置</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/%E6%AF%94%E7%89%B9%E6%88%AA%E5%9B%BE2022-01-26-18-00-01.png" alt="比特截图2022-01-26-18-00-01.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> startIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minLength = <span class="number">0</span>;<span class="comment">//如果未改变该值，则表示没有找到最短数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> endIndex = <span class="number">0</span>; endIndex&lt;nums.length; endIndex++)&#123;</span><br><span class="line">        sum += nums[endIndex];</span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(minLength &gt; <span class="number">0</span>)</span><br><span class="line">                minLength = Math.min((endIndex - startIndex + <span class="number">1</span>), minLength);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                minLength = endIndex - startIndex + <span class="number">1</span>;</span><br><span class="line">            sum -= nums[startIndex++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="904-水果成篮-力扣（LeetCode）-leetcode-cn-com"><a href="https://leetcode-cn.com/problems/fruit-into-baskets/">904. 水果成篮 - 力扣（LeetCode） (leetcode-cn.com)</a></h3><p><a href="https://leetcode-cn.com/problems/fruit-into-baskets/">904. 水果成篮 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>我最开始想到了用滑动窗口，即使用startIndex和endIndex,对于每个递增的endIndex,都对应一个最小的startIndex,即有f(endIndex) = startIndex, f函数表示使得从startIndex到endIndex的所有水果成功放入蓝中的startIndex的最小值。可见该函数是一个递增函数，因此使用滑动窗口一定能解决出来。</p><p>但关键问题在于如何存储篮子中放置水果的情况，对此我是直接用了两个二维数组分别存储每个篮子内放置的水果的种类和数量，这样做还要在每次增加和删除时作两次比较，降低了算法效率，这样得到了如下的结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(<span class="keyword">int</span>[] fruits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> startIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] basket = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] basketNum = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> endIndex = <span class="number">0</span>; endIndex &lt; fruits.length; endIndex++)&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;<span class="number">2</span> ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(basket[i] == -<span class="number">1</span> || fruits[endIndex] == basket[i])&#123;</span><br><span class="line">                basketNum[i]++;</span><br><span class="line">                basket[i] = fruits[endIndex];</span><br><span class="line">                sum++;</span><br><span class="line">                total = Math.max(sum,total);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sum--;</span><br><span class="line">            <span class="keyword">if</span>(basket[<span class="number">0</span>] == fruits[startIndex])&#123;</span><br><span class="line">                <span class="keyword">if</span>(basketNum[<span class="number">0</span>] == <span class="number">1</span>)</span><br><span class="line">                    basket[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">                basketNum[<span class="number">0</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(basket[<span class="number">1</span>] == fruits[startIndex])&#123;</span><br><span class="line">                <span class="keyword">if</span>(basketNum[<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">                    basket[<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">                basketNum[<span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">            startIndex++;</span><br><span class="line">            endIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/%E6%AF%94%E7%89%B9%E6%88%AA%E5%9B%BE2022-01-26-18-44-31.png" alt="比特截图2022-01-26-18-44-31.png"></p><p>实际上，对于这种情况最好的存储办法是使用<strong>HashMap</strong>，存放若干键值对的集合。修改后的写法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(<span class="keyword">int</span>[] tree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        Counter count = <span class="keyword">new</span> Counter();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tree.length; ++j) &#123;</span><br><span class="line">            count.add(tree[j], <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (count.size() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                count.add(tree[i], -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (count.get(tree[i]) == <span class="number">0</span>)</span><br><span class="line">                    count.remove(tree[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containsKey(k) ? <span class="keyword">super</span>.get(k) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        put(k, get(k) + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而实际上速度反而慢了。。。</p><p><img src="https://joes-bucket.oss-cn-shanghai.aliyuncs.com/img/%E6%AF%94%E7%89%B9%E6%88%AA%E5%9B%BE2022-01-26-18-59-05.png" alt="比特截图2022-01-26-18-59-05.png"></p><h3 id="76-最小覆盖子串（困难）—字节在线一面原题">76. 最小覆盖子串（困难）—字节在线一面原题</h3><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/solution/zui-xiao-fu-gai-zi-chuan-by-leetcode-solution/">最小覆盖子串 - 最小覆盖子串 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>方法一： 使用滑动窗口方法（我当时解题使用的方法）也是最终答案给出的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Character,Integer&gt; orign=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Character,Integer&gt;window=<span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">//记录滑动窗口中的character及频率</span></span><br><span class="line">    <span class="keyword">int</span> ansL=-<span class="number">1</span>;<span class="comment">//全局的左指针</span></span><br><span class="line">    <span class="keyword">int</span> ansR=-<span class="number">1</span>;<span class="comment">//全局的右指针</span></span><br><span class="line">    <span class="keyword">int</span> len=Integer.MAX_VALUE; <span class="comment">//记录每次匹配符合时子串的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length() ; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c=t.charAt(i);</span><br><span class="line">            orign.put(c,orign.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左、右指针</span></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (r&lt;s.length())&#123;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="comment">//可能window中一个字符出现的次数要多于我们要比对的那个字符串中字符的个数</span></span><br><span class="line">            <span class="keyword">if</span>(r&lt;s.length()&amp;&amp;orign.containsKey(s.charAt(r)))&#123;</span><br><span class="line">                window.put(s.charAt(r),window.getOrDefault(s.charAt(r),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (check()&amp;&amp;l&lt;=r)&#123; <span class="comment">//这里检查左指针是否可以收缩窗口，注意左指针可以收缩窗口的条件在于：窗口中包含了字符t</span></span><br><span class="line">                <span class="comment">//能够走到这里就说明已经符合要求了,但是要找到全局最小的子串，所以每次都要判断一下</span></span><br><span class="line">                <span class="keyword">if</span>(r-l+<span class="number">1</span>&lt;len)&#123;</span><br><span class="line">                    ansL=l;</span><br><span class="line">                    ansR=r;</span><br><span class="line">                    len=r-l+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果window中的左边出现了t中的字符，直接减1，然后看是否还能满足完全覆盖的要求</span></span><br><span class="line">                <span class="keyword">if</span>(orign.containsKey(s.charAt(l)))&#123;</span><br><span class="line">                    window.put(s.charAt(l),window.getOrDefault(s.charAt(l),<span class="number">0</span>)-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansR==-<span class="number">1</span>?<span class="string">&quot;&quot;</span>:s.substring(ansL,ansR+<span class="number">1</span>); <span class="comment">//ansR==-1 说明没有符合的，就返回空字符串</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//用于检测是否窗口中是否完全覆盖了子串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry e:orign.entrySet())&#123;</span><br><span class="line">             <span class="keyword">int</span> val= (<span class="keyword">int</span>) e.getValue();</span><br><span class="line">             <span class="keyword">if</span>(window.getOrDefault(e.getKey(), <span class="number">0</span>)&lt;val)&#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补充：遍历Hashmap的几种方法：">补充：遍历Hashmap的几种方法：</h3><ol><li><p>使用迭代器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">　Iterator iter = map.entrySet().iterator();</span><br><span class="line">　<span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">　Map.Entry entry = (Map.Entry) iter.next();</span><br><span class="line">　Object key = entry.getKey();</span><br><span class="line">　Object val = entry.getValue();</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure></li><li><p>For each遍历：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">entry.getKey();</span><br><span class="line">entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：最坏情况下左右指针对 s 的每个元素各遍历一遍，哈希表中对 s中的每个元素各插入、删除一次，对 t 中的元素各插入一次。每次检查是否可行会遍历整个 t 的哈希表，哈希表的大小与字符集的大小有关，设字符集大小为 C，则渐进时间复杂度为 O(C⋅∣s∣+∣t∣).</p></li></ol><h2 id="59-螺旋矩阵2—模拟行为">59.螺旋矩阵2—模拟行为</h2><p><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>无特殊算法，注意边界条件即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        result[i][j] = num;</span><br><span class="line">        <span class="keyword">while</span>(num &lt; n*n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span> &lt; n &amp;&amp; result[i][j+<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; (i-<span class="number">1</span>&lt;<span class="number">0</span> || result[i-<span class="number">1</span>][j] != <span class="number">0</span>))</span><br><span class="line">                result[i][++j] = ++num;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i+<span class="number">1</span> &lt;n &amp;&amp; result[i+<span class="number">1</span>][j] == <span class="number">0</span> &amp;&amp; (j+<span class="number">1</span> == n || result[i][j+<span class="number">1</span>] != <span class="number">0</span>))</span><br><span class="line">                result[++i][j] = ++num;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; result[i][j-<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; (i+<span class="number">1</span> == n || result[i+<span class="number">1</span>][j] != <span class="number">0</span>))</span><br><span class="line">                result[i][--j] = ++num;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i-<span class="number">1</span> &gt;=<span class="number">0</span> &amp;&amp; result[i-<span class="number">1</span>][j] == <span class="number">0</span> &amp;&amp; (j-<span class="number">1</span> &lt;<span class="number">0</span> || result[i][j-<span class="number">1</span>] != <span class="number">0</span>))</span><br><span class="line">                result[--i][j] = ++num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="54-螺旋矩阵">54. 螺旋矩阵</h3><p><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵 - 力扣（LeetCode） (leetcode-cn.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
